{"meta":{"title":"hydd's blog","subtitle":"","description":"","author":"hydd","url":"http://hydd.cf","root":"/"},"pages":[{"title":"404","date":"2020-09-30T05:49:05.000Z","updated":"2020-09-30T06:17:40.281Z","comments":true,"path":"/404.html","permalink":"http://hydd.cf/404.html","excerpt":"","text":""},{"title":"分类","date":"2020-09-29T16:00:00.000Z","updated":"2020-09-30T06:06:27.120Z","comments":true,"path":"categories/index.html","permalink":"http://hydd.cf/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-29T16:00:00.000Z","updated":"2020-09-30T06:05:48.846Z","comments":true,"path":"tags/index.html","permalink":"http://hydd.cf/tags/index.html","excerpt":"","text":""},{"title":"模板","date":"2020-09-30T11:25:33.000Z","updated":"2020-09-30T11:30:40.238Z","comments":true,"path":"template/index.html","permalink":"http://hydd.cf/template/index.html","excerpt":"","text":"此博客不对外公开，有些代码/算法讲解是从网上copy的，所以应该不存在版权问题（？） 若有人公开了这篇博客的密码，请联系我。QQ：3058728305 0. 一些奇怪的东西 常用结论： 普通幂转第二类斯特林数：$i^k=\\sum\\limits_{j=1}^{i}S_{k,j}\\times C_{i,j}\\times j! $。 第二类斯特林数求自然数幂和：$\\sum\\limits ^{n}_{i=0}i^k= \\sum\\limits_{j=1}^{n}S_{k,j}\\times j!\\times C_{n+1,j+1}$。 $\\rm min-max$容斥：$\\max(S)=\\sum_{T \\subseteq S}(-1)^{|T|+1}\\min(T)$，$\\min(S)=\\sum_{T \\subseteq S}(-1)^{|T|+1}\\max(T)$ $\\gcd-\\mathrm{lcm}$容斥：$\\mathrm{lcm}(T)=\\prod_{S\\in T}\\gcd(S)^{(-1)^{|S|+1}}$ 多项式开根：若$B’^2(x)\\equiv A(x) (mod\\ x^{\\frac{n}{2}})$，$B^2(x)\\equiv A(x) (mod\\ x^{n})$，则有以下等式成立：$B(x)\\equiv \\dfrac{A(x)+B’^2(x)}{2B’(x)} (mod\\ x^n)$。 0.1 读入优化 复习完成！！！ 1234567891011121314151617181920212223char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;char readop()&#123; char ch=Getchar(); while (ch&lt;&#x27;A&#x27;||ch&gt;&#x27;Z&#x27;) ch=Getchar(); return ch;&#125; 0.2 输出优化123456789101112131415161718192021char pbuf[100000],*pp=pbuf;void pc(const char c) &#123; if (pp-pbuf==100000) fwrite(pbuf,1,100000,stdout),pp=pbuf; *pp++=c;&#125;void write(int x) &#123; static int sta[35]; if (x&lt;0)&#123; pc(&#x27;-&#x27;); x=-x; &#125; int top=0; do&#123; sta[top++]=x%10; x/=10; &#125; while(x); while (top) pc(sta[--top]+&#x27;0&#x27;);&#125;void myfflush()&#123; fwrite(pbuf,1,pp-pbuf,stdout);&#125; 0.3 取模优化123inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125; 1. 数论1.1 预处理阶乘和阶乘逆元1234567fac[0]=1; for (int i=1;i&lt;=10000000;i++) fac[i]=fac[i-1]*i%Mod;inv[1]=1; for (int i=2;i&lt;=10000000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;inv[0]=1; for (int i=1;i&lt;=10000000;i++) inv[i]=inv[i-1]*inv[i]%Mod;ll C(int n,int m)&#123; if (n&lt;m) return 0; return 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;&#125; 1.2 快速幂12345678ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125; 1.3 gcd&amp;lcm12345int gcd(int a,int b)&#123; if (!b) return a; return gcd(b,a%b);&#125;int lcm(int a,int b)&#123; return 1ll*a/gcd(a,b)*b;&#125; 1.4 CRT12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int n;ll a[11],b[11];ll mult(ll a,ll b,ll mod)&#123; if (a&lt;b) swap(a,b); ll ans=0; while (b)&#123; if (b&amp;1) ans=(ans+a)%mod; a=(a&lt;&lt;1)%mod; b&gt;&gt;=1; &#125; return ans;&#125;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if (!b)&#123; x=1; y=0; return; &#125; exgcd(b,a%b,x,y); ll tmp=x; x=y; y=tmp-a/b*y;&#125;ll CRT(int n)&#123; ll x,y; ll ans=0,lcm=1; for (int i=1;i&lt;=n;i++) lcm*=b[i]; for (int i=1;i&lt;=n;i++)&#123; ll tmp=lcm/b[i]; exgcd(tmp,b[i],x,y); x=(x%b[i]+b[i])%b[i]; ans=(ans+mult(mult(tmp,x,lcm),a[i],lcm))%lcm; &#125; return (ans+lcm)%lcm;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lld&quot;,&amp;b[i]); a[i]=(a[i]%b[i]+b[i])%b[i]; &#125; printf(&quot;%lld\\n&quot;,CRT(n)); return 0;&#125; 1.5 exgcd&amp;excrt 背过了 考虑合并两个方程 $x\\equiv a_1(\\operatorname{mod} m_1),x\\equiv a_2(\\operatorname{mod} m_2)$。 那么，有 $x=a_1+k_1\\times m_1,x=a_2+k_2\\times m_2$。 $k_2\\times m_2-k_1\\times m_1=a_1-a_2$。 令 $c=a_1-a_2$，$g=gcd(m_2,m_1)$。 那么，若 $g\\nmid c$，则方程无解。否则 $g\\mid c,\\frac{c}{g}\\in \\Z$。 我们可以用 $exgcd$ 求出 $k_2’\\times m_2+k_1’\\times m_1=g$ 中满足条件的 $k_1’$。 将两边同时乘 $\\frac{c}{g}$，即 $k_1’,k_2’$ 乘上 $\\frac cg$，右边变成 $c$ 。 我们得到了 $k_2’\\times m_2+k_1’\\times m_1=c$ 的解 $k_1’$。可以将 $k_1’ \\mod m_2$。 但是注意，我们的原方程是 $k_2\\times m_2-k_1\\times m_1=a_1-a_2$，故 $k_1=-k_1’$。 也就是 $x=a_1-k_1’\\times m_1$。我们就求出了一个解 $x_0$。那么通解是 $x\\equiv x_0(\\operatorname{mod} \\operatorname{lcm}(m_1,m_2))$。 1234567891011121314151617181920212223typedef long long ll;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if (!b)&#123; x=1; y=0; return a; &#125; ll g=exgcd(b,a%b,y,x); y-=a/b*x; return g;&#125;ll a[N],m[N];ll excrt()&#123; ll M=m[1],A=a[1],x,y,d; for (int i=2;i&lt;=n;i++)&#123; d=exgcd(M,m[i],x,y); if ((A-a[i])%d) return -1; x=(A-a[i])/d*x%m[i]; A-=M*x; M=M/d*m[i]; A%=M; &#125; return (A%M+M)%M;&#125; 1.6 Pollard Rho 输出 $n$ 的最大质因子（$1\\leqslant n\\leqslant 10^{18}$） todo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;#define ctz __builtin_ctzllusing namespace std;typedef long long ll;ll ans;/*inline ll mul(ll x,ll y,ll Mod)&#123; ll ret=x*y-((ll)((long double)x/Mod*y+0.5))*Mod; return (ret%Mod+Mod)%Mod;&#125;*/inline ll mul(ll x,ll y,ll p)&#123; return (__int128)x*y%p;&#125;inline ll qpow(ll x,ll a,ll Mod)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=mul(res,x,Mod); x=mul(x,x,Mod); a&gt;&gt;=1; &#125; return res;&#125;inline ll rdm()&#123; return 1ll*rand()&lt;&lt;31|rand();&#125;ll gcd(ll x,ll y)&#123; if (!y) return x; return gcd(y,x%y);&#125;bool Miller_Rabin(ll n)&#123; if (n==2||n==3) return true; if (!(n&amp;1)||(n==1)||!(n%3)) return false; ll p=n-1,m=0; while (!(p&amp;1)) p&gt;&gt;=1,++m; int Case=8; while (Case--)&#123; ll lst=qpow(rdm()%(n-1)+1,p,n),now=lst; for (int i=1;i&lt;=m;i++)&#123; now=mul(now,now,n); if (now==1&amp;&amp;lst!=1&amp;&amp;lst!=n-1) return false; lst=now; &#125; if (now!=1) return false; &#125; return true;&#125;ll Pollard_Rho(ll n,int c)&#123; ll i=1,k=2,x=rand()%(n-1)+1,y=x,sum=1; while (true)&#123; i++; x=(mul(x,x,n)+c)%n; sum=mul(sum,(y-x+n)%n,n); if (x==y||!sum) return n; if (i==k||i%127==0)&#123; int d=gcd(sum,n); if (d!=1) return d; if (i==k)&#123; y=x; k&lt;&lt;=1;&#125; &#125; &#125;&#125;void work(ll n)&#123; if (n&lt;=ans) return; if (Miller_Rabin(n))&#123; ans=max(ans,n); return; &#125; ll tmp=n; while (tmp==n) tmp=Pollard_Rho(n,rand()%n); while (n%tmp==0) n/=tmp; work(tmp); work(n);&#125;int main()&#123; srand(time(NULL)); int T; ll x; scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%lld&quot;,&amp;x); if (Miller_Rabin(x))&#123; puts(&quot;Prime&quot;); continue;&#125; ans=0; work(x); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;//贴个超级短的：LL pollardRho(LL n, int a)&#123; LL x=2,y=2,d=1; while(d==1)&#123; x=(x*x+a)%n; y=(y*y+a)%n;y=(y*y+a)%n; d=gcd(abs(x-y),n); &#125; if(d==n) return pollardRho(n,a+1); return d;&#125; 1.7 欧拉筛（线性筛）最小质因子 复习完成 1234567891011//注意1不为质数 for (int i=2;i&lt;=n;i++)&#123; if (!lst[i])&#123; lst[i]=i; prime[++cnt]=i; &#125; for (int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123; lst[i*prime[j]]=prime[j]; if (i%prime[j]==0) break; &#125;&#125; 1.8 BSGS todo 12345678910111213141516int BSGS(ll a,ll b)&#123; int blo=(int)(sqrt(p)+1); ll base=b; for(int i=0;i&lt;blo;i++)&#123; myhash[base]=i; base=base*a%Mod; &#125; ll tmp=1; base=qpow(a,blo); for(int i=1;i&lt;=blo+1;i++)&#123; tmp=tmp*base%Mod; int t=tmp; if (myhash.count(t)) return i*blo-myhash[t]; &#125; return -1;&#125; 1.9 欧拉筛（线性筛）mu/phi 复习完成 12345678910111213141516171819202122int cnt,mu[110000],p[110000],phi[110000];bool vis[110000];void init(int n)&#123; vis[1]=1;//注意，1不是质数 phi[1]=0; mu[1]=1; for (int i=2;i&lt;=n;i++)&#123; if (!vis[i])&#123; p[++cnt]=i; phi[i]=i-1; mu[i]=-1; &#125; for (int j=1;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;j++)&#123; vis[i*p[j]]=true; if (i%p[j]==0)&#123; phi[i*p[j]]=phi[i]*p[j]; mu[i*p[j]]=0; break; &#125; phi[i*p[j]]=phi[i]*(p[j]-1); mu[i*p[j]]=-mu[i]; &#125; &#125;&#125; 2.数据结构2.1 树状数组 没必要 单点加，区间求和12345678void add(int *tree,int x,int y)&#123; for (;x&lt;=N;x+=x&amp;-x) tree[x]+=y;&#125;int getsum(int *tree,int x)&#123; int sum=0; for (;x;x-=x&amp;(-x)) sum+=tree[x]; return sum;&#125; 区间加，区间求和123456789101112131415161718192021222324252627282930313233/* b[i]=a[i]-a[i-1] a[1] + a[2] + ... + a[n] = (b[1]) + (b[1]+b[2]) + ... + (b[1]+b[2]+...+b[n]) = n*b[1] + (n-1)*b[2] +... +b[n] = n * (b[1]+b[2]+...+b[n]) - (0*b[1]+1*b[2]+...+(n-1)*b[n]) sum1[i] = \\sum b[i],sum2[i] = \\sum b[i]*(i-1)*/int n,a[N];int sum1[N],sum2[N];void change(int x,int y)&#123; for (int i=x;i&lt;=n;i+=(i&amp;-i))&#123; sum1[i]+=y; sum2[i]+=y*(x-1); &#125;&#125;void range_change(int l,int r,int y)&#123; change(l,y); change(r+1,-y);&#125;int query(int x)&#123; int res=0; for (int i=x;i&gt;=1;i-=(i&amp;-i)) res+=x*sum1[i]-sum2[i]; return res;&#125;int range_query(int l,int r)&#123; return query(r)-query(l-1);&#125; int main()&#123; for (int i=1;i&lt;=n;i++) change(i,a[i]-a[i-1]); //[l,r] +x range_change(l,r,x); //sum(l,r) range_query(l,r) return 0;&#125; 2.2 线段树（ 区间加，区间求和） 没必要 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#define ls ((now)&lt;&lt;1)//左儿子 #define rs ((now)&lt;&lt;1|1)//右儿子 using namespace std;const int MAXN=110000;typedef long long ll;int n,m;ll a[MAXN];//n-&gt;区间长度，m-&gt;询问个数，a-&gt;区间初始值 struct node&#123; ll val,add;//线段树的值，加法标记 &#125; tree[MAXN&lt;&lt;2];void pushup(int now)&#123;//上传标记 tree[now].val=tree[ls].val+tree[rs].val; &#125;void pushdown(int now,int l,int r)&#123;//下传标记 int mid=(l+r)&gt;&gt;1; //更新实际值 tree[ls].val+=tree[now].add*(mid-l+1); tree[rs].val+=tree[now].add*(r-mid); //下传加法标记 tree[ls].add+=tree[now].add; tree[rs].add+=tree[now].add; //清空当前标记 tree[now].add=0;&#125;void buildtree(int now,int l,int r)&#123;//建树 //零标记 tree[now].add=0; if (l==r)&#123; tree[now].val=a[l];//初始化 return; &#125; int mid=(l+r)&gt;&gt;1; buildtree(ls,l,mid); buildtree(rs,mid+1,r);//建子树 pushup(now);//上传更新 &#125;void change(int now,int l,int r,int x,int y,ll k)&#123; if (l&gt;r||x&gt;y) return; if (l==x&amp;&amp;r==y)&#123; tree[now].add+=k;//更新加法标记 tree[now].val+=k*(r-l+1);//更新值 return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(now,l,r);//先下传 if (y&lt;=mid) change(ls,l,mid,x,y,k);//更新左子树 else if (x&gt;mid) change(rs,mid+1,r,x,y,k);//更新右子树 else change(ls,l,mid,x,mid,k),change(rs,mid+1,r,mid+1,y,k);//更新左右子树 pushup(now);//上传标记 &#125;ll query(int now,int l,int r,int x,int y)&#123; if (l&gt;r||x&gt;y) return 0; if (l==x&amp;&amp;r==y) return tree[now].val;//返回实际值 int mid=(l+r)&gt;&gt;1; pushdown(now,l,r);//先下传 if (y&lt;=mid) return query(ls,l,mid,x,y);//询问左子树 else if (x&gt;mid) return query(rs,mid+1,r,x,y);//询问右子树 else return query(ls,l,mid,x,mid)+query(rs,mid+1,r,mid+1,y);//将左右子树的询问答案相加 pushup(now);//上传标记 &#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);//读入初始值 int op,x,y; ll k; buildtree(1,1,n);//建树 while (m--)&#123; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;x,&amp;y); if (op==1)&#123;//1代表加 scanf(&quot;%lld&quot;,&amp;k); change(1,1,n,x,y,k); &#125; else printf(&quot;%lld\\n&quot;,query(1,1,n,x,y));//其它数代表询问 &#125; return 0;&#125; 2.3 splay todo？？？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF=1e9;int n,m,op,x,a[110000];int root,sz,tag[110000],ch[110000][2],f[110000],cnt[110000],key[110000],size[110000];inline void clear(int x)&#123; ch[x][0]=ch[x][1]=f[x]=cnt[x]=key[x]=size[x]=0;&#125;inline int get(int x)&#123; return ch[f[x]][1]==x;&#125;inline void update(int x)&#123; if (x)&#123; size[x]=cnt[x]; if (ch[x][0]) size[x]+=size[ch[x][0]]; if (ch[x][1]) size[x]+=size[ch[x][1]]; &#125;&#125;inline void pushdown(int x)&#123; if (x&amp;&amp;tag[x])&#123; tag[ch[x][0]]^=1; tag[ch[x][1]]^=1; swap(ch[x][0],ch[x][1]); tag[x]=0; &#125;&#125;inline void rotate(int x)&#123; pushdown(f[x]); pushdown(x); int fa=f[x],gfa=f[fa],dir=get(x); ch[fa][dir]=ch[x][dir^1]; f[ch[fa][dir]]=fa; f[fa]=x; ch[x][dir^1]=fa; f[x]=gfa; if (gfa) ch[gfa][ch[gfa][1]==fa]=x; update(fa); update(x);&#125;void splay(int x,int goal=0)&#123; for (int fa;(fa=f[x])!=goal;rotate(x)) if (f[fa]!=goal) rotate((get(x)==get(fa))?fa:x); if (!goal) root=x;&#125;inline int build(int l,int r,int fa)&#123; if (l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; int now=++sz; key[now]=a[mid]; f[now]=fa; cnt[now]=1; tag[now]=0; ch[now][0]=build(l,mid-1,now); ch[now][1]=build(mid+1,r,now); update(now); return now;&#125;inline void insert(int v)&#123; if (!root)&#123; root=++sz; ch[sz][0]=ch[sz][1]=f[sz]=0; key[sz]=v; cnt[sz]=size[sz]=1; return; &#125; int now=root,fa=0; while (true)&#123; if (key[now]==v)&#123; cnt[now]++; update(now); update(fa); splay(now); break; &#125; fa=now; now=ch[now][key[now]&lt;v]; if (!now)&#123; sz++; ch[sz][0]=ch[sz][1]=0; key[sz]=v; size[sz]=1; cnt[sz]=1; f[sz]=fa; ch[fa][key[fa]&lt;v]=sz; update(fa); splay(sz); break; &#125; &#125;&#125;inline int Rank(int v)&#123; int ans=0,now=root; while (true)&#123; if (v&lt;key[now]) now=ch[now][0]; else&#123; ans+=(ch[now][0]?size[ch[now][0]]:0); if (v==key[now])&#123; splay(now); return ans+1; &#125; ans+=cnt[now]; now=ch[now][1]; &#125; &#125;&#125;inline int find(int x)&#123; int now=root; while (true)&#123; pushdown(now); if (ch[now][0]&amp;&amp;x&lt;=size[ch[now][0]]) now=ch[now][0]; else&#123; int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now]; if (x&lt;=temp) return now;//key[now]; x-=temp; now=ch[now][1]; &#125; &#125;&#125;inline int pre()&#123; int now=ch[root][0]; while (ch[now][1]) now=ch[now][1]; return now;&#125; inline int next()&#123; int now=ch[root][1]; while (ch[now][0]) now=ch[now][0]; return now;&#125;inline void del(int x)&#123; Rank(x); if (cnt[root]&gt;1)&#123; cnt[root]--; update(root); return; &#125; if (!ch[root][0]&amp;&amp;!ch[root][1])&#123; clear(root); root=0; return; &#125; if (!ch[root][0])&#123; int oldroot=root; root=ch[root][1]; f[root]=0; clear(oldroot); return; &#125; else if (!ch[root][1])&#123; int oldroot=root; root=ch[root][0]; f[root]=0; clear(oldroot); return; &#125; int leftbig=pre(),oldroot=root; splay(leftbig); f[ch[oldroot][1]]=root; ch[root][1]=ch[oldroot][1]; clear(oldroot); update(root); return;&#125;inline void print(int now)&#123; pushdown(now); if (ch[now][0]) print(ch[now][0]); if (key[now]!=-INF&amp;&amp;key[now]!=INF) printf(&quot;%d &quot;,key[now]); if (ch[now][1]) print(ch[now][1]);&#125;void reverse(int x,int y)&#123;//翻转[x,y] int a=find(x); int b=find(y+2); splay(a); splay(b,a); tag[ch[ch[root][1]][0]]^=1;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); insert(-INF); insert(INF); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d%d&quot;,&amp;op,&amp;x); switch (op)&#123; case 1: insert(x); break; case 2: del(x); break; case 3: printf(&quot;%d\\n&quot;,Rank(x)-1); break; case 4: printf(&quot;%d\\n&quot;,key[find(x+1)]); break; case 5: insert(x); printf(&quot;%d\\n&quot;,key[pre()]); del(x); break; case 6: insert(x); printf(&quot;%d\\n&quot;,key[next()]); del(x); break; &#125; &#125; return 0;&#125; 2.4 左偏树 敲过了1234567891011121314struct pq&#123; int v[110000]; int l[110000],r[110000],d[110000]; int merge(int x,int y)&#123; if (!x||!y) return x|y; if (v[x]&lt;v[y]) swap(x,y); r[x]=merge(r[x],y); if (d[r[x]]&gt;d[l[x]]) swap(l[x],r[x]); d[x]=d[r[x]]+1; return x; &#125; void pop(int &amp;x)&#123; x=merge(l[x],r[x]);&#125; int top(int x)&#123; return v[x];&#125;&#125; que; 2.5 LCT（Link-Cut Tree） 这部分代码敲了好几遍了，易错点 把fa[x]和f[x]混起来写。。。 access中加注释的地方写成nroot(x)。 link的时候写成f[y]=x。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;algorithm&gt; #define ls c[x][0]#define rs c[x][1]using namespace std;int n,m,type,x,y,f[310000],c[310000][2],v[310000],s[310000],st[310000];bool r[310000];inline bool nroot(int x)&#123; return x==c[f[x]][0]||x==c[f[x]][1];&#125;inline void pushup(int x)&#123; s[x]=s[ls]^s[rs]^v[x];&#125;inline void pushr(int x)&#123; swap(ls,rs); r[x]^=1;&#125;inline void pushdown(int x)&#123; if (r[x])&#123; if (ls) pushr(ls); if (rs) pushr(rs); r[x]=0; &#125;&#125;inline int dir(int x)&#123; return c[f[x]][1]==x;&#125;void rotate(int x)&#123; int y=f[x],z=f[y],k=dir(x),w=c[x][!k]; if (nroot(y)) c[z][dir(y)]=x; c[x][!k]=y; c[y][k]=w; if (w) f[w]=y; f[y]=x; f[x]=z; pushup(y);&#125;void splay(int x)&#123; int y=x,z=0; st[++z]=y; while (nroot(y)) st[++z]=y=f[y]; while (z) pushdown(st[z--]); while (nroot(x))&#123; y=f[x]; if (nroot(y)) rotate(dir(x)!=dir(y)?x:y); rotate(x); &#125; pushup(x);&#125;void access(int x)&#123; for (int y=0;x;y=x,x=f[y])&#123;//注意此处，x是打通到整棵树的根的路径，所以是;x;而不是;nroot(x);。 splay(x); rs=y; pushup(x); &#125; &#125;inline void makeroot(int x)&#123; access(x); splay(x); pushr(x);&#125;int findroot(int x)&#123; access(x); splay(x); while (ls)&#123; pushdown(x); x=ls; &#125; splay(x); return x;&#125;inline void split(int x,int y)&#123; makeroot(x); access(y); splay(y);&#125;void link(int x,int y)&#123; makeroot(x); if (findroot(y)!=x) f[x]=y;&#125;void cut(int x,int y)&#123; makeroot(x); if (findroot(y)==x&amp;&amp;f[y]==x&amp;&amp;!c[y][0])&#123; f[y]=0; c[x][1]=0; pushup(x); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;v[i]); while (m--)&#123; scanf(&quot;%d%d%d&quot;,&amp;type,&amp;x,&amp;y); switch (type)&#123; case 0: split(x,y); printf(&quot;%d\\n&quot;,s[y]); break; case 1: link(x,y); break; case 2: cut(x,y); break; case 3: splay(x); v[x]=y; break; &#125; &#125; return 0;&#125; 2.6 虚树 背完了 现在改为luogu2495的某篇题解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;#define il inline#define re register#define debug printf(&quot;Now is Line : %d\\n&quot;,__LINE__)#define file(a) freopen(#a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(#a&quot;.out&quot;,&quot;w&quot;,stdout)#define int long long#define inf 123456789000000000#define mod 1000000007il int read()&#123; re int x = 0, f = 1; re char c = getchar(); while(c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; if(c == &#x27;-&#x27;) f = -1; c = getchar();&#125; while(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - 48, c = getchar(); return x * f;&#125;#define maxn 250005struct edge&#123; int v, w, next;&#125;e[maxn &lt;&lt; 1];int n, m, head[maxn], cnt, is[maxn], mi[maxn], dfn[maxn], col, t;int size[maxn], fa[maxn], top[maxn], son[maxn], dep[maxn], s[maxn];vector&lt;int&gt;v[maxn];il void add(int u, int v, int w)&#123; e[++ cnt] = (edge)&#123;v, w, head[u]&#125;; head[u] = cnt;&#125;il bool cmp(int a, int b)&#123;return dfn[a] &lt; dfn[b];&#125;il void dfs1(int u, int fr)&#123; size[u] = 1, fa[u] = fr, dep[u] = dep[fr] + 1; for(re int i = head[u]; i; i = e[i].next) &#123; int v = e[i].v; if(v == fr) continue; mi[v] = min(mi[u], e[i].w); dfs1(v, u), size[u] += size[v]; if(size[son[u]] &lt; size[v]) son[u] = v; &#125;&#125;il void dfs2(int u, int fr)&#123; top[u] = fr, dfn[u] = ++ col; if(!son[u]) return; dfs2(son[u], fr); for(re int i = head[u]; i; i = e[i].next) &#123; int v = e[i].v; if(v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v); &#125;&#125;il int lca(int a, int b)&#123; while(top[a] != top[b]) dep[top[a]] &gt; dep[top[b]] ? a = fa[top[a]] : b = fa[top[b]]; return dep[a] &lt; dep[b] ? a : b;&#125;il void push(int x)&#123; if(t == 1) &#123;s[++ t] = x;return;&#125; int l = lca(x, s[t]); if(l == s[t]) return; while(t &gt; 1 &amp;&amp; dfn[s[t - 1]] &gt;= dfn[l]) v[s[t - 1]].push_back(s[t]), --t; if(s[t] != l) v[l].push_back(s[t]), s[t] = l; s[++ t] = x;&#125;il int dp(int u)&#123; if(v[u].size() == 0) return mi[u]; int temp = 0; for(re int i = 0; i &lt; v[u].size(); ++ i) temp += dp(v[u][i]); v[u].clear(); return min(mi[u], temp);&#125;signed main()&#123; file(a); n = read(); for(re int i = 1; i &lt; n; ++ i) &#123; int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w); &#125; mi[1] = inf, dfs1(1, 0), dfs2(1, 1); int T = read(); while(T --) &#123; m = read(); for(re int i = 1; i &lt;= m; ++ i) is[i] = read(); sort(is + 1, is + m + 1, cmp); s[t = 1] = 1; for(re int i = 1; i &lt;= m; ++ i) push(is[i]); while(t &gt; 0) v[s[t - 1]].push_back(s[t]), --t; printf(&quot;%lld\\n&quot;, dp(1)); &#125; return 0;&#125; 3.网络流&amp;图论3.1 最大流（ISAP）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int INF=0x3f3f3f3f;int n,m,s,t,gap[11000],cur[11000],d[11000],que[11000];int edgenum,vet[210000],val[210000],Next[210000],Head[11000];void addedge(int u,int v,int cost)&#123; vet[++edgenum]=v; val[edgenum]=cost; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void bfs()&#123; memset(gap,0,sizeof(gap)); memset(d,0,sizeof(d)); d[t]=1; gap[1]++; int head=1,tail=1; que[1]=t; while (head&lt;=tail)&#123; int u=que[head++]; for (int e=Head[u];e;e=Next[e]) if (!d[vet[e]])&#123; d[vet[e]]=d[u]+1; gap[d[vet[e]]]++; que[++tail]=vet[e]; &#125; &#125;&#125;int dfs(int u,int flow)&#123; if (u==t) return flow; int used=0; for (int &amp;e=cur[u];e;e=Next[e]) if (d[u]==d[vet[e]]+1)&#123; int tmp=dfs(vet[e],min(flow,val[e])); used+=tmp; flow-=tmp; val[e]-=tmp; val[e^1]+=tmp; if (!flow) return used; &#125; if (!(--gap[d[u]])) d[s]=n+1; d[u]++; gap[d[u]]++; cur[u]=Head[u]; return used;&#125;int maxflow()&#123; bfs(); for (int i=1;i&lt;=n;i++) cur[i]=Head[i]; int ans=dfs(s,INF); while (d[s]&lt;=n) ans+=dfs(s,INF); return ans;&#125;int main()&#123; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); int u,v,cost; edgenum=1; for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;cost); addedge(u,v,cost); addedge(v,u,0); &#125; printf(&quot;%d\\n&quot;,maxflow()); return 0;&#125; 3.2 最大流（dinic） 背过了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int INF=0x3f3f3f3f;int n,m,s,t,maxflow;int vis[11000];//是否到达过该点 int dep[11000]; int edgenum=1,F[210000],V[210000],Next[210000],Head[11000];//f:最大流量（flow），w:单位费用 void addedge(int u,int v,int f)&#123; V[++edgenum]=v; F[edgenum]=f; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void Add(int u,int v,int f)&#123; addedge(u,v,f); addedge(v,u,0);&#125;bool bfs()&#123; memset(vis,false,sizeof(vis)); memset(dep,0x3f,sizeof(dep)); dep[s]=0; vis[s]=true; queue&lt;int&gt; que; que.push(s); while (!que.empty())&#123; int u=que.front(); que.pop(); vis[u]=false; for (int e=Head[u];e;e=Next[e])&#123; int d=V[e]; if (dep[d]&gt;dep[u]+1&amp;&amp;F[e])&#123; dep[d]=dep[u]+1; if (!vis[d])&#123; que.push(d); vis[d]=true; &#125; &#125; &#125; &#125; return dep[t]&lt;INF;&#125;int dfs(int u,int flow)&#123; if (u==t)&#123; vis[t]=true; maxflow+=flow; return flow; &#125; int used=0; vis[u]=true; for (int e=Head[u];e;e=Next[e])&#123; int d=V[e]; if ((!vis[d]||d==t)&amp;&amp;F[e]&amp;&amp;dep[d]==dep[u]+1)&#123; int minflow=dfs(d,min(flow-used,F[e])); if (minflow!=0) F[e]-=minflow,F[e^1]+=minflow,used+=minflow; if (used==flow) break; &#125; &#125; return used;&#125;int dinic()&#123; while (bfs())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,false,sizeof(vis)); dfs(s,INF); &#125; &#125; return maxflow;&#125;int main()&#123; n=read(),m=read(),s=read(),t=read(); int u,v,f; for (register int i=1;i&lt;=m;i++)&#123; u=read(),v=read(),f=read(); Add(u,v,f); &#125; dinic(); printf(&quot;%d\\n&quot;,maxflow); return 0;&#125; 3.3 最小费用最大流（dinic） 背过了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int INF=0x3f3f3f3f;int n,m,s,t;int ans,maxflow;int vis[5100];//是否到达过该点 int dist[5100]; int edgenum=1,F[110000],V[110000],Next[110000],W[110000],Head[5100];//f:最大流量（flow），w:单位费用 void addedge(int u,int v,int f,int w)&#123; V[++edgenum]=v; W[edgenum]=w; F[edgenum]=f; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void Add(int u,int v,int f,int w)&#123; addedge(u,v,f,w); addedge(v,u,0,-w);&#125;bool spfa()&#123; memset(vis,false,sizeof(vis)); memset(dist,0x3f,sizeof(dist)); dist[s]=0; vis[s]=true; queue&lt;int&gt; que; que.push(s); while (!que.empty())&#123; int u=que.front(); que.pop(); vis[u]=false; for (int e=Head[u];e;e=Next[e])&#123; int d=V[e]; if (dist[d]&gt;dist[u]+W[e]&amp;&amp;F[e])&#123; dist[d]=dist[u]+W[e]; if (!vis[d])&#123; que.push(d); vis[d]=true; &#125; &#125; &#125; &#125; return dist[t]&lt;INF;&#125;int dfs(int u,int flow)&#123; if (u==t)&#123; vis[t]=true; maxflow+=flow; return flow; &#125; int used=0; vis[u]=true; for (int e=Head[u];e;e=Next[e])&#123; int d=V[e]; if ((!vis[d]||d==t)&amp;&amp;F[e]&amp;&amp;dist[d]==dist[u]+W[e])&#123; int minflow=dfs(d,min(flow-used,F[e])); if (minflow!=0) ans+=W[e]*minflow,F[e]-=minflow,F[e^1]+=minflow,used+=minflow; if (used==flow) break; &#125; &#125; return used;&#125;int mincostmaxflow()&#123; while (spfa())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,false,sizeof(vis)); dfs(s,INF); &#125; &#125; return maxflow;&#125;int main()&#123; n=read(),m=read(),s=read(),t=read(); int u,v,f,w; for (register int i=1;i&lt;=m;i++)&#123; u=read(),v=read(),f=read(),w=read(); Add(u,v,f,w); &#125; mincostmaxflow(); printf(&quot;%d %d\\n&quot;,maxflow,ans); return 0;&#125; 3.4 无向图Tarjan算法&amp;欧拉回路 敲了一遍，注意!的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// tarjan算法求无向图的桥、边双连通分量并缩点#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int SIZE = 100010;int head[SIZE], ver[SIZE * 2], Next[SIZE * 2];int dfn[SIZE], low[SIZE], c[SIZE];int n, m, tot, num, dcc, tc;bool bridge[SIZE * 2];int hc[SIZE], vc[SIZE * 2], nc[SIZE * 2];void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot;&#125;void add_c(int x, int y) &#123; vc[++tc] = y, nc[tc] = hc[x], hc[x] = tc;&#125;void tarjan(int x, int in_edge) &#123; dfn[x] = low[x] = ++num; for (int i = head[x]; i; i = Next[i]) &#123; int y = ver[i]; if (!dfn[y]) &#123; tarjan(y, i); low[x] = min(low[x], low[y]); if (low[y] &gt; dfn[x]) bridge[i] = bridge[i ^ 1] = true; &#125; else if (i != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); &#125;&#125;void dfs(int x) &#123; c[x] = dcc; for (int i = head[x]; i; i = Next[i]) &#123; int y = ver[i]; if (c[y] || bridge[i]) continue; dfs(y); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; tot = 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y), add(y, x); &#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, 0); for (int i = 2; i &lt; tot; i += 2) if (bridge[i]) printf(&quot;%d %d\\n&quot;, ver[i ^ 1], ver[i]); for (int i = 1; i &lt;= n; i++) if (!c[i]) &#123; ++dcc; dfs(i); &#125; printf(&quot;There are %d e-DCCs.\\n&quot;, dcc); for (int i = 1; i &lt;= n; i++) printf(&quot;%d belongs to DCC %d.\\n&quot;, i, c[i]); tc = 1; for (int i = 2; i &lt;= tot; i++) &#123; int x = ver[i ^ 1], y = ver[i]; if (c[x] == c[y]) continue; add_c(c[x], c[y]); &#125; printf(&quot;缩点之后的森林，点数 %d，边数 %d\\n&quot;, dcc, tc / 2); for (int i = 2; i &lt; tc; i += 2) printf(&quot;%d %d\\n&quot;, vc[i ^ 1], vc[i]);&#125;// tarjan算法求无向图的割点、点双连通分量并缩点#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int SIZE = 100010;int head[SIZE], ver[SIZE * 2], Next[SIZE * 2];int dfn[SIZE], low[SIZE], stack[SIZE], new_id[SIZE], c[SIZE];int n, m, tot, num, root, top, cnt, tc;bool cut[SIZE];vector&lt;int&gt; dcc[SIZE];int hc[SIZE], vc[SIZE * 2], nc[SIZE * 2];void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot;&#125;void add_c(int x, int y) &#123; vc[++tc] = y, nc[tc] = hc[x], hc[x] = tc;&#125;void tarjan(int x) &#123; dfn[x] = low[x] = ++num; stack[++top] = x; if (x == root &amp;&amp; head[x] == 0) &#123; // 孤立点 !!!!!!!!!!!!!!!!!!!!!! dcc[++cnt].push_back(x); return; &#125; int flag = 0; for (int i = head[x]; i; i = Next[i]) &#123; int y = ver[i]; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (low[y] &gt;= dfn[x]) &#123; flag++; if (x != root || flag &gt; 1) cut[x] = true; cnt++; int z; do &#123; z = stack[top--]; dcc[cnt].push_back(z); &#125; while (z != y); dcc[cnt].push_back(x); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; tot = 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (x == y) continue; add(x, y), add(y, x); &#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) root = i, tarjan(i); for (int i = 1; i &lt;= n; i++) if (cut[i]) printf(&quot;%d &quot;, i); puts(&quot;are cut-vertexes&quot;); for (int i = 1; i &lt;= cnt; i++) &#123; printf(&quot;v-DCC #%d:&quot;, i); for (int j = 0; j &lt; dcc[i].size(); j++) printf(&quot; %d&quot;, dcc[i][j]); puts(&quot;&quot;); &#125; // 给每个割点一个新的编号(编号从cnt+1开始) num = cnt; for (int i = 1; i &lt;= n; i++) if (cut[i]) new_id[i] = ++num; // 建新图，从每个v-DCC到它包含的所有割点连边 tc = 1; for (int i = 1; i &lt;= cnt; i++) for (int j = 0; j &lt; dcc[i].size(); j++) &#123; int x = dcc[i][j]; if (cut[x]) &#123; add_c(i, new_id[x]); add_c(new_id[x], i); &#125; else c[x] = i; // 除割点外，其它点仅属于1个v-DCC &#125; printf(&quot;缩点之后的森林，点数 %d，边数 %d\\n&quot;, num, tc / 2); printf(&quot;编号 1~%d 的为原图的v-DCC，编号 &gt;%d 的为原图割点\\n&quot;, cnt, cnt); for (int i = 2; i &lt; tc; i += 2) printf(&quot;%d %d\\n&quot;, vc[i ^ 1], vc[i]);&#125;// 求出欧拉图中的一条欧拉回路#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int head[100010], ver[1000010], Next[1000010], tot; // 邻接表int stack[1000010], ans[1000010]; // 模拟系统栈，答案栈bool vis[1000010];int n, m, top, t;void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot;&#125;void euler() &#123; stack[++top] = 1; while (top &gt; 0) &#123; int x = stack[top], i = head[x]; // 找到一条尚未访问的边 while (i &amp;&amp; vis[i]) i = Next[i]; // 沿着这条边模拟递归过程，标记该边，并更新表头 if (i) &#123; stack[++top] = ver[i]; head[x] = Next[i]; vis[i] = vis[i ^ 1] = true; &#125; // 与x相连的所有边均已访问，模拟回溯过程，并记录于答案栈中 else &#123; top--; ans[++t] = x; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; tot = 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y), add(y, x); &#125; euler(); for (int i = t; i; i--) printf(&quot;%d\\n&quot;, ans[i]);&#125; 3.5 有向图Tarjan算法（强连通分量） 敲了一遍，注意!的部分 12345678910111213141516171819202122232425262728void tarjan(int u)&#123; int v; dfn[u]=low[u]=++idx;//每次dfs，u的次序号增加1 s.push(u);//将u入栈 ins[u]=1;//标记u在栈内 for(int i=head[u];i!=-1;i=e[i].next)//访问从u出发的边 &#123; v=e[i].v; if(!dfn[v])//如果v没被处理过 &#123; tarjan(v);//dfs(v) low[u]=min(low[u],low[v]);//u点能到达的最小次序号是它自己能到达点的最小次序号和连接点v能到达点的最小次序号中较小的 &#125; else if(ins[v])low[u]=min(low[u],dfn[v]);//如果v在栈内，u点能到达的最小次序号是它自己能到达点的最小次序号和v的次序号中较小的 &#125; if(dfn[u]==low[u])//!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &#123; Bcnt++; do &#123; v=s.top(); s.pop(); ins[v]=0; Belong[v]=Bcnt; &#125;while(u != v); &#125;&#125; 3.6 二分图匹配（匈牙利算法） 敲了一遍 12345678910111213141516bool dfs(int x) &#123; for (int i = head[x], y; i; i = next[i]) if (!visit[y = ver[i]]) &#123; visit[y] = 1; if (!match[y] || dfs(match[y])) &#123; match[y]=x; return true; &#125; &#125; return false;&#125;for (int i = 1; i &lt;= n; i++) &#123; memset(visit, 0, sizeof(visit)); if (dfs(i)) ans++;&#125; 4. 矩阵&amp;多项式4.1 多项式基础模板1234567891011121314151617181920212223242526272829303132333435363738394041424344struct poly&#123; vector&lt;int&gt; v; poly()&#123; v.clear();&#125; inline int size()&#123; return v.size();&#125; friend poly operator+(poly A,poly B)&#123; int lenA=A.v.size()-1,lenB=B.v.size()-1; int len=max(lenA,lenB); A.v.resize(len+1); B.v.resize(len+1); poly C; C.v.resize(len+1); for (int i=0;i&lt;=len;i++) C.v[i]=add(A.v[i],B.v[i]); return C; &#125; friend poly operator*(poly A,int v)&#123; for (int i=0;i&lt;A.size();i++) A.v[i]=mul(A.v[i],v); return A; &#125; friend poly operator*(const poly &amp;A,const poly &amp;B)&#123; int len=A.v.size()+B.v.size()-2; poly C; C.v.resize(len+1); for (int i=0;i&lt;(int)A.v.size();i++) for (int j=0;j&lt;(int)B.v.size();j++) C.v[i+j]=add(C.v[i+j],mul(A.v[i],B.v[j])); return C; &#125; friend poly operator%(poly A,const poly &amp;B)&#123; int lenA=(int)A.v.size()-1,lenB=(int)B.v.size()-1; int inv=getinv(B.v[lenB]); if (lenA&lt;lenB) return A; for (int i=lenA;i&gt;=lenB;i--) if (A.v[i])&#123; int t=mul(A.v[i],inv); for (int j=i;j&gt;=i-lenB;j--) A.v[j]=dec(A.v[j],mul(t,B.v[lenB-i+j])); &#125; A.v.resize(lenB+1); return A; &#125;&#125;;poly qpow(poly x,char *a,const poly &amp;M)&#123;//a为二进制数 poly res; res.v.clear(); res.v.push_back(1); for (int i=strlen(a)-1;i&gt;=0;i--)&#123; if (a[i]==&#x27;1&#x27;) res=(res*x)%M; x=(x*x)%M; &#125; return res;&#125; 4.2 FWT :star: 背过一遍 123456789101112131415161718192021222324252627282930// 均类似于FFT/NTT的三重循环。// Or卷积，正变换是大的+小的，逆变换是大的-小的。（两个数Or起来会变大）。// And卷积，正变换是小的+大的，逆变换是小的-大的。（两个数And起来会变小）。// Xor卷积，正变换和FFT/NTT一样，小的=(X+Y)，大的=(X-Y)。逆变换把结果都/2。void FWT_or(int *a,int op)&#123; for (int i=1;i&lt;N;i&lt;&lt;=1) for (int p=i&lt;&lt;1,j=0;j&lt;N;j+=p) for (int k=0;k&lt;i;++k) if (op==1) a[i+j+k]=(a[j+k]+a[i+j+k])%Mod; else a[i+j+k]=(a[i+j+k]+Mod-a[j+k])%Mod;&#125;void FWT_and(int *a,int op)&#123; for (int i=1;i&lt;N;i&lt;&lt;=1) for (int p=i&lt;&lt;1,j=0;j&lt;N;j+=p) for (int k=0;k&lt;i;++k) if (op==1) a[j+k]=(a[j+k]+a[i+j+k])%Mod; else a[j+k]=(a[j+k]+Mod-a[i+j+k])%Mod;&#125;void FWT_xor(int *a,int op)&#123; for (int i=1;i&lt;N;i&lt;&lt;=1) for (int p=i&lt;&lt;1,j=0;j&lt;N;j+=p) for (int k=0;k&lt;i;k++)&#123; int X=a[j+k],Y=a[i+j+k]; a[j+k]=(X+Y)%Mod; a[i+j+k]=(X+Mod-Y)%Mod; if (op==-1)&#123; a[j+k]=1ll*a[j+k]*inv2%Mod; a[i+j+k]=1ll*a[i+j+k]*inv2%Mod;//inv2为2的逆元 &#125; &#125;&#125; 4.3 FFT:star2: 敲过了 首先，重要的一点是rev[x]=(rev[x&gt;&gt;1]&gt;&gt;1)|((x&amp;1)&lt;&lt;(bit-1))。相当于把它的最后一个位置删去，然后反过来，此时所有位置都往左移了一位，那么右移一位，最后把最后一个位置的数放在最高位。 然后，将原序列x&lt;rev[x]的位置，交换x,rev[x]。（否则会交换两次，相当于没交换）。 考虑正变换 枚举mid，表示当前长度的一半。此时，$\\omega=\\cos \\frac{2\\pi}{2mid}+sin\\frac{2\\pi}{2mid}=\\cos\\frac{\\pi}{mid}+sin \\frac{\\pi}{mid}$。 然后枚举起始位置$i$，必须是 $2mid$ 的倍数。 初始时，$w=1$，然后，枚举段中的位置 $j$ ，则 $i+j$ 为左边段的真实位置，$i+j+mid$ 是右边段的真实位置。 $a[i+j]=(X+Y),a[i+j+mid]=w(X-Y)$，最后$w=\\omega$。 接着考虑逆变换，其实就是改变了$\\omega$，此时$\\omega=cos \\frac{\\pi}{mid}-i\\sin\\frac{\\pi}{mid}$。最后要把每个数都/n。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1e7+10;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;const double Pi=acos(-1.0);struct complex&#123; double x,y; complex (double xx=0,double yy=0)&#123; x=xx; y=yy;&#125;&#125; a[MAXN],b[MAXN];complex operator+(complex a,complex b)&#123; return complex(a.x+b.x,a.y+b.y);&#125;complex operator-(complex a,complex b)&#123; return complex(a.x-b.x,a.y-b.y);&#125;complex operator*(complex a,complex b)&#123; return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125; int N,M;int l,r[MAXN];int len=1;void FFT(complex *A,int type)&#123; for (int i=0;i&lt;len;i++) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; complex Wn(cos(Pi/mid),type*sin(Pi/mid)); for (int R=mid&lt;&lt;1,j=0;j&lt;len;j+=R)&#123; complex w(1,0); for (int k=0;k&lt;mid;k++,w=w*Wn)&#123; complex x=A[j+k],y=w*A[j+mid+k]; A[j+k]=x+y; A[j+mid+k]=x-y; &#125; &#125; &#125;&#125;int main()&#123; int N=read(),M=read(); for (int i=0;i&lt;=N;i++) a[i].x=read(); for (int i=0;i&lt;=M;i++) b[i].x=read(); while (len&lt;=N+M) len&lt;&lt;=1,l++; for (int i=0;i&lt;len;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); FFT(a,1); FFT(b,1); for (int i=0;i&lt;=len;i++) a[i]=a[i]*b[i]; FFT(a,-1); for (int i=0;i&lt;=N+M;i++) printf(&quot;%d &quot;,(int)(a[i].x/len+0.5)); return 0;&#125; 4.4 NTT:star2: 敲过了 正变换：改变了FFT中的$\\omega$，此时$\\omega=g^\\dfrac{\\varphi(Mod)}{mid2}=g^\\dfrac{Mod-1}{mid2}$。 逆变换：改变了FFT中的$\\omega$，此时$\\omega=\\dfrac1{g^\\dfrac{\\varphi(Mod)}{mid2}}=\\dfrac 1{g^\\dfrac{Mod-1}{mid2}}$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int g=3;const int Mod=998244353;const int MAXN=2100000;//&gt;n+m上取到2的幂次 int n,m,len,rev[MAXN];ll a[MAXN],b[MAXN],c[MAXN];inline ll qpow(ll x,int a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline int getinv(int x)&#123; return qpow(x,Mod-2);&#125;void NTT(ll *a,int inv)&#123; for (int i=0;i&lt;n;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;n;mid&lt;&lt;=1)&#123; int tmp=qpow(g,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;n;i+=mid*2)&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=omega*tmp%Mod)&#123; int x=a[i+j],y=omega*a[i+j+mid]%Mod; a[i+j]=(x+y)%Mod,a[i+j+mid]=(x-y+Mod)%Mod; &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); n++; m++; for (int i=0;i&lt;n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for (int i=0;i&lt;m;i++) scanf(&quot;%lld&quot;,&amp;b[i]); len=n+m-1; int bit=0; while ((1&lt;&lt;bit)&lt;len) bit++; n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,1); NTT(b,1); for (int i=0;i&lt;n;i++) a[i]=a[i]*b[i]%Mod; NTT(a,-1); ll inv=getinv(n); for (int i=0;i&lt;len;i++)&#123; c[i]=a[i]*inv%Mod; printf(&quot;%lld &quot;,c[i]); &#125; return 0;&#125; 4.5 多项式求逆:star: 背过一遍 就一个式子，将变换后的按位乘改为：$b[i]=(2-c[i]b[i])b[i]$。 1234567891011121314151617181920212223242526272829303132333435void polymul(vec &amp;a,vec &amp;b,vec &amp;c,int bit)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(n,a,1); NTT(n,b,1); for (int i=0;i&lt;n;i++) a[i]=a[i]*b[i]%Mod; NTT(n,a,-1); ll inv=getinv(n); c.resize(n); for (int i=0;i&lt;n;i++) c[i]=a[i]*inv%Mod; a.clear(); b.clear();&#125;void polyinv(int len,int bit,vec &amp;a,vec &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); vec c=a; c.resize(len); NTT(n,c,1); NTT(n,b,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(n,b,-1); b.resize(len); ll inv=getinv(n); for (int i=0;i&lt;len;i++) b[i]=b[i]*inv%Mod;&#125;int getbit(int x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(int n,vec &amp;a,vec &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125; 4.6 拉格朗日插值 背完了 $\\displaystyle f(x)=\\sum_{i=1}^n y_i\\prod_{i\\not= j} \\frac{x-x_j}{x_i-x_j} $ 1234567891011121314151617181920212223242526272829303132 scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);//求f(k) for (int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;x[i],&amp;y[i]);//f(x[i])=y[i] ll s1,s2,ans=0; for (int i=1;i&lt;=n;i++)&#123; s1=y[i]%Mod; s2=1ll; for (int j=1;j&lt;=n;j++) if (i!=j)&#123; s1=s1*(k-x[j])%Mod; s2=s2*(x[i]-x[j])%Mod; &#125; s1=(s1+Mod)%Mod; s2=(s2+Mod)%Mod; ans=(ans+s1*inv(s2))%Mod; &#125; printf(&quot;%lld\\n&quot;,ans); //1..nint Lagrange(int k)&#123; if (k&lt;=n) return f[k]; int res=0; for (int i=1;i&lt;=n;i++)&#123; int s=1; for (int j=0;j&lt;=n;j++)&#123; if (i==j) continue; s=1ll*s*((k-j)%Mod+Mod)%Mod; if (i&gt;j) s=1ll*s*inv[i-j]%Mod; else s=(Mod-1ll*s*inv[j-i]%Mod)%Mod; &#125; res=(res+1ll*f[i]*s%Mod)%Mod; &#125; return res;&#125; 4.7 下降幂多项式乘法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int Mod=998244353;const int G=3;int n,m,len;ll f[610000],g[610000],s[610000];ll fac[610000],invfac[610000];int rev[610000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;char readop()&#123; char ch=Getchar(); while (ch&lt;&#x27;A&#x27;||ch&gt;&#x27;Z&#x27;) ch=Getchar(); return ch;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;void NTT(ll *a,int inv)&#123; for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;n;i++) a[i]=mul(a[i],inv); &#125;&#125;void FDT(ll *f,int inv)&#123; if (inv==1) for (int i=0;i&lt;n;i++) s[i]=invfac[i]; else for (int i=0;i&lt;n;i++) if (i&amp;1) s[i]=Mod-invfac[i]; else s[i]=invfac[i]; for (int i=n;i&lt;len;i++) s[i]=0; NTT(f,1); NTT(s,1); for (int i=0;i&lt;len;i++) f[i]=mul(f[i],s[i]); NTT(f,-1); for (int i=n;i&lt;len;i++) f[i]=0;&#125;int main()&#123; n=read()+1; m=read()+1; for (int i=0;i&lt;n;i++) f[i]=read(); for (int i=0;i&lt;m;i++) g[i]=read(); n=n+m-1; int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); fac[0]=1; for (int i=1;i&lt;=len;i++) fac[i]=fac[i-1]*i%Mod; invfac[1]=1; for (int i=2;i&lt;=len;i++) invfac[i]=(Mod-Mod/i)*invfac[Mod%i]%Mod; invfac[0]=1; for (int i=1;i&lt;=len;i++) invfac[i]=invfac[i-1]*invfac[i]%Mod; FDT(f,1); FDT(g,1); for (int i=0;i&lt;n;i++) f[i]=mul(mul(f[i],g[i]),fac[i]); FDT(f,-1); for (int i=0;i&lt;n;i++) printf(&quot;%lld &quot;,f[i]); return 0;&#125; 4.8 多项式除法:star: 背过一遍 $A(x)/B(x)$ $A$的最高次项为 $x^n$，$B$ 的最高次项为 $x^m$。 把 $A,B$ 翻转，$B$ 的最高此项改为 $x^{n-m}$。 求出 $B$ 的逆，和 $A$ 乘起来，再取 $x^0…x^{n-m}$。再翻转 ，输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;//#define int long long#define ls (now&lt;&lt;1)#define rs (now&lt;&lt;1|1)using namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int Mod=998244353;const int G=3; const int invG=332748118;int n,m,a[310000],rev[310000],ans[310000];poly f,g;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp);// printf(&quot;%d &quot;,(Mod-1)/(mid&lt;&lt;1)); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(poly a,poly b,poly &amp;c,int n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;void polyinv(int len,int bit,poly &amp;a,poly &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len);&#125;int getbit(int x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(int n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125;poly c,d;poly getdiv(poly a,poly b)&#123; int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; d.resize(1); d[0]=0; return d; &#125; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); b.resize(n-m+1); c.clear(); getinv(n-m+1,b,c); d.clear(); mult(c,a,d,n+(n-m+1)); d.resize(n-m+1); reverse(d.begin(),d.end()); return d;&#125;poly ans1,tmp,ans2;void getmod(poly &amp;a,poly b,poly &amp;c)&#123; int n=a.size()-1,m=b.size()-1; if (n&lt;m) return; ans1=getdiv(a,b); mult(ans1,b,tmp,n+m); c.resize(m); for (int i=0;i&lt;m;i++) c[i]=dec(a[i],tmp[i]);&#125;int main()&#123;// freopen(&quot;P4512_4.in&quot;,&quot;r&quot;,stdin); n=read(); m=read(); f.resize(n+1); g.resize(m+1); for (int i=0;i&lt;=n;i++) f[i]=read(); for (int i=0;i&lt;=m;i++) g[i]=read(); getmod(f,g,ans2); ans1.resize(n-m); for (int i=0;i&lt;=n-m;i++) printf(&quot;%d &quot;,ans1[i]); putchar(&#x27;\\n&#x27;); for (int i=0;i&lt;m;i++) printf(&quot;%d &quot;,ans2[i]); return 0;&#125;/*5 115466465 9465465 2154654 64546 4546466 86644561545 75468*/ 4.9 多点求值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define ls (now&lt;&lt;1)#define rs (now&lt;&lt;1|1)using namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int Mod=998244353;const int G=3; const int invG=332748118;int n,m,a[310000],rev[310000],ans[310000];ll Inv[2100000],powG[2100000],powInvG[2100000];poly f;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(const int &amp;x)&#123; return qpow(x,Mod-2);&#125;void NTT(poly &amp;a,const int &amp;len,const int &amp;inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp; if (inv==1) tmp=powG[mid]; else tmp=powInvG[mid];// int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1));// if (inv==-1) tmp=getinv(tmp);// printf(&quot;%d &quot;,(Mod-1)/(mid&lt;&lt;1)); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=Inv[len]; for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;/*void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp);// printf(&quot;%d &quot;,(Mod-1)/(mid&lt;&lt;1)); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;*/void mult(poly a,poly b,poly &amp;c,const int &amp;n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;void polyinv(const int &amp;len,const int &amp;bit,poly &amp;a,poly &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len);&#125;inline int getbit(const int &amp;x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(const int &amp;n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125;poly c,d;poly getdiv(poly a,poly b)&#123; int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; d.resize(1); d[0]=0; return d; &#125; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); b.resize(n-m+1); c.clear(); getinv(n-m+1,b,c); d.clear(); mult(c,a,d,n+(n-m+1)); d.resize(n-m+1); reverse(d.begin(),d.end()); return d;&#125;poly ans1,tmp,ans2;void getmod(poly a,poly b,poly &amp;c)&#123; while (!b.empty()&amp;&amp;!b.back()) b.pop_back(); int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; c=a; return;&#125; ans1=getdiv(a,b); mult(ans1,b,tmp,n+m); c.resize(m); for (int i=0;i&lt;m;i++) c[i]=dec(a[i],tmp[i]);&#125;poly p[310000];void getpoly(const int &amp;now,const int &amp;l,const int &amp;r)&#123; if (l==r)&#123; p[now].push_back(dec(0,a[l])); p[now].push_back(1); return; &#125; int mid=(l+r)&gt;&gt;1; getpoly(ls,l,mid); getpoly(rs,mid+1,r); mult(p[ls],p[rs],p[now],r-l+2);&#125;void solve(const poly &amp;A,const int &amp;now,const int &amp;l,const int &amp;r)&#123; if (r-l&lt;=1000)&#123; for (int i=l;i&lt;=r;i++)&#123; int s=0; for (int j=A.size()-1;j&gt;=0;j--) s=add(mul(s,a[i]),A[j]); ans[i]=s; &#125; return; &#125; poly B; int mid=(l+r)&gt;&gt;1; getmod(A,p[ls],B); solve(B,ls,l,mid); getmod(A,p[rs],B); solve(B,rs,mid+1,r);&#125;int main()&#123; for (int mid=1;mid&lt;=2000000;mid&lt;&lt;=1)&#123; powG[mid]=qpow(G,(Mod-1)/(mid&lt;&lt;1)); powInvG[mid]=qpow(powG[mid],Mod-2); &#125; Inv[1]=1; for (int i=2;i&lt;=2000000;i++) Inv[i]=(Mod-Mod/i)*Inv[Mod%i]%Mod; n=read(); m=read(); f.resize(n+1); for (int i=0;i&lt;=n;i++) f[i]=read(); for (int i=1;i&lt;=m;i++) a[i]=read();// n=64000; m=64000; f.resize(n+1);// for (int i=0;i&lt;=n;i++) f[i]=1;// for (int i=1;i&lt;=m;i++) a[i]=i; getpoly(1,1,m); getmod(f,p[1],f); solve(f,1,1,m); for (int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0;&#125; 4.10 多项式ln/exp todo？？？？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef vector&lt;int&gt; poly;typedef long long ll;const int Mod=998244353;const int G=3;int n,m,a[310000],rev[310000],ans[310000];poly f,g;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(const int &amp;x)&#123; return qpow(x,Mod-2);&#125;void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(poly a,poly b,poly &amp;c,const int &amp;n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;void polyinv(const int &amp;len,const int &amp;bit,poly &amp;a,poly &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len);&#125;inline int getbit(const int &amp;x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(const int &amp;n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125;void Dao(poly &amp;A,poly &amp;B,int len)&#123; for (int i=1;i&lt;len;i++) B[i-1]=1ll*i*A[i]%Mod; B[len-1]=0;&#125;void Jifen(poly &amp;A,poly &amp;B,int len)&#123; for (int i=1;i&lt;len;i++) B[i]=1ll*A[i-1]*getinv(i)%Mod; B[0]=0;&#125;poly A,B,C;void getln(poly &amp;f,poly &amp;g,int n)&#123; f.resize(n); g.resize(n); A.resize(n); B.resize(n); Dao(f,A,n); getinv(n,f,B); mult(A,B,C,n+n); Jifen(C,g,n);&#125;poly t;void getexp(const int &amp;n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=1; return; &#125; getexp(n&gt;&gt;1,a,b); getln(b,t,n); for (int i=0;i&lt;n;i++) t[i]=dec(a[i],t[i]); t[0]=add(1,t[0]); mult(t,b,b,n+n); t.clear(); b.resize(n);&#125;int main()&#123; n=read(); f.resize(n); for (int i=0;i&lt;n;i++) f[i]=read(); for (m=1;m&lt;=n;m&lt;&lt;=1); f.resize(m); getexp(m,f,g); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,g[i]); return 0;&#125; 4.11 普通多项式转下降幂多项式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define ls (now&lt;&lt;1)#define rs (now&lt;&lt;1|1)using namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int Mod=998244353;const int G=3; const int invG=332748118;int n,m,a[510000],rev[510000],ans[510000];ll Inv[1100000];int GPow[2][19][510000];ll fac[1100000],invfac[1100000];poly f;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(const int &amp;x)&#123; return qpow(x,Mod-2);&#125;inline void InitG()&#123; for (int p=1;p&lt;=18;p++) &#123; int buf1=qpow(G,(Mod-1)/(1&lt;&lt;p)); int buf0=qpow(invG,(Mod-1)/(1&lt;&lt;p)); GPow[1][p][0]=GPow[0][p][0]=1; for (int i=1;i&lt;(1&lt;&lt;p);i++)&#123; GPow[1][p][i]=1LL*GPow[1][p][i-1]*buf1%Mod; GPow[0][p][i]=1LL*GPow[0][p][i-1]*buf0%Mod; &#125; &#125;&#125;void NTT(poly &amp;a,const int &amp;len,int inv)&#123; if (inv==-1) inv=0; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); /*for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp; if (inv==1) tmp=powG[mid]; else tmp=powInvG[mid]; for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125;*/ for (int l=2,cnt=1;l&lt;=len;l&lt;&lt;=1,cnt++)&#123; int m=l&gt;&gt;1; for (int i=0;i&lt;len;i+=l)&#123; int *buf=GPow[inv][cnt]; for (int j=0;j&lt;m;j++,buf++) &#123; int x=a[i+j],y=1LL*(*buf)*a[i+j+m]%Mod; a[i+j]=add(x,y),a[i+j+m]=dec(x,y); &#125; &#125; &#125; if (inv!=1)&#123; ll inv=Inv[len]; for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(poly a,poly b,poly &amp;c,const int &amp;n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;void polyinv(const int &amp;len,const int &amp;bit,poly &amp;a,poly &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=mul(dec(2,mul(c[i],b[i])),b[i]); NTT(b,n,-1); b.resize(len);&#125;inline int getbit(const int &amp;x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(const int &amp;n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125;poly c,d;poly getdiv(poly a,poly b)&#123; int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; d.resize(1); d[0]=0; return d; &#125; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); b.resize(n-m+1); c.clear(); getinv(n-m+1,b,c); d.clear(); mult(c,a,d,n+(n-m+1)); d.resize(n-m+1); reverse(d.begin(),d.end()); return d;&#125;poly ans1,tmp,ans2;void getmod(poly a,poly b,poly &amp;c)&#123; while (!b.empty()&amp;&amp;!b.back()) b.pop_back(); int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; c=a; return;&#125; ans1=getdiv(a,b); mult(ans1,b,tmp,n+m); c.resize(m); for (int i=0;i&lt;m;i++) c[i]=dec(a[i],tmp[i]);&#125;poly p[510000];void getpoly(const int &amp;now,const int &amp;l,const int &amp;r)&#123; if (l==r)&#123; p[now].push_back(dec(0,a[l])); p[now].push_back(1); return; &#125; int mid=(l+r)&gt;&gt;1; getpoly(ls,l,mid); getpoly(rs,mid+1,r); mult(p[ls],p[rs],p[now],r-l+2);&#125;void solve(const poly &amp;A,const int &amp;now,const int &amp;l,const int &amp;r)&#123; if (r-l&lt;=700)&#123; for (int i=l;i&lt;=r;i++)&#123; int s=0; for (int j=A.size()-1;j&gt;=0;j--) s=add(mul(s,a[i]),A[j]); ans[i]=s; &#125; return; &#125; poly B; int mid=(l+r)&gt;&gt;1; getmod(A,p[ls],B); solve(B,ls,l,mid); getmod(A,p[rs],B); solve(B,rs,mid+1,r);&#125;poly s;void FDT(poly &amp;f,int len,int inv)&#123; f.resize(len); s.resize(len); if (inv==1) for (int i=0;i&lt;n;i++) s[i]=invfac[i]; else for (int i=0;i&lt;n;i++) if (i&amp;1) s[i]=Mod-invfac[i]; else s[i]=invfac[i]; for (int i=n;i&lt;len;i++) s[i]=0; NTT(f,len,1); NTT(s,len,1); for (int i=0;i&lt;len;i++) f[i]=mul(f[i],s[i]); NTT(f,len,-1); for (int i=n;i&lt;len;i++) f[i]=0;&#125;int main()&#123; Inv[1]=1; for (int i=2;i&lt;=1000000;i++) Inv[i]=(Mod-Mod/i)*Inv[Mod%i]%Mod; InitG(); n=read(); f.resize(n);// n=100000; f.resize(n); // for (int i=0;i&lt;n;i++) f[i]=i; for (int i=0;i&lt;n;i++) f[i]=read(); m=n; for (int i=1;i&lt;=m;i++) a[i]=i-1; getpoly(1,1,m); getmod(f,p[1],f); solve(f,1,1,m); int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); fac[0]=1; for (int i=1;i&lt;=len;i++) fac[i]=fac[i-1]*i%Mod; invfac[1]=1; for (int i=2;i&lt;=len;i++) invfac[i]=(Mod-Mod/i)*invfac[Mod%i]%Mod; invfac[0]=1; for (int i=1;i&lt;=len;i++) invfac[i]=invfac[i-1]*invfac[i]%Mod; f.resize(n); for (int i=0;i&lt;n;i++) f[i]=mul(ans[i+1],invfac[i]); FDT(f,len,-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,f[i]); return 0;&#125; 4.12 下降幂多项式转普通多项式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int G=3,invG=332748118;const int Mod=998244353;typedef long long ll;typedef vector&lt;int&gt; poly;struct node&#123; poly g,f;&#125;;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;int n,GPow[2][20][1100000];int rev[1100000]; ll fac[1100000],inv[1100000],invfac[1100000];poly f,tmp,ans;inline void InitG()&#123; fac[0]=1; for (int i=1;i&lt;=1000000;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=1000000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; invfac[0]=1; for (int i=1;i&lt;=1000000;i++) invfac[i]=invfac[i-1]*inv[i]%Mod; for (int p=1;p&lt;=19;p++) &#123; int buf1=qpow(G,(Mod-1)/(1&lt;&lt;p)); int buf0=qpow(invG,(Mod-1)/(1&lt;&lt;p)); GPow[1][p][0]=GPow[0][p][0]=1; for (int i=1;i&lt;(1&lt;&lt;p);i++)&#123; GPow[1][p][i]=1LL*GPow[1][p][i-1]*buf1%Mod; GPow[0][p][i]=1LL*GPow[0][p][i-1]*buf0%Mod; &#125; &#125;&#125;void NTT(poly &amp;a,const int &amp;len,int inv)&#123; if (inv==-1) inv=0; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int l=2,cnt=1;l&lt;=len;l&lt;&lt;=1,cnt++)&#123; int m=l&gt;&gt;1; for (int i=0;i&lt;len;i+=l)&#123; int *buf=GPow[inv][cnt]; for (int j=0;j&lt;m;j++,buf++)&#123; int x=a[i+j],y=1LL*(*buf)*a[i+j+m]%Mod; a[i+j]=add(x,y),a[i+j+m]=dec(x,y); &#125; &#125; &#125; if (inv!=1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;poly A,B;void mult(int n,int m,const poly &amp;a,const poly &amp;b,poly &amp;c)&#123; n++; m++; int len=1,bit=0; while (len&lt;(n+m)) len&lt;&lt;=1,bit++; A.resize(n); B.resize(m); for (int i=0;i&lt;n;i++) A[i]=a[i]; for (int i=0;i&lt;m;i++) B[i]=b[i]; c.resize(len); for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(A,len,1); NTT(B,len,1); for (int i=0;i&lt;len;i++) c[i]=1ll*A[i]*B[i]%Mod; NTT(c,len,-1);&#125;poly s;void ADD(poly &amp;a,const poly &amp;b)&#123; if (b.size()&gt;a.size()) a.resize(b.size()); for (int i=0;i&lt;(int)b.size();i++) a[i]=add(a[i],b[i]); &#125;void FDT(poly &amp;f,int len,int inv)&#123; f.resize(len); s.resize(len); if (inv==1) for (int i=0;i&lt;n;i++) s[i]=invfac[i]; else for (int i=0;i&lt;n;i++) if (i&amp;1) s[i]=Mod-invfac[i]; else s[i]=invfac[i]; for (int i=n;i&lt;len;i++) s[i]=0; NTT(f,len,1); NTT(s,len,1); for (int i=0;i&lt;len;i++) f[i]=mul(f[i],s[i]); NTT(f,len,-1); f.resize(n);&#125;node interpolation(int l,int r,const poly &amp;A,const poly &amp;B)&#123; if (l==r)&#123; node tmp; tmp.g.clear(); tmp.f.clear(); tmp.g.push_back(dec(0,l)); tmp.g.push_back(1); tmp.f.push_back(mul(A[l],B[l])); return tmp; &#125; int mid=(l+r)&gt;&gt;1; node a=interpolation(l,mid,A,B); node b=interpolation(mid+1,r,A,B); poly c; mult(mid-l+1,r-mid,a.g,b.g,c); poly d; mult(mid-l+1,r-mid-1,a.g,b.f,d); poly e; mult(mid-l,r-mid,a.f,b.g,e); ADD(d,e); return (node)&#123;c,d&#125;;&#125;int main()&#123; InitG(); n=read(); f.resize(n); tmp.resize(n); for (int i=0;i&lt;n;i++) f[i]=read(); int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1));f.resize(n); tmp.resize(n); FDT(f,len,1); for (int i=0;i&lt;n;i++) f[i]=mul(f[i],fac[i]); for (int i=0;i&lt;n;i++) tmp[i]=mul(invfac[i],((n-i)&amp;1)?invfac[n-i-1]:Mod-invfac[n-i-1]); ans=interpolation(0,n-1,f,tmp).f; ans.resize(n); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,ans[i]); return 0;&#125; 4.13 常系数齐次线性递推123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int G=3,invG=332748118;const int Mod=998244353;typedef long long ll;typedef vector&lt;int&gt; poly;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;int GPow[2][19][410000];int rev[410000],f[410000],g[410000];poly A,B,c,a,b;inline void InitG()&#123; for (int p=1;p&lt;=18;p++) &#123; int buf1=qpow(G,(Mod-1)/(1&lt;&lt;p)); int buf0=qpow(invG,(Mod-1)/(1&lt;&lt;p)); GPow[1][p][0]=GPow[0][p][0]=1; for (int i=1;i&lt;(1&lt;&lt;p);i++)&#123; GPow[1][p][i]=1LL*GPow[1][p][i-1]*buf1%Mod; GPow[0][p][i]=1LL*GPow[0][p][i-1]*buf0%Mod; &#125; &#125;&#125;void NTT(poly &amp;a,const int &amp;len,int inv)&#123; if (inv==-1) inv=0; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int l=2,cnt=1;l&lt;=len;l&lt;&lt;=1,cnt++)&#123; int m=l&gt;&gt;1; for (int i=0;i&lt;len;i+=l)&#123; int *buf=GPow[inv][cnt]; for (int j=0;j&lt;m;j++,buf++) &#123; int x=a[i+j],y=1LL*(*buf)*a[i+j+m]%Mod; a[i+j]=add(x,y),a[i+j+m]=dec(x,y); &#125; &#125; &#125; if (inv!=1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(int n,int m,const poly &amp;a,const poly &amp;b,poly &amp;c)&#123; int len=1,bit=0; while (len&lt;(n+m)) len&lt;&lt;=1,bit++; A.resize(n); B.resize(m); for (int i=0;i&lt;n;i++) A[i]=a[i]; for (int i=0;i&lt;m;i++) B[i]=b[i]; c.resize(len); for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(A,len,1); NTT(B,len,1); for (int i=0;i&lt;len;i++) c[i]=1ll*A[i]*B[i]%Mod; NTT(c,len,-1);&#125;void PolyInv(int n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; PolyInv((n+1)&gt;&gt;1,a,b); int len=1,bit=0; while (len&lt;(n&lt;&lt;1)) len&lt;&lt;=1,bit++; c.resize(n); for (int i=0;i&lt;n;i++) c[i]=a[i]; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(c,len,1); NTT(b,len,1); for (int i=0;i&lt;len;i++) b[i]=1ll*(2-1ll*c[i]*b[i]%Mod+Mod)%Mod*b[i]%Mod; NTT(b,len,-1); b.resize(n);&#125;poly fr,gr,tmp,q,R,Q;void PolyMod(int n,int m,poly &amp;f,poly &amp;g,poly &amp;r)&#123; fr.clear(); tmp.clear(); q.clear(); R.clear(); f.resize(n+1); fr.resize(n+1); for (int i=0;i&lt;=n;i++) fr[n-i]=f[i]; mult(n-m+1,n,gr,fr,q); q.resize(n-m+1); reverse(q.begin(),q.end()); mult(m+1,n-m+1,g,q,R); for (int i=0;i&lt;m;i++) r[i]=(f[i]-R[i]+Mod)%Mod; r.resize(m);&#125;int n,k; poly res,x;int val[410000];int main()&#123; InitG(); n=read(); k=read(); a.resize(k+1); res.resize(k+1); x.resize(k+1); for (int i=1;i&lt;=k;i++) a[k-i]=(Mod-read()%Mod)%Mod; for (int i=0;i&lt;=k-1;i++) val[i]=(read()%Mod+Mod)%Mod; a[k]=res[0]=1; x[1]=1; gr.resize(k+1); for (int i=0;i&lt;=k;i++) gr[k-i]=a[i]; PolyInv(k+1,gr,tmp); for (int i=0;i&lt;=k;i++) gr[i]=tmp[i]; while (n)&#123; if (n&amp;1)&#123; mult(k,k,res,x,res); PolyMod(2*k+1,k,res,a,res); &#125; mult(k,k,x,x,x); PolyMod(2*k+1,k,x,a,x); n&gt;&gt;=1; &#125; int ans=0; res.resize(k); for (int i=0;i&lt;k;i++) ans=(ans+1ll*res[i]*val[i])%Mod; printf(&quot;%d\\n&quot;,ans); return 0;&#125; 5.字符串5.1 后缀自动机（SAM） 敲了一遍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int S=1;int z,n,cnt,sz[2100000],a[2100000],c[2100000],len[2100000];int link[2100000],trans[2100000][27];long long ans;char s[1100000];inline void add(int loc)&#123; int c=s[loc]-&#x27;a&#x27;,v=z; z=++cnt; len[z]=loc; for (;v&amp;&amp;!trans[v][c];v=link[v]) trans[v][c]=z; if (!v) link[z]=S; else&#123; int x=trans[v][c]; if (len[v]+1==len[x]) link[z]=x; else &#123; int y=++cnt; len[y]=len[v]+1; for (int i=0;i&lt;=26;i++) trans[y][i]=trans[x][i]; link[y]=link[x]; link[x]=y; link[z]=y; for (;trans[v][c]==x;v=link[v]) trans[v][c]=y; &#125; &#125; sz[z]=1;&#125;void calc()&#123; for (int i=1;i&lt;=cnt;i++) c[len[i]]++; for (int i=1;i&lt;=cnt;i++) c[i]+=c[i-1]; for (int i=1;i&lt;=cnt;i++) a[c[len[i]]--]=i; for (int i=cnt;i;i--)&#123; int u=a[i]; sz[link[u]]+=sz[u]; ans+=1ll*(len[u]-len[link[u]])*sz[u]*(n-sz[u]); &#125;&#125;int main()&#123; scanf(&quot;%s&quot;,s+1); n=strlen(s+1); z=1; cnt=1; for (int i=1;i&lt;=n;i++) add(i); calc(); printf(&quot;%lld\\n&quot;,ans); return 0;&#125; 5.2 回文自动机（PAM） 敲过一遍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int MAXN=310000;const int Mod=1e9+7;const int inv2=5e8+4;char s[MAXN];class Palindromic_tree&#123; /* 两棵树，记录长度为奇数和偶数的回文串 0为长度为偶数的根,1为长度为奇数的根 *1. 偶数根节点字符长度为0，不存在，将它看做一个不在字符集中的字符-1 *2. 奇数根节点字符长度为-1，作用相当于backspace，方便处理单字符形成的回文串 *3. 只更改了最长的满足条件回文串的个数， 最后要从1-&gt;tot，把fail,fail[fail],...都也加上，这样显然会T 所以要倒过来，从tot-&gt;1，cnt[fail]+=cnt[now]; */ private: int now,tot,s[MAXN]; int fail[MAXN],cnt[MAXN],len[MAXN],ch[MAXN][26]; inline int newnode(int x)&#123; //新建一个节点，长度为x len[++tot]=x; return tot; &#125; inline int getfail(int x,int r)&#123; //从l节点开始找s[r]的fail while (s[r-len[x]-1]!=s[r]) x=fail[x]; //一直跳直到找到后缀回文 return x; &#125; public: void build(const char *t,int n)&#123; for (int i=1;i&lt;=n;i++) s[i]=t[i]-&#x27;a&#x27;; s[0]=-1; fail[0]=1; len[0]=0; //*1. len[1]=-1; //*2. now=0; tot=1; //当前在0号节点，用了&lt;=1的位置 int x,y; for (int i=1;i&lt;=n;i++)&#123; x=getfail(now,i); //找到回文的位置 if (!ch[x][s[i]])&#123; //没转移过 y=newnode(len[x]+2); //前后都加上这个字符，长度加2 fail[y]=ch[getfail(fail[x],i)][s[i]]; //记录新的fail ch[x][s[i]]=y; &#125; now=ch[x][s[i]]; cnt[now]++; //记录出现次数（只记录了最长的满足条件的）*3. &#125; &#125; ll getans()&#123; ll res=0; for (int i=tot;i&gt;=1;i--)&#123; cnt[fail[i]]+=cnt[i]; res=(res+1ll*cnt[i]*(cnt[i]-1)%Mod*inv2)%Mod; &#125; return res; &#125;&#125; tree;int main()&#123; scanf(&quot;%s&quot;,s+1); tree.build(s,strlen(s+1)); printf(&quot;%lld\\n&quot;,tree.getans()); return 0;&#125; 5.3 后缀数组（SA） 背过一遍 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char s[1100000];int y[1100000],x[1100000],c[1100000],sa[1100000],rk[1100000],height[1100000],wt[30];int n,m;void get_SA()&#123; for (int i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; //c数组是桶 //x[i]是第i个元素的第一关键字 for (int i=2;i&lt;=m;++i) c[i]+=c[i-1]; //做c的前缀和，我们就可以得出每个关键字最多是在第几名 for (int i=n;i&gt;=1;--i) sa[c[x[i]]--]=i; for (int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for (int i=n-k+1;i&lt;=n;++i) y[++num]=i; //y[i]表示第二关键字排名为i的数，第一关键字的位置 //第n-k+1到第n位是没有第二关键字的 所以排名在最前面 for (int i=1;i&lt;=n;++i) if (sa[i]&gt;k) y[++num]=sa[i]-k; //排名为i的数 在数组中是否在第k位以后 //如果满足(sa[i]&gt;k) 那么它可以作为别人的第二关键字，就把它的第一关键字的位置添加进y就行了 //所以i枚举的是第二关键字的排名，第二关键字靠前的先入队 for (int i=1;i&lt;=m;++i) c[i]=0; //初始化c桶 for (int i=1;i&lt;=n;++i) ++c[x[i]]; //因为上一次循环已经算出了这次的第一关键字 所以直接加就行了 for (int i=2;i&lt;=m;++i) c[i]+=c[i-1];//第一关键字排名为1~i的数有多少个 for (int i=n;i&gt;=1;--i) sa[c[x[y[i]]]--]=y[i],y[i]=0; //因为y的顺序是按照第二关键字的顺序来排的 //第二关键字靠后的，在同一个第一关键字桶中排名越靠后 //基数排序 swap(x,y); //这里不用想太多，因为要生成新的x时要用到旧的，就把旧的复制下来，没别的意思 x[sa[1]]=1;num=1; for (int i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]] &amp;&amp; y[sa[i]+k]==y[sa[i-1]+k]) ? num : ++num; //因为sa[i]已经排好序了，所以可以按排名枚举，生成下一次的第一关键字 if (num==n) break; m=num; //这里就不用那个122了，因为都有新的编号了 &#125; for (int i=1;i&lt;=n;++i) printf(&quot;%d &quot;,sa[i]);&#125;void get_height()&#123; int k=0; for (int i=1;i&lt;=n;++i) rk[sa[i]]=i; for (int i=1;i&lt;=n;++i)&#123; if (rk[i]==1) continue;//第一名height为0 if (k) --k;//h[i]&gt;=h[i-1]-1; int j=sa[rk[i]-1]; while (j+k&lt;=n &amp;&amp; i+k&lt;=n &amp;&amp; s[i+k]==s[j+k]) ++k; height[rk[i]]=k;//h[i]=height[rk[i]]; &#125; putchar(10); for (int i=1;i&lt;=n;++i) printf(&quot;%d &quot;,height[i]);&#125;int main()&#123; gets(s+1); n=strlen(s+1); m=122; //因为这个题不读入n和m所以要自己设 //n表示原字符串长度，m表示字符个数，ascll(&#x27;z&#x27;)=122 //我们第一次读入字符直接不用转化，按原来的ascll码来就可以了 //因为转化数字和大小写字母还得分类讨论，怪麻烦的 get_SA(); //get_height(); return 0;&#125; 5.4 Manacher1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int p[21000000];char s[11000000];char t[21000000];//存添加字符后的字符串 int init()&#123;//形成新的字符串 int len=strlen(s);//len是输入字符串的长度 t[0]=&#x27;$&#x27;;//处理边界，防止越界 t[1]=&#x27;#&#x27;; int j=2; for (int i=0;i&lt;len;i++)&#123; t[j++]=s[i]; t[j++]=&#x27;#&#x27;; &#125; t[j]=&#x27;\\0&#x27;;//处理边界，防止越界（容易忘记） return j;// 返回t的长度 &#125;int Manacher()&#123;//返回最长回文串 int len=init();//取得新字符串的长度， 完成向t的转换 int max_len=-1;//最长回文长度 int id; int mx=0; for (int i=1;i&lt;=len;i++)&#123; if (i&lt;mx) p[i]=min(p[2*id-i],mx-i);//上面图片就是这里的讲解 else p[i]=1; while (t[i-p[i]]==t[i+p[i]])//不需边界判断，因为左有&#x27;$&#x27;，右有&#x27;\\0&#x27;标记； p[i]++;//mx对此回文中点的贡献已经结束，现在是正常寻找扩大半径 if (mx&lt;i+p[i])&#123;//每走移动一个回文中点，都要和mx比较，使mx是最大，提高p[i]=min(p[2*id-i],mx-i)效率 id=i;//更新id mx=i+p[i];//更新mx &#125; max_len=max(max_len,p[i]-1); &#125; return max_len; &#125;int main()&#123; scanf(&quot;%s&quot;,s); printf(&quot;%d&quot;,Manacher()); return 0;&#125; 5.5 0/1可持久化trie123456789101112131415void change(int &amp;x,int dep,int v)&#123; tree[++cnt]=tree[x]; x=cnt; tree[x].sz++; if (dep==-1) return; bool k=v&amp;(1&lt;&lt;dep); if (k) change(tree[x].ch[1],dep-1,v); else change(tree[x].ch[0],dep-1,v);&#125;void build()&#123; cnt=0; for (int i=1;i&lt;=n;i++)&#123; rt[i]=rt[i-1]; change(rt[i],30,a[i]); &#125;&#125; 5.6 离线可删线性基123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;unordered_map&gt;using namespace std;int n,m,Q,ans,sz,op[2100000],x[2100000],lst[2100000],nxt[2100000];bool vis[35];struct node&#123; int x,y; bool operator&gt;(const node &amp;a) const&#123; return nxt[y]&gt;nxt[a.y]; &#125;&#125; c[35];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;unordered_map&lt;int,int&gt; num;void ins(node x)&#123; for (int i=n;i&gt;=0;i--) if (x.x&amp;(1&lt;&lt;i))&#123; if (!vis[i])&#123; vis[i]=true; sz++; c[i]=x; break; &#125; else&#123; if (x&gt;c[i]) swap(c[i],x); x.x^=c[i].x; &#125; &#125;&#125;void del(int x)&#123; for (int i=n;i&gt;=0;i--) if (vis[i]&amp;&amp;c[i].y==x)&#123; vis[i]=false; sz--; break; &#125; &#125;int main()&#123; n=read(); Q=read(); m=(1&lt;&lt;n); for (int i=1;i&lt;=Q;i++)&#123; op[i]=read(); x[i]=read(); nxt[num[x[i]]]=i; lst[i]=num[x[i]]; num[x[i]]=i; &#125; for (int i=1;i&lt;=Q;i++) if (!nxt[i]) nxt[i]=Q+1; for (int i=1;i&lt;=Q;i++)&#123; if (op[i]==1) ins((node)&#123;x[i],i&#125;); else del(lst[i]); ans^=(m/(1&lt;&lt;sz)); &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; 5.7 AC自动机 todo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int T,n,q,a[510000],pos[510000],len[510000],l[510000];int tot,sum[510000],fail[510000],ch[510000][27];int head,tail,que[510000];char st[510000],s[510000],pre[510000],suf[510000];int ins()&#123; int now=0,len; len=strlen(suf); for (int i=0;i&lt;len;i++)&#123; if (!ch[now][suf[i]-&#x27;a&#x27;]) ch[now][suf[i]-&#x27;a&#x27;]=++tot; now=ch[now][suf[i]-&#x27;a&#x27;]; &#125; if (!ch[now][26]) ch[now][26]=++tot; now=ch[now][26]; len=strlen(pre); for (int i=0;i&lt;len;i++)&#123; if (!ch[now][pre[i]-&#x27;a&#x27;]) ch[now][pre[i]-&#x27;a&#x27;]=++tot; now=ch[now][pre[i]-&#x27;a&#x27;]; &#125; l[now]=strlen(suf)+strlen(pre); return now;&#125;void build()&#123; int head=1,tail=0; for (int i=0;i&lt;=26;i++) if (ch[0][i]) que[++tail]=ch[0][i]; while (head&lt;=tail)&#123; int now=que[head++]; for(int i=0;i&lt;=26;i++)&#123; if (ch[now][i])&#123; fail[ch[now][i]]=ch[fail[now]][i]; que[++tail]=ch[now][i]; &#125; else ch[now][i]=ch[fail[now]][i]; &#125; &#125;&#125;void query(int x,int len)&#123; int now=0; for (int i=x+1;i&lt;=x+len;i++) now=ch[now][st[i]-&#x27;a&#x27;]; now=ch[now][26]; for (int i=x+1;i&lt;=x+len;i++)&#123; now=ch[now][st[i]-&#x27;a&#x27;]; int tmp=now; while (l[tmp]&gt;len) tmp=fail[tmp]; sum[tmp]++; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; memset(fail,0,sizeof(fail)); memset(sum,0,sizeof(sum)); memset(ch,0,sizeof(ch)); scanf(&quot;%d%d&quot;,&amp;n,&amp;q); int cnt=0; tot=0; for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%s&quot;,s+1); len[i]=strlen(s+1); a[i]=cnt; for (int j=1;j&lt;=len[i];j++) st[++cnt]=s[j]; &#125; for (int i=1;i&lt;=q;i++)&#123; scanf(&quot;%s%s&quot;,pre,suf); pos[i]=ins(); &#125; build(); for (int i=1;i&lt;=n;i++) query(a[i],len[i]); for (int i=tot;i&gt;=1;i--) sum[fail[que[i]]]+=sum[que[i]]; for (int i=1;i&lt;=q;i++) printf(&quot;%d\\n&quot;,sum[pos[i]]); &#125; return 0;&#125; 6.分治6.1 整体二分 todo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int MAXN=1100000;typedef long long ll;int n,m,x,k,t[MAXN],ans[MAXN];ll tree[MAXN];vector&lt;int&gt; vec[MAXN];struct node&#123; int l,r,num; bool isq; ll k;&#125; a[MAXN],Left[MAXN],Right[MAXN];inline void add(int x,ll y)&#123; for (;x&lt;=m;x+=x&amp;-x) tree[x]+=y;&#125;inline ll getsum(int x)&#123; ll sum=0; for (;x;x-=x&amp;-x) sum+=tree[x]; return sum;&#125;void solve(int L,int R,int l,int r)&#123; if (l&gt;r) return; if (L==R)&#123; for (int i=l;i&lt;=r;i++) if (a[i].isq) ans[a[i].num]=L; return; &#125; int mid=(L+R)&gt;&gt;1,n=0,m=0; for (int i=l;i&lt;=r;i++)&#123; if (a[i].isq)&#123; ll tmp=0; for (int j=0;j&lt;vec[a[i].num].size();j++)&#123; tmp+=getsum(vec[a[i].num][j]); if (tmp&gt;=a[i].k) break; &#125; if (tmp&gt;=a[i].k) Left[++n]=a[i]; else a[i].k-=tmp,Right[++m]=a[i]; &#125; else&#123; if (a[i].num&lt;=mid)&#123; if (a[i].l&lt;=a[i].r)&#123; add(a[i].l,a[i].k); add(a[i].r+1,-a[i].k); &#125; else&#123; add(1,a[i].k); add(a[i].r+1,-a[i].k); add(a[i].l,a[i].k); &#125; Left[++n]=a[i]; &#125; else Right[++m]=a[i]; &#125; &#125; for (int i=l;i&lt;=r;i++) if (a[i].num&lt;=mid&amp;&amp;!a[i].isq)&#123; if (a[i].l&lt;=a[i].r)&#123; add(a[i].l,-a[i].k); add(a[i].r+1,a[i].k); &#125; else&#123; add(1,-a[i].k); add(a[i].r+1,a[i].k); add(a[i].l,-a[i].k); &#125; &#125; for (int i=1;i&lt;=n;i++) a[l+i-1]=Left[i]; for (int i=1;i&lt;=m;i++) a[l+n+i-1]=Right[i]; solve(L,mid,l,l+n-1); solve(mid+1,R,l+n,r);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d&quot;,&amp;x); vec[x].push_back(i); &#125; for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;t[i]); scanf(&quot;%d&quot;,&amp;k); for (int i=1;i&lt;=k;i++)&#123; scanf(&quot;%d%d%lld&quot;,&amp;a[i].l,&amp;a[i].r,&amp;a[i].k); a[i].isq=false; a[i].num=i; &#125; for (int i=1;i&lt;=n;i++)&#123; a[i+k].k=t[i]; a[i+k].isq=true; a[i+k].num=i; &#125; solve(1,k+1,1,k+n); for (int i=1;i&lt;=n;i++) if (ans[i]!=k+1) printf(&quot;%d\\n&quot;,ans[i]); else puts(&quot;NIE&quot;); return 0;&#125; 6.2 CDQ分治（三维偏序） todo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int MAXM=210000;struct node&#123; int s,c,m,num,tot;&#125; t[MAXN],a[MAXN];int n,k,cnt,tree[MAXM],tot[MAXN],num[MAXN],ans[MAXN];inline void add(int x,int y)&#123; for (;x&lt;=k;x+=x&amp;(-x)) tree[x]+=y;&#125;inline int getsum(int x)&#123; int sum=0; for (;x;x-=x&amp;(-x)) sum+=tree[x]; return sum;&#125;inline int cmp1(node a,node b)&#123; return (a.s&lt;b.s)||(a.s==b.s&amp;&amp;a.c&lt;b.c)||(a.s==b.s&amp;&amp;a.c==b.c&amp;&amp;a.m&lt;b.m);&#125;inline int cmp2(node a,node b)&#123; return (a.c&lt;b.c)||(a.c==b.c&amp;&amp;a.m&lt;b.m);&#125;void CDQ(int l,int r)&#123; if (l==r)&#123; tot[a[l].num]+=a[l].tot-1; return; &#125; int mid=(l+r)&gt;&gt;1; CDQ(l,mid); CDQ(mid+1,r); sort(a+l,a+mid+1,cmp2); sort(a+mid+1,a+r+1,cmp2); int i,j; for (i=l,j=mid+1;j&lt;=r;j++)&#123; for (;i&lt;=mid&amp;&amp;a[i].c&lt;=a[j].c;i++) add(a[i].m,a[i].tot); tot[a[j].num]+=getsum(a[j].m); &#125; while ((--i)&gt;=l) add(a[i].m,-a[i].tot);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;t[i].s,&amp;t[i].c,&amp;t[i].m); sort(t+1,t+n+1,cmp1); for (int i=1;i&lt;=n;i++) if (i==1||t[i-1].s!=t[i].s||t[i-1].m!=t[i].m||t[i-1].c!=t[i].c)&#123; a[++cnt]=t[i]; a[cnt].tot=1; a[cnt].num=cnt; &#125; else a[cnt].tot++; for (int i=1;i&lt;=cnt;i++) num[i]=a[i].tot; CDQ(1,cnt); for (int i=1;i&lt;=cnt;i++) ans[tot[i]]+=num[i]; for (int i=0;i&lt;n;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0;&#125; 7. 计算几何7.1 基础模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct Point&#123; double x,y; Point(double x=0,double y=0):x(x),y(y)&#123;&#125;&#125;;typedef Point Vector;Vector operator+(Vector A,Vector B)&#123; return Vector(A.x+B.x,A.y+B.y);&#125;Vector operator-(Point A,Point B)&#123; return Vector(A.x-B.x,A.y-B.y);&#125;Vector operator*(Vector A,double p)&#123; return Vector(A.x*p,A.y*p);&#125;Vector operator/(Vector A,double p)&#123; return Vector(A.x/p,A.y/p);&#125;const double eps=1e-6;int sgn(double x)&#123; if (fabs(x)&lt;eps) return 0; if (x&lt;0) return -1; return 1;&#125;bool operator==(const Point&amp; a,const Point&amp; b)&#123; if (sgn(a.x-b.x)==0&amp;&amp;sgn(a.y-b.y)==0) return true; return false;&#125;double Dot(Vector A,Vector B)&#123; return A.x*B.x+A.y*B.y;&#125;double Length(Vector A)&#123; return sqrt(Dot(A, A));&#125;double Angle(Vector A,Vector B)&#123; return acos(Dot(A,B)/Length(A)/Length(B));&#125;double Cross(Vector A,Vector B)&#123; return A.x*B.y-A.y*B.x;&#125;double Area(Point A,Point B,Point C)&#123;//计算两向量构成的三角形形有向面积 return Cross(B-A,C-A)/2;&#125;double Area2(Point A,Point B,Point C)&#123;//计算两向量构成的平行四边形有向面积 return Cross(B-A,C-A);&#125;Vector Rotate(Vector A,double rad)&#123;//rad为弧度 且为逆时针旋转的角 return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;Vector Normal(Vector A)&#123;//向量A左转90°的单位法向量 double L=Length(A); return Vector(-A.y/L,A.x/L);&#125;bool ToLeftTest(Point a,Point b,Point c)&#123; return Cross(b-a,c-b)&gt;0;&#125;double DistanceToLine(Point P,Point A,Point B)&#123;//点P到直线AB距离公式 Vector v1=B-A,v2=P-A; return fabs(Cross(v1,v2)/Length(v1));//不去绝对值，得到的是有向距离&#125;double DistanceToSegment(Point P,Point A,Point B)&#123;//点P到线段AB距离公式 if (A==B) return Length(P-A); Vector v1=B-A,v2=P-A,v3=P-B; if (dcmp(Dot(v1,v2))&lt;0) return Length(v2); if (dcmp(Dot(v1,v3))&gt;0) return Length(v3); return DistanceToLine(P,A,B);&#125; 8.矩阵12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364## 4.6 矩阵基础模板​```cppstruct matrix&#123; int v[55][55]; matrix()&#123; memset(v,0,sizeof(v));&#125; int det()&#123; int res=1; for (int i=1;i&lt;=K;i++)&#123; if (!v[i][i])&#123; for (int j=i+1;j&lt;=K;j++) if (v[j][i])&#123; swap(v[i],v[j]); break;&#125; res=dec(0,res); if (!v[i][i]) return 0; &#125; ll inv=getinv(v[i][i]); for (int j=i+1;j&lt;=K;j++)&#123; int tmp=mul(v[j][i],inv); for (int k=i;k&lt;=K;k++) v[j][k]=dec(v[j][k],mul(tmp,v[i][k])); &#125; &#125; for (int i=1;i&lt;=K;i++) res=mul(res,v[i][i]); return res; &#125; friend matrix operator+(const matrix &amp;a,const matrix &amp;b)&#123; matrix res; for (int i=1;i&lt;=K;i++) for (int j=1;j&lt;=K;j++) res.v[i][j]=add(a.v[i][j],b.v[i][j]); return res; &#125; friend matrix operator-(const matrix &amp;a,const matrix &amp;b)&#123; matrix res; for (int i=1;i&lt;=K;i++) for (int j=1;j&lt;=K;j++) res.v[i][j]=dec(a.v[i][j],b.v[i][j]); return res; &#125; friend matrix operator*(const matrix &amp;a,const int b)&#123; matrix res; for (int i=1;i&lt;=K;i++) for (int j=1;j&lt;=K;j++) res.v[i][j]=mul(a.v[i][j],b); return res; &#125; friend matrix operator*(const matrix &amp;a,const matrix &amp;b)&#123; matrix res; for (int i=1;i&lt;=K;i++) for (int k=1;k&lt;=K;k++) if (a.v[i][k]) for (int j=1;j&lt;=K;j++) res.v[i][j]=add(res.v[i][j],mul(a.v[i][k],b.v[k][j])); return res; &#125; friend matrix operator^(matrix x,int a)&#123; matrix res; for (int i=1;i&lt;=K;i++) res.v[i][i]=1; while (a)&#123; if (a&amp;1) res=res*x; x=x*x; a&gt;&gt;=1; &#125; return res; &#125;&#125;; ToDo List：多项式多点插值"},{"title":"","date":"2020-11-13T02:52:32.344Z","updated":"2020-11-13T02:52:32.344Z","comments":true,"path":"record/index.html","permalink":"http://hydd.cf/record/index.html","excerpt":"","text":"开个档记录做题时出现的错误/细节。 2020.10.21道路（road） 当只有一个孤立点的时候，自己到自己是没有长度 $&gt;0$ 的路径的。 2020.10.23勇敢的阿乐（ale） 要求的是每个点往上第一个点权比它小的（而不是点权最小的）。 所以不能用 $set$，只能维护单调栈。 2020.10.27维修道路（repair） 若选择的一条路径是直径，那么另一条选择的路径的两端可能不与直径相邻。 626C - Block Towers 二分判断条件为 $n\\leq \\lfloor \\frac {mid}2\\rfloor,m\\leq \\lfloor \\frac {mid}3\\rfloor,n+m\\leq \\lfloor \\frac {mid}2\\rfloor+\\lfloor \\frac {mid}3\\rfloor-\\lfloor \\frac {mid}6\\rfloor$。 不能将其改为 $2n\\leq mid,3m\\leq mid,6(n+m)\\leq 4mid$ 2020.10.29627C - Package Delivery 做的时候要保证任意时刻剩下的油量都 $\\geq 0$。 不能到最后再判剩下的油量是否 $\\geq 0$。 545E - Paths and Trees $long\\ long$ 的 $INF$ 不能开成 $0x3f3f3f3f$！ 神奇的流浪者（rover） 组合数的下标可以达到 $n+m$，所以预处理组合数要开两倍。 神奇的图（graph） 用 $vector$ 没有加 #include&lt;vector&gt; $CE$ 了，本地 $dev-c++,-std=c++11$ 可以正常编译。 解决方案：1.使用万能头文件 #include&lt;bits/stdc++.h&gt;；2.用命令行再编译一遍；3.编译的时候不要开 $-std=c++11$ 2020.10.30神奇的字母（alpha） 暴力把 $2^n$ 的数组开成 $n$。 2020.11.02六边形（hexagons） 记录数位 $dp$ 状态时，要把压不压上界也记进去。 因为压上界的转移有 $2^4=16$ 种。 硬币（coin） 要开 $long\\ long$。 2020.11.12帝国重建（empire） 当时正着想想错了，然后反着想，写了一个代码，后来发现也是错的。 这个可以通过对拍/造小数据检查出来。"}],"posts":[{"title":"超立方体","slug":"sol_26","date":"2020-11-12T16:00:00.000Z","updated":"2020-11-13T02:26:49.931Z","comments":true,"path":"2020/11/13/sol_26/","link":"","permalink":"http://hydd.cf/2020/11/13/sol_26/","excerpt":"","text":"设 $g_S$ 表示一维中相交情况为 $S$ 的方案数。（当 $n=3$ 时，$001$ 代表 $1,2$ 不相交，$1,3$ 不相交，$2,3$ 相交） 可以用搜索搜出所有 $g_S$，但是不同的搜索方法各自有一些问题： 直接搜 $l_i,r_i$，但是这样复杂度太高，$m=6$ 过不去。 搜的时候保证 $(l_i,r_i)\\leq(l_{i+1},r_{i+1})$，最后再枚举排列，但是这样的话有可能会算重（有可能有 $l_i=l_{i+1}$ 且 $r_i=r_{i+1}$）。 搜的时候保证 $(l_i,r_i)&lt;(l_{i+1},r_{i+1})$，但是这样少算了有区间相同的情况。 其实 $2,3$ 种方法应该都可以做，下面讲讲如果用第 $3$ 种搜法怎么做。 首先，枚举 $t$ 表示有 $t$ 个本质不同的区间（$l$ 不同或 $r$ 不同的区间视为本质不同） 然后，搜索 $(l_i,r_i),1\\leq i\\leq t$，求出在 $(l_i,r_i)&lt;(l_{i+1},r_{i+1})$ 的条件下，相交情况为 $s$ 的方案数，记作 $f_S$。 最后，枚举原问题的第 $i(1\\leq i\\leq m)$ 个区间是搜索出的哪个 $(l_j,r_j),1\\leq j\\leq t$，要求每个 $(l_j,r_j)$ 至少被选了一次，然后算出每种相交情况的方案数，记作 $g_S$。 算出 $g_S$ 后就解决了一维的情况，现在要求 $k$ 维的情况下两两不相交的方案数。 记 $h_S=\\sum_{S\\subseteq T} g_T$，即一维时相交情况至少是 $S$ 的方案数。 那么 $k$ 维时相交情况至少为 $S$ 的方案数是 $h_S^k$。再容斥回来就可以得到 $k$ 维是相交情况为 $0$ 的方案数，即答案。 这个容斥过程其实是 $FMT$。时间复杂度 $O(2^\\binom{m}{2}\\binom{m}{2}+T(m))$，$T(m)$ 为搜索的时间复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;const int Mod=998244353;typedef long long ll;int n,m,k,upperlim,tmp,tot[45],id[45]; bool vis[45];int f[110000],g[110000],C[45],num[45][45],numm[45][45];struct node&#123; int l,r; &#125; p[45];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void dfs(int dep,int pos,int lst)&#123; if (dep==(m&lt;&lt;1|1))&#123;//所有括号都放完了 int res=0; for (int i=1;i&lt;=m;i++) for (int j=i+1;j&lt;=m;j++) if (p[i].r&gt;=p[j].l) res|=(1&lt;&lt;num[i][j]); f[res]=(f[res]+C[pos])%Mod; return; &#125; for (int i=1;i&lt;=m;i++) if (!vis[i])&#123; vis[i]=true; p[i].l=pos+1; dfs(dep+1,pos+1,i); if (dep&gt;1&amp;&amp;i&gt;lst)&#123; p[i].l=pos; dfs(dep+1,pos,i); &#125; vis[i]=false; //先放左括号，再放右括号，左括号从小到大放，右括号从小到大放 break; &#125; for (int i=1;i&lt;=m;i++) if (vis[i]&amp;&amp;!vis[i+m])&#123; if (vis[i-1]&amp;&amp;p[i].l==p[i-1].l&amp;&amp;!vis[i-1+m]) continue; vis[i+m]=true; //二元关系严格&lt;，左括号位置相同的必须编号小的先放 p[i].r=pos+1; dfs(dep+1,pos+1,i+m); if (dep&gt;1&amp;&amp;i+m&gt;lst)&#123; if (p[i].l==pos||vis[i-1]&amp;&amp;p[i].l==p[i-1].l&amp;&amp;p[i-1].r==pos)&#123; vis[i+m]=false; continue;&#125; p[i].r=pos; dfs(dep+1,pos,i+m); &#125; //先放左括号，再放右括号，左括号从小到大放，右括号从小到大放 vis[i+m]=false; &#125;&#125;void dfs2(int now)&#123; if (now==tmp+1)&#123; for (int i=1;i&lt;=m;i++) if (!tot[i]) return; for (int s=0;s&lt;upperlim;s++) if (f[s])&#123; int res=0; for (int i=1;i&lt;=tmp;i++) for (int j=i+1;j&lt;=tmp;j++) if (id[i]==id[j]||(s&amp;(1&lt;&lt;num[id[i]][id[j]]))) res|=(1&lt;&lt;numm[i][j]); g[res]=(g[res]+f[s])%Mod; &#125; return; &#125; for (int i=1;i&lt;=m;i++)&#123; id[now]=i; tot[i]++; dfs2(now+1); tot[i]--; &#125;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;int main()&#123; freopen(&quot;box.in&quot;,&quot;r&quot;,stdin); freopen(&quot;box.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); k=read(); C[0]=1; for (int i=1;i&lt;=2*m;i++) C[i]=1ll*C[i-1]*(n-i+1)%Mod*qpow(i,Mod-2)%Mod; tmp=m; int cnt=0; for (int i=1;i&lt;=m;i++) for (int j=i+1;j&lt;=m;j++)&#123; numm[i][j]=cnt; numm[j][i]=cnt; cnt++; &#125; for (m=1;m&lt;=tmp;m++)&#123; cnt=0; for (int i=1;i&lt;=m;i++) for (int j=i+1;j&lt;=m;j++)&#123; num[i][j]=cnt; num[j][i]=cnt; cnt++; &#125; upperlim=1&lt;&lt;cnt; memset(f,0,sizeof(f)); dfs(1,0,-1); dfs2(1); &#125; for (int i=1;i&lt;upperlim;i&lt;&lt;=1) for (int s=0;s&lt;upperlim;s++) if (s&amp;i) g[s^i]=(g[s^i]+g[s])%Mod; for (int s=0;s&lt;upperlim;s++) g[s]=qpow(g[s],k); for (int i=1;i&lt;upperlim;i&lt;&lt;=1) for (int s=0;s&lt;upperlim;s++) if (s&amp;i) g[s^i]=(g[s^i]+Mod-g[s])%Mod; printf(&quot;%d\\n&quot;,g[0]); return 0;&#125;","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"http://hydd.cf/categories/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"http://hydd.cf/tags/%E5%AE%B9%E6%96%A5/"},{"name":"搜索","slug":"搜索","permalink":"http://hydd.cf/tags/%E6%90%9C%E7%B4%A2/"},{"name":"FMT","slug":"FMT","permalink":"http://hydd.cf/tags/FMT/"}]},{"title":"CSP-S2020 记录和总结","slug":"sum_5","date":"2020-11-12T16:00:00.000Z","updated":"2020-11-13T12:45:24.047Z","comments":true,"path":"2020/11/13/sum_5/","link":"","permalink":"http://hydd.cf/2020/11/13/sum_5/","excerpt":"","text":"考场策略&amp;时间分配 看了一遍题目后，认为 T1 大码量题，T2 不是很清楚，T3 神仙题，T4 可能可做。 按照 T1 - T2 - T4 - T3 的顺序开题。 T1 用了 1.3 h，刚开始往纯数学方面想，后来发现可以直接枚举 2000 年之前的，然后对后面 %400 处理一下即可。 T2 用了 20 min，刚开始用了 map 实现，后来发现 $q_i$ 互不相同，然后改为二进制或。 T4 用了大部分时间，刚开始使用堆可以做，然后改为双队列模拟，发现第三个和第四个大样例过不去（有些答案多了1），重新开始想，认为只有 ”第一次在最小值为第二个队列中的数的之后，新加入的值是队列中最小的“ 的个数的奇偶性有关，改了很长时间后才过两个大样例。 T3 用了剩下的 0.5 h，因为时间不多了，直接打 40pts 暴力，然后发现可以倒过来做，维护每个点能到达的 2 操作的乘积，然后按照拓扑序计算即可，打了一会儿发现来不及，就放弃了并开始检查。然后检查出 T4 的一个错误（它是最小的条件为它比第一个队列的队尾小并且比第二个队列的队尾小，当时只判了和第一个队列的大小关系）。 出考场后 发现 lyp 把 T3 A了，仔细想一想 T3 的确比 T4 好写一些。 还有人说 T2 $k=64,n=0$ 要特判，我没发现，可能要挂分。 后来发现的问题策略问题 因为 T3 的题面很长，特别是输入格式，而 T1 题目也这么长，再听说上午 J 组 T3 最难，就没有仔细想，去做 T4 了。这是很大的一个判断失误。 在 T4 70分打完后，先做 100 分，而不是先想/打 T3，也是一个失误。 细节问题 T2 当 $k=64$ 时，$1ull&lt;&lt;k$ 的值是 $1$（在 $NOILinux$ 下，这是未定义行为），而我认为是 $0$。当时没有检查 $k=64$ 的情况。","categories":[{"name":"CSP-S2020","slug":"CSP-S2020","permalink":"http://hydd.cf/categories/CSP-S2020/"}],"tags":[]},{"title":"20201113 记录和总结","slug":"sum_6","date":"2020-11-12T16:00:00.000Z","updated":"2020-11-13T12:45:55.563Z","comments":true,"path":"2020/11/13/sum_6/","link":"","permalink":"http://hydd.cf/2020/11/13/sum_6/","excerpt":"","text":"过程记录 做题顺序为 T2,T4,T3,T1。 考试的时候认为 T1 可能会挂，但没有很好的检查方法。 并没有对拍和极限数据（这个数据实在是太难造了）。 预计不到 400 分，实际 0+90+50+0。 T1 的问题： 应该只合并有标记的位置 判断条件为 $u,u+c$ 是否连通，而非是否 $0..2c+1$ 连通 要清空 $vis$ 数组（注意第二维要清空到 $2c$） T2 的问题： 当 $n=1$ 时，答案应该为 $0$，我在读入之前将 $dis[i][i]=0$，但是后面读入时有可能会读到自环，使得 $dis[i][i]$ 变为 $1$。 T3 的问题： 使用 $\\%d$ 输出 $\\rm long\\ long$。 理论上会有警告，但是使用 $VSCode$ 编译，没去看。 T4 的问题： 当时想的是把它变成一个合法的括号序。 所以在 $n$ 为奇数的时候我加入了一个 $(0,0)$。但是排序是按照第一维从小到大，第二维从大到小，所以有可能会跑到前面去，就不行了。实际上根本没必要。 解决方法 对拍（数据难造，暴力难写） T2 可以手造这样的小数据。T3 用 dev 编译即可。","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"http://hydd.cf/categories/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"三元环计数 笔记","slug":"note_5","date":"2020-11-09T16:00:00.000Z","updated":"2020-11-10T08:20:22.918Z","comments":true,"path":"2020/11/10/note_5/","link":"","permalink":"http://hydd.cf/2020/11/10/note_5/","excerpt":"","text":"前言 这个算法可以在 $O(m\\sqrt m)$ 的时间内找出无向图的所有三元环。 所以，如果是有向图，不妨将边看成无向边，求出后判断一下方向是否合法即可。 下面只讨论无向图的情况。 定义 对于一个 $n$ 个点 $m$ 条边的无向图，三元环定义为满足 $x-y,y-z,z-x$ 两两之间有边的无序三元组 $(x,y,z)$ 。 转化 定义点 $u$ 的权值为二元组 $(deg_u,u)$（$deg_u$ 为 $u$ 的度数）。显然任意两点权值互不相同。 将原图中的边定向，从权值大的点指向权值小的点。（二元组比较：先比较第一个数，再比较第二个数） 而新图的一条边方向表示的是两点的权值大小关系，所以这是一张 $DAG$。 求解 分成以下三个步骤： 枚举点 $u$（三元环中权值最大的点） 枚举点 $u$ 的出边，设指向的点为 $v$（三元环中权值次大的点） 枚举点 $v$ 的出边，设指向的点为 $w$（三元环中权值最小的点） 若点 $u$ 有指向 $w$ 的出边（这个可以通过对 $u$ 出边指向的点标记做到），则 $(u,v,w)$ 为一个三元环。 正确性证明 显然这样求出的所有 $(u,v,w)$ 都是三元环。 而对于原图中的三元环 $(u,v,w)$，不妨设 $cost_u&gt;cost_v&gt;cost_w$。那么枚举 $u$ 的时候必有 $v$ 的出边，枚举 $v$ 的时候必有 $w$ 的出边，且 $u$ 必有指向 $w$ 的出边，故所有三元环都会计算到。 复杂度证明 在枚举 $u$ 的出边时，每条边都被访问一次。 在枚举 $v$ 的出边时，每条边被访问了 $ind_v$（新图中 $v$ 的入度） 次，而所有指向 $v$ 的点 $u$ 都要满足 $deg_u\\geq deg_v$，$2m\\geq \\sum_u deg_u\\geq \\sum_u deg_v\\geq \\sum_u ind_v=ind_v\\times ind_v$（无向图所有点的度数和为 $2m$）。所以 $ind_v\\leq \\sqrt{2m}$。 故每条边被访问了 $O(\\sqrt m)$次，总时间复杂度为 $O(m\\sqrt m)$。 例题HDU6184 Counting Stars题意 给定一张 $n$ 个点 $m$ 条边的无向图。 若一个导出子图满足 $V=(A,B,C,D)$ 且 $E=(AB,BC,CD,DA,AC)$ ，则称它是 $A-structure$。 求 $A-structure$ 的个数。数据组数不超过 $300$。 $2 \\leq n \\leq 10^{5}, 1 \\leq m \\leq \\min \\left(2 \\times 10^{5}, \\frac{n(n-1)}{2}\\right),\\sum n \\leq 3 \\times 10^{5}, \\sum m \\leq 6 \\times 10^{5}$ 题解 $A-structure$ 是由有一条公共边的两个三元环构成的。 枚举公共边，答案为 $\\sum_{i=1}^m\\binom{cnt_i}2$。其中 $cnt_i$ 是经过第 $i$ 条边的三元环个数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pii;typedef long long ll;int T,n,m,u[210000],v[210000],Ans[210000];int deg[110000],tag[110000],lst[110000]; pii val[110000];int edgenum,vet[410000],Next[410000],Head[210000];void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;int main()&#123; while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2)&#123; edgenum=0; for (int i=1;i&lt;=n;i++)&#123; deg[i]=0; tag[i]=0; lst[i]=0; Head[i]=0; &#125; for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d&quot;,&amp;u[i],&amp;v[i]); deg[u[i]]++; deg[v[i]]++; Ans[i]=0; &#125; for (int i=1;i&lt;=n;i++) val[i]=pii(deg[i],i); for (int i=1;i&lt;=m;i++) if (val[u[i]]&gt;val[v[i]]) addedge(u[i],v[i]); else addedge(v[i],u[i]); for (int u=1;u&lt;=n;u++)&#123; for (int e=Head[u];e;e=Next[e])&#123; int v=vet[e]; tag[v]=u; lst[v]=e; &#125; for (int e=Head[u];e;e=Next[e])&#123; int v=vet[e]; for (int f=Head[v];f;f=Next[f])&#123; int w=vet[f]; if (tag[w]!=u) continue; Ans[e]++; Ans[f]++; Ans[lst[w]]++; &#125; &#125; &#125; ll ans=0; for (int i=1;i&lt;=m;i++) ans+=1ll*Ans[i]*(Ans[i]-1)&gt;&gt;1; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hydd.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://hydd.cf/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"20201021 模拟赛题解","slug":"sol_24","date":"2020-10-20T16:00:00.000Z","updated":"2020-10-21T13:54:48.789Z","comments":true,"path":"2020/10/21/sol_24/","link":"","permalink":"http://hydd.cf/2020/10/21/sol_24/","excerpt":"","text":"escape 由于要求字典序最小，所以从左到右，尽量使得每一位尽量小。 交换两个字符相当于把后面一个字符移到前面。 可以发现，如果这个位置最后位置放的是字符 $x$，那么一定是往后离它最近的 $x$ 移到了这个位置。 从小到大枚举第 $i$ 个位置的字符 $x$，设往后离它最近的 $x$ 的位置为 $pos$，则移动步数为 $pos-x$。若 $pos-x\\leq k$，则当前位置可以放 $x$，将原先 $i..pos$ 的位置上的数都往后移一格即可。 具体实现，可以考虑记录每个字符从左到右出现的位置。每次移动，要将 $i..pos-1$ 的位置上的数都往右移，暴力做是 $O(n^2)$ 的，但是可以发现，这只是相当于原来在 $i..pos-1$ 位置上的数，现在的位置往右移了一格。 原来在 $pos$ 位置上的数，以后都不用考虑了，可以认为被删除了。现在的操作相当于删除一格字符，把前面的数都往后移一格。 用树状数组维护，原来在 $x$ 位置的字符，现在往右移了多少格。每次删除了一格字符，只是将树状数组一段位置上的数 $+1$。 但是每次要枚举每个字符，算出每个字符最靠左的位置。这样是 $O(n|\\Sigma|\\log n)$（$|\\Sigma|$表示字符集大小）。 可以发现，删除一个字符 $x$ 后，别的字符最靠左的位置是否往右移一格是可以 $O(1)$ 计算的。字符 $x$ 新的最靠左的位置可以 $O(\\log n)$ 计算。删除次数是 $O(n)$ 的，一次删除的复杂度是 $O(|\\Sigma|+\\log n)$ 的。 总时间复杂度 $O(n(|\\Sigma|+\\log n))$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;int n,len[510000],tree[510000],q[510000];ll k;vector&lt;int&gt; vec[26];char s[510000],t[510000];inline int myabs(int x)&#123; return x&gt;0?x:-x;&#125;void add(int x,int y)&#123; for (;x&lt;=n;x+=x&amp;-x) tree[x]+=y;&#125;int getsum(int x)&#123; int res=0; for (;x;x-=x&amp;-x) res+=tree[x]; return res;&#125;int getnum(int t)&#123; if (!len[t]) return -1; int x=vec[t][len[t]-1]; return x+getsum(n-x+1);&#125;int main()&#123; freopen(&quot;escape.in&quot;,&quot;r&quot;,stdin); freopen(&quot;escape.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%lld&quot;,&amp;n,&amp;k); scanf(&quot;%s&quot;,s+1); for (int i=n;i&gt;=1;i--)&#123; vec[s[i]-&#x27;a&#x27;].push_back(i); len[s[i]-&#x27;a&#x27;]++; &#125; for (int j=0;j&lt;26;j++) q[j]=getnum(j); int x,y; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;26;j++) if (len[j])&#123; x=vec[j][len[j]-1]; y=q[j]; if (k-(y-i)&gt;=0)&#123; k-=(y-i); t[i]=char(j+&#x27;a&#x27;); int tmp=n-x+1; add(tmp,1); len[j]--; q[j]=getnum(j); for (int k=0;k&lt;26;k++) if (len[k]&amp;&amp;k!=j)&#123; x=vec[k][len[k]-1]; if (tmp&lt;=n-x+1) q[k]++; &#125; break; &#125; &#125; printf(&quot;%s\\n&quot;,t+1); return 0;&#125; ride 先求出从每个点出发，海拔单调下降的路径数量。 因为海拔就等于点的编号，从小到大枚举编号，然后直接 $dp$ 即可，$dp[u]=1+\\sum_{(u,v)\\in E,v&lt;u} dp[v]$。 以 $u$ 为最高点的路径数量为 $\\sum_{(u,v)\\in E,v&lt;u}\\sum_{(u,w)\\in E,w&lt;u,w\\neq v}dp[v]\\times dp[w]=\\sum_{(u,v)\\in E,v}dp[v]\\times(dp[u]-dp[v])$。 直接算即可。时间复杂度 $O(n)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;int n; ll dp[310000];vector&lt;int&gt; vec[310000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;int main()&#123; freopen(&quot;ride.in&quot;,&quot;r&quot;,stdin); freopen(&quot;ride.out&quot;,&quot;w&quot;,stdout); n=read(); int u,v; for (int i=1;i&lt;n;i++)&#123; u=read(); v=read(); if (u&gt;v) swap(u,v); vec[v].push_back(u); &#125; ll ans=0; for (int i=1;i&lt;=n;i++)&#123; for (int j=0;j&lt;(int)vec[i].size();j++) dp[i]+=dp[vec[i][j]]; for (int j=0;j&lt;(int)vec[i].size();j++) ans+=dp[vec[i][j]]*(dp[i]-dp[vec[i][j]]); dp[i]++; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; road 可以发现，当 $u\\neq v$ 时： 设 $(u,v)$ 之间长度为奇数的最短路长度为 $d_1$，那么 $(u,v)$ 之间必定存在长度为 $d(2\\nmid d,d\\geq d_1)$ 的路径。（$d_1$ 存在） 设 $(u,v)$ 之间长度为偶数的最短路长度为 $d_0$，那么 $(u,v)$ 之间必定存在长度为 $d(2\\mid d,d\\geq d_0)$ 的路径。（ $d_2$ 存在） 直接求出任意两点长度为奇数/偶数的最短路即可。这个直接处理不太方便，可以新建 $n+1,n+2,\\cdots ,2n$ 这些点，将原图一条边无向边 $(u,v)$ 改为两条无向边 $(u,v+n),(u+n,v)$。这样从 $x$ 点出发，到 $y$ 号点的最短路就是偶数条边，到 $y+n$ 号点的最短路是奇数条边。 当 $u=v$ 时 长度为奇数的还是可以用上面的方法判断 长度为偶数，如果 $u$ 号点有边和其他点连接，那么必定为 $Yes$。 长度为偶数，如果 $u$ 号点没有边和其他点连接，那么 $d=0$ 为 $Yes$，否则为 $No$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int INF=0x3f3f3f3f;struct node&#123; int x,d,id; node()&#123;&#125; node(int _x,int _d,int _id):x(_x),d(_d),id(_id)&#123;&#125;&#125;;int n,m,Q,dis[110000],Ans[110000];int head,tail,que[110000];vector&lt;int&gt; vec[11000];vector&lt;node&gt; q[11000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void bfs(int u)&#123; for (int i=1;i&lt;=n+n;i++) dis[i]=INF; head=1; tail=1; que[1]=u; dis[u]=0; int v; while (head&lt;=tail)&#123; u=que[head++]; for (int i=0;i&lt;(int)vec[u].size();i++)&#123; v=vec[u][i]; if (dis[v]&gt;dis[u]+1)&#123; dis[v]=dis[u]+1; que[++tail]=v; &#125; &#125; &#125;&#125;int main()&#123; freopen(&quot;road.in&quot;,&quot;r&quot;,stdin); freopen(&quot;road.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); Q=read(); int u,v; for (int i=1;i&lt;=m;i++)&#123; u=read(); v=read(); vec[u].push_back(v+n); vec[u+n].push_back(v); vec[v].push_back(u+n); vec[v+n].push_back(u); &#125; int s,t,d; for (int i=1;i&lt;=Q;i++)&#123; s=read(); t=read(); d=read(); if (d&amp;1) t+=n; q[s].push_back(node(t,d,i)); &#125; int x,y; for (int i=1;i&lt;=n;i++)&#123; bfs(i); for (int j=0;j&lt;(int)q[i].size();j++)&#123; x=q[i][j].x; y=q[i][j].d; if (x==i)&#123; if (!vec[x].empty()) Ans[q[i][j].id]=1; else Ans[q[i][j].id]=(y==0); continue; &#125; if (dis[x]&lt;=y) Ans[q[i][j].id]=1; else Ans[q[i][j].id]=0; &#125; &#125; for (int i=1;i&lt;=Q;i++) if (Ans[i]) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; tree 题目要求的是 $\\sum_d (\\sum_{i=1}^{n/2} d_i)^2=\\sum_d(\\sum_{i=1}^{n/2} d_i^2+\\sum_{1\\leq i\\leq n/2}\\sum_{1\\leq j\\leq n/2,j\\neq i} d_id_j)$。 $n$ 个点的数，匹配的方案数为 $F(n)=(n-1)(n-3)(n-5)\\cdots1$。 这个可以考虑第一个点和谁匹配，有 $(n-1)$ 种方案。再考虑还没有匹配中的第一个点和谁匹配，有 $(n-3)$ 种方案，以此类推。 $\\sum_d\\sum_{i=1}^{n/2} d_i^2$ 这个可以考虑每个匹配的贡献。对于一个匹配 $(a,b)$ ，它的贡献次数为 $F(n-2)$ 次，贡献为 $dis^2(a,b)$。相当于 $\\sum_d\\sum_{i=1}^{n/2} d_i^2=F(n-2)\\sum_{1\\leq a\\leq n}\\sum_{1\\leq b\\leq n,b\\neq a} dis^2(a,b)$。后面的部分可以通过换根 $dp$ 处理。 设 $h[u]$ 表示 $u$ 子树中点的个数，$g[u]$ 表示 $u$ 子树中每个点的深度之和，$f[u]$ 表示 $u$ 子树中每个点深度的平方和。 那么 $h[u]=1+\\sum_v h[v],g[u]=\\sum_v (g[v]+h[v]),f[u]=\\sum_v(f[v]+2g[v]+h[v])$。 换根 $dp$，记根为 $u$ 的时候 $f[u]$ 的值为 $q[u]$（即所有点到 $u$ 距离的平方和）。在将以 $u$ 为根时的 $g[u]$ 求和 /2 的值即为 $s$（即所有点两两距离之和）。 然后记 $S=\\sum_{i=1}^n q[u]$，$\\sum_d\\sum_{i=1}^{n/2} d_i^2=F(n-2)S$。 \\begin{align*} &\\quad\\sum_d\\sum_{1\\leq i\\leq n/2}\\sum_{1\\leq j\\leq n/2,j\\neq i} d_id_j\\\\ &=F(n-4)\\frac12\\sum_{1\\leq a\\leq n}\\sum_{1\\leq b\\leq n,b\\neq a}\\sum_{1\\leq c\\leq n,c\\neq a,b}\\sum_{1\\leq d\\leq n,d\\neq a,b,c} dis(a,b)dis(c,d)\\\\ &=F(n-4)\\frac12\\sum_{1\\leq a\\leq n}\\sum_{1\\leq b\\leq n,b\\neq a} dis(a,b)(s-q[a]-q[b]+dis(a,b)\\\\ &=F(n-4)\\frac12\\sum_{1\\leq a\\leq n}\\sum_{1\\leq b\\leq n,b\\neq a} dis(a,b)(s-q[a]-q[b]+dis(a,b))\\\\ &=F(n-4)(\\frac12(s^2+S)-q[a]\\sum_{1\\leq a\\leq n}dis(a,b))\\\\ &=F(n-4)(\\frac12(s^2+S)-q[a]^2)\\\\ \\end{align*} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;using namespace std;const int Mod=998244353;const int inv2=(Mod+1)/2;int n,ans,ans2,s,h[310000],g[310000],f[310000],q[310000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;int edgenum,vet[610000],Next[610000],Head[310000];void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;inline int add(int x,int y)&#123; return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123; return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123; return 1ll*x*y%Mod;&#125;void upd(int u,int v)&#123; h[u]=add(h[u],h[v]); g[u]=add(g[u],add(g[v],h[v])); f[u]=add(f[u],add(f[v],add(h[v],add(g[v],g[v]))));&#125;void rupd(int u,int v)&#123; h[u]=dec(h[u],h[v]); g[u]=dec(g[u],add(g[v],h[v])); f[u]=dec(f[u],add(f[v],add(h[v],add(g[v],g[v]))));&#125;void dfs(int u,int fa)&#123; f[u]=0; g[u]=0; h[u]=1; int v; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (v==fa) continue; dfs(v,u); upd(u,v); &#125;&#125;void dfs2(int u,int fa)&#123; ans=add(ans,f[u]); s=add(s,g[u]); q[u]=g[u]; int v; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (v==fa) continue; rupd(u,v); upd(v,u); dfs2(v,u); rupd(v,u); upd(u,v); &#125; &#125;int main()&#123; freopen(&quot;tree.in&quot;,&quot;r&quot;,stdin); freopen(&quot;tree.out&quot;,&quot;w&quot;,stdout); n=read(); int u,v; for (int i=1;i&lt;n;i++)&#123; u=read(); v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); dfs2(1,0); ans=mul(ans,inv2); s=mul(s,inv2); ans2=add(ans2,mul(s,s)); ans2=add(ans2,ans); for (int i=1;i&lt;=n;i++) ans2=dec(ans2,mul(q[i],q[i])); for (int i=n-3;i&gt;=1;i-=2) ans=mul(ans,i); for (int i=n-5;i&gt;=1;i-=2) ans2=mul(ans2,i); ans=add(ans,ans2); printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"http://hydd.cf/categories/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"20201016 模拟赛题解","slug":"sol_23","date":"2020-10-18T16:00:00.000Z","updated":"2020-10-19T06:11:27.196Z","comments":true,"path":"2020/10/19/sol_23/","link":"","permalink":"http://hydd.cf/2020/10/19/sol_23/","excerpt":"","text":"count 不想重新再手打一遍了 QAQ。 算了再打一遍吧。 \\begin{align*} f_m(n)&=\\sum_{i=0}^na_i\\sum_{j=0}^n(-1)^j\\binom{m}{j}\\binom{n-m}{i-j}\\\\ \\\\ F(x)&=\\sum_{i=0}^nx^i\\sum_{j=0}^n(-1)^j\\binom{m}{j}\\binom{n-m}{i-j}\\\\ &=\\sum_{a=0}^m\\sum_{b=0}^{n-m}\\left(\\binom{m}{a}x^a(-1)^a\\right)\\left(\\binom{n-m}{b}x^b\\right)\\\\ &=\\sum_{a=0}^m\\left(\\binom{m}{a}(-x)^a1^{m-a}\\right)\\sum_{b=0}^{n-m}\\left(\\binom{n-m}{b}x^b1^{n-m-b}\\right)\\\\ &=(1-x)^m(1+x)^{n-m}\\\\ &=(2-(1+x))^m(1+x)^{n-m}\\\\ &=\\sum_{i=0}^m\\binom{m}{i}2^i(1+x)^{m-i}(-1)^{m-i}(1+x)^{n-m}\\\\ &=\\sum_{i=0}^m\\binom{m}{i}2^i(1+x)^{n-i}(-1)^{m-i}\\\\ &=\\sum_{i=0}^m\\binom{m}{i}2^i(-1)^{m-i}\\left(\\sum_{j=0}^{n-i}\\binom{n-i}{j}x^j\\right)\\\\ \\\\ f_m(n)&=\\sum_{i=0}^m\\binom{m}{i}2^i(-1)^{m-i}\\left(\\sum_{j=0}^{n-i}\\binom{n-i}{j}a_j\\right)\\\\ \\\\ G(x)&=f_0(n)x^0+f_1(n)x^1+f_2(n)x^2+\\cdots+f_n(n)x^n\\\\ &=\\sum_{m=0}^nf_m(n)x^m\\\\ &=\\sum_{m=0}^n x^m\\sum_{i=0}^m\\binom{m}{i}2^i(-1)^{n-i}\\left(\\sum_{j=0}^{n-i}\\binom{n-i}{j}a_j\\right)\\\\ &=\\sum_{m=0}^n m!\\sum_{i=0}^m\\frac{2^i\\left(\\sum_{j=0}^{n-i}\\binom{n-i}{j}a_j\\right)x^i}{i!}\\frac{(-1)^{m-i}x^{m-i}}{(m-i)!}\\\\ \\\\ D(x)&=\\sum_{i=0}^n2^i\\left(\\sum_{j=0}^{n-i}\\binom{n-i}{j}a_j\\right)\\frac{x^i}{i!}\\\\ E(x)&=\\sum_{i=0}^n(-1)^i\\frac{x^i}{i!} \\\\ G(x)&=\\sum_{m=0}^n m!x^m\\sum_{i=0}^mD[x^i]E[x^{m-i}]\\\\ &=\\sum_{m=0}^n m!x^m(D\\times E)[x^m]\\\\ \\\\ D(x)&=\\sum_{i=0}^n2^i\\left(\\sum_{j=0}^{n-i}\\binom{n-i}{j}a_j\\right)\\frac{x^i}{i!}\\\\ C(x)&=\\sum_{i=0}^nx^i\\sum_{j=0}^{i}\\binom{i}{j}a_j\\\\ &=\\sum_{i=0}^ni!\\sum_{j=0}^{i}\\frac{a_jx^j}{j!}\\frac{x^{i-j}}{(i-j)!}\\\\ \\\\ A(x)&=\\sum_{i=0}^{n}a_i\\frac{x^i}{i!}\\\\ B(x)&=\\sum_{i=0}^{n}\\frac{x^i}{i!}\\\\ C(x)&=\\sum_{i=0}^n i!x^i\\sum_{j=0}^iA[x^j]B[x^{i-j}]\\\\ &=\\sum_{i=0}^n i!x^i(A\\times B)[x^i]\\\\ D(x)&=\\sum_{i=0}^n2^iC[x^{n-i}]\\frac{x^i}{i!}\\\\ E(x)&=\\sum_{i=0}^n(-1)^i\\frac{x^i}{i!}\\\\ G(x)&=\\sum_{m=0}^n m!x^m(D\\times E)[x^m]\\\\ Ans&=G(1000000007) \\end{align*}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/********************************************************************* * Source：安师大省选模拟2 * Problem：count - T1 * Author：hydd * Date：2020/10/16*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;const int g=3;const int Mod=998244353;const unsigned val=1000000007;typedef vector&lt;ll&gt; poly;int n,s,m,t,rev[2100000];ll fac[2100000],inv[2100000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline ll add(ll x,ll y)&#123; return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline ll dec(ll x,ll y)&#123; return x-y&lt;0?x-y+Mod:x-y;&#125;inline ll mul(ll x,ll y)&#123; return x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(ll x)&#123; return qpow(x,Mod-2);&#125;poly A,B,C;void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; ll tmp=qpow(g,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (int j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; ll x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y); a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(poly a,poly b,poly &amp;c,int n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;int main()&#123; freopen(&quot;count.in&quot;,&quot;r&quot;,stdin); freopen(&quot;count.out&quot;,&quot;w&quot;,stdout); fac[0]=1; for (int i=1;i&lt;=2000000;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=2000000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=2000000;i++) inv[i]=inv[i-1]*inv[i]%Mod; n=read(); A.resize(n+1); B.resize(n+1); B[0]=read(); s=read(); m=read(); t=read(); for (int i=0;i&lt;=n;i++) A[i]=inv[i]; for (int i=1;i&lt;=n;i++) B[i]=((B[i-1]^s)*m+t)%Mod; for (int i=0;i&lt;=n;i++) B[i]=B[i]*inv[i]%Mod; mult(A,B,C,n+1); for (int i=0;i&lt;=n;i++) C[i]=C[i]*fac[i]%Mod; A.resize(n+1); B.resize(n+1); ll now=1; for (int i=0;i&lt;=n;i++)&#123; A[i]=C[n-i]*inv[i]%Mod*now%Mod; now=add(now,now); &#125; for (int i=0;i&lt;=n;i++)&#123; B[i]=inv[i]; if (i&amp;1) B[i]=(Mod-B[i])%Mod; &#125; mult(A,B,C,n+1); for (int i=0;i&lt;=n;i++) C[i]=C[i]*fac[i]%Mod; unsigned ans=0; for (int i=n;i&gt;=0;i--) ans=ans*val+(unsigned)C[i]; printf(&quot;%u\\n&quot;,ans); return 0;&#125; path一个结论 先给出一个结论： 一条合法的路径上，一定存在一条边 $(a,b)$，使得这条边上的顶点序列，存在相邻的两个点 $a,b$。 证明： 考虑设函数 $f(x)$ 表示走过 $x$ 个点的时候，经过的边上的顶点序列的长度之和。 $f(1)=0,f(n)=n$，$f(x)$ 单调不降。 原命题等价于存在 $1\\leq i&lt;n,f(i)&lt;i,f(i+1)\\geq i+1$。 显然成立。 第一问 我们可以对所有满足“这条边上的顶点序列上存在相邻的两个点 $a,b$”的所有边 $(a,b)$，往左右不断扩展，看是否合法。若合法，输出即可。 第二问定义 现在，我们定义 $4$ 种路径： 左开右闭：路径上的边的顶点序列接起来，没有路径上的第一个点。 左闭右开：路径上的边的顶点序列接起来，没有路径上的最后一个点。 左闭右闭：路径上的边的顶点序列接起来，有路径上的所有点。 左开右开：路径上的边的顶点序列接起来，没有路径上的第一个点和最后一个点。 我们定义极短路径为：不能切割得到更短的路径拼接起来。（这个定义对以上 $4$ 种都成立） 左开右开极短路径 若一条边上顶点序列为空，那这条边就是左开右开极短路径。 如果有更长的左开右开路径，那么不是极短的。 它必定可以用 左开右开极短路径+左闭右开路径 或 左开右闭极短路径+左开右开路径表示。 取决于它的第一条边上的顶点序列是否为空。 左闭右开极短路径 枚举这种路径的结尾边 $(u,v)$。 结尾边上的顶点序列最后一个点若为 $u$，那么往左扩展，如果合法，就是一条极短的左闭右开路径。 这个求出来的路径显然两两不同。（因为它只向一边扩展） 接下来证明它不能由 左闭右开路径+左闭右开极短路径 或 左闭右闭路径+左开右开极短路径表示。 第一种显然不可能，现在是固定最后一个点，往左扩展，如果扩展到已经满足条件了，就不会再扩展了。 第二种也不可能，左开右开极短路径是一条顶点序列为空的边，而现在的路径要求结尾边的顶点序列最后一个点为 $u$，矛盾。 左开右闭极短路径 先建反图，将路径上的顶点序列也反过来。 剩下的做法和“左闭右开极短路径”一样，证明也同理。 左闭右闭极短路径 可以通过第一问的方法可以得到若干条极短的合法（左闭右闭）路径。 但是，它往两边扩展，会不会有两个满足条件的边，它们扩展出来是同一条路径呢？ 可以发现，求出来的极短的合法（左闭右闭）路径是两两不重复的。 证明： 如果有重复，那就说明有一条极短的合法路径，上面出现了两条边 $(a_1,b_1),(a_2,b_2)$ 满足条件（这条边上的顶点序列上存在相邻的两个点 $a,b$） 不妨设在路径上 $(a_1,b_1)$ 在 $(a_2,b_2)$ 之前出现。那么 $(a_2,b_2)$ 是 $(a_1,b_1)$ 向右扩展时走到的。 那么，如果要加入 $(a_2,b_2)$ 这条边，那么在加入这条边之前的时刻，剩下将要经过的顶点序列中，前两个为 $(a_2,b_2)$。现在加入这条边后，将要经过的顶点序列中有新出现了 $(a_2,b_2)$，那么路径成环了，不可能长度 $\\leq 2*n$。 由于中心边唯一，扩展出的路径必定是极短路径。 可以发现，每个路径只有一种极短路径分解方法，否则就和极短的定义矛盾了。 由于这些路径唯一，所以这些路径组合拼接成的更长的路径，也是不重复的。 记 $dp1[0/1][0/1][i][j][k]$ 分别表示左开/闭，右开/闭，起点为 $i$，终点为 $j$，长度为 $k$ 的极短路径条数。 记 $dp2[k][i][0/1]$ 分别表示路径长度为 $k$，当前路径最后一个点为 $i$， 是开/闭的路径条数。 答案为 $\\sum_k\\sum_i dp2[k][i][1]$。 时间复杂度 $O(n^2m+n^3)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/********************************************************************* * Source：安师大省选模拟2 * Problem：path - T2 （CF331E1/E2） * Author：hydd * Date：2020/10/18*********************************************************************/#include&lt;cstdio&gt;#include&lt;utility&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;typedef pair&lt;int,int&gt; pii;const int Mod=1e9+7;int n,m,num[110][110],v[110];int top,s[21000],top2,s2[21000];int ans,Ans[21000];vector&lt;int&gt; vec[21000];struct node&#123; int x,y,k;&#125; a[21000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;pii get_path(int x,bool rev)&#123;//从正边/反边上走 int now=0,y,e; for (int i=1;i&lt;=top&amp;&amp;top&lt;=2*n;i++)&#123; y=s[i]; e=num[x][y]; if (!e||(rev&amp;&amp;e&lt;=m)||(!rev&amp;&amp;e&gt;m)) return pii(2*n+1,2*n+1); for (int j=0;j&lt;(int)vec[e].size();j++) s[++top]=vec[e][j]; x=y; now++; &#125; return pii(top,x);&#125;int dp1[2][2][55][55][110],dp2[110][55][2];int f[55][55][110],g[55][55][110];void work(bool rev)&#123;//路径是否反过来了 memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); for (int i=1;i&lt;=m*2;i++)&#123; if ((rev&amp;&amp;i&lt;=m)||(!rev&amp;&amp;i&gt;m)) continue; for (int j=0;j&lt;(int)vec[i].size();j++) if (vec[i][j]==a[i].x)&#123; top=0; for (int k=j-1;k&gt;=0;k--) s[++top]=vec[i][k]; pii res=get_path(a[i].x,!rev); if (res.first+1&gt;2*n) continue; if (j+1==(int)vec[i].size()) g[res.second][a[i].y][res.first+1]++;//左闭右开 else&#123; if (vec[i][j+1]!=a[i].y) continue; top2=0; for (int i=top;i&gt;=1;i--) s2[++top2]=s[i]; top=0; for (int k=j+2;k&lt;(int)vec[i].size();k++) s[++top]=vec[i][k]; pii res2=get_path(a[i].y,rev); if (res2.first+1+res.first&gt;2*n) continue; if (!ans)&#123; for (int i=1;i&lt;=top2;i++) Ans[++ans]=s2[i]; Ans[++ans]=a[i].x; Ans[++ans]=a[i].y; for (int i=1;i&lt;=top;i++) Ans[++ans]=s[i]; &#125; f[res.second][res2.second][res2.first+1+res.first]++;//左闭右闭 &#125; &#125; &#125;&#125;int main()&#123; freopen(&quot;path.in&quot;,&quot;r&quot;,stdin); freopen(&quot;path.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int x,y,k; for (int i=1;i&lt;=m;i++)&#123; x=read(); y=read(); k=read(); for (int j=1;j&lt;=k;j++) v[j]=read(); a[i].x=x; a[i].y=y; a[i].k=k; num[x][y]=i; for (int j=1;j&lt;=k;j++) vec[i].push_back(v[j]); a[i+m].x=y; a[i+m].y=x; a[i+m].k=k; num[y][x]=i+m; for (int j=1;j&lt;=k;j++) vec[i+m].push_back(v[k-j+1]); if (!k) dp1[0][0][x][y][1]++; &#125; work(false); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) for (int k=1;k&lt;=n*2;k++)&#123; dp1[1][1][i][j][k]=f[i][j][k]; dp1[1][0][i][j][k]=g[i][j][k]; &#125; if (ans)&#123; printf(&quot;%d\\n&quot;,ans); for (int i=1;i&lt;ans;i++) printf(&quot;%d &quot;,Ans[i]); printf(&quot;%d\\n&quot;,Ans[ans]); &#125; else puts(&quot;0\\n&quot;); work(true); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) for (int k=1;k&lt;=n*2;k++) dp1[0][1][i][j][k]=g[j][i][k]; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) for (int k=1;k&lt;=n*2;k++)&#123; dp2[k][j][0]=(dp2[k][j][0]+dp1[1][0][i][j][k])%Mod; dp2[k][j][1]=(dp2[k][j][1]+dp1[1][1][i][j][k])%Mod; &#125; for (int p=1;p&lt;=n*2;p++)&#123; int res=0; for (int i=1;i&lt;=n;i++)&#123; res=(res+dp2[p][i][1])%Mod; for (int m=0;m&lt;=1;m++) if (dp2[p][i][m])&#123; for (int s=0;s&lt;=1;s++) for (int x=1;x&lt;=n;x++) for (int q=1;q&lt;=n*2-p;q++) dp2[p+q][x][s]=(dp2[p+q][x][s]+1ll*dp2[p][i][m]*dp1[m^1][s][i][x][q])%Mod; &#125; &#125; printf(&quot;%d\\n&quot;,res); &#125; return 0;&#125; graph 建立一个这样的网络模型： 新建一个汇点 $T$（不妨设它为$(-\\inf,-\\inf)$），在原图上选一个点（不妨选横坐标最小的点，保证平面图的性质），将 $T$ 和这个点连边。 每个点自带一个单位的流量，流量沿着原图的边可以双向流动。 那么原图所有点的流出量-流入量=1。 可以发现，因为原图是个平面图，所以一个环内的点数是从环上流出环的流量总和-从环外流入环的流量总和。 如何求一个可行的流量呢？就直接随便搞一颗以 $T$ 为根的生成树即可，每个点往父亲的流量就是这个点的子树大小。 从环外流入环的流量总和=父亲在环上，自己在环外的点的子树大小之和。 从环上流出环的流量总和=父亲在环外，自己在环上的点的子树大小之和。 *这个大小就是边上的流量。 由于是平面图，所以对于环上的任意点，把它的所有出边按极角排序，那么往环外走的边是一段连续的区间。 答案=环上流出环的流量总和-从环外流入环的流量总和。对于每个在环上的点： “从环上流出环的流量总和=父亲在环外，自己在环上的点的子树大小之和”。当前点在环上，若父亲在环外，有贡献 $+sz[fa]$。 “从环外流入环的流量总和=父亲在环上，自己在环外的点的子树大小之和”。当前点在环上，若儿子在环外，有贡献 $-sz[son]$。 *流出为负，流入为正，类似于正向边和反向边。 可以将每个点的出边极角排序，父亲的贡献设为 $+sz[]$，儿子的贡献设为 $-sz[]$，由于往环外走的边是一段连续的区间，求这个区间贡献之和即可。 怎么求这个区间呢？这个可以将每条边极角排序的排名记录下来，就可以得到区间的两个端点。（具体实现可以看代码） 因为题目没有说是顺时针还是逆时针方向，所以求出了区间的两个端点后，不知道哪一部分是在环内，哪一部分是在环外，所以我们要规定方向。 随便在环上选一个点 $O$，对环上的任意一条边，求出 $O$ 和它围成三角形的有向面积（叉积 $ab\\sin\\theta$），求和看正负即可判断是顺时针还是逆时针。 比如我们统一为逆时针，给出的是顺时针，就把给出的点 $reverse$ 一下即可。（具体实现看代码） 时间复杂度： 预处理，求生成树 $O(n)$。 将每个点的出边极角排序，最坏情况下为 $O(m\\log m)$。 求答案 $O(\\sum k)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/********************************************************************* * Source：安师大省选模拟2 * Problem：graph - T3 （CF223E） * Author：hydd * Date：2020/10/17*********************************************************************/#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;utility&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;int n,m,q,k,a[110000],cnt,tmp[110000];int edgenum=1,vet[610000],val[610000],Next[610000],Head[110000];double ang[610000]; bool vis[110000];map&lt;pii,int&gt; rnk;vector&lt;ll&gt; sum[110000];struct node&#123; int x,y; node()&#123;&#125; node(int _x,int _y):x(_x),y(_y)&#123;&#125;&#125; p[110000];node operator-(const node &amp;a,const node &amp;b)&#123; return node(a.x-b.x,a.y-b.y);&#125;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;int dfs(int u)&#123; vis[u]=true; int flow=1,tmp; for (int e=Head[u];e;e=Next[e]) if (!vis[vet[e]])&#123; tmp=dfs(vet[e]); val[e]+=tmp; val[e^1]-=tmp; flow+=tmp; &#125; return flow;&#125;inline bool cmp(int a,int b)&#123; return ang[a]&lt;ang[b];&#125;inline ll cross(node x,node y)&#123; return 1ll*x.x*y.y-1ll*x.y*y.x;&#125;int main()&#123; freopen(&quot;graph.in&quot;,&quot;r&quot;,stdin); freopen(&quot;graph.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); int u,v; for (int i=1;i&lt;=m;i++)&#123; u=read(); v=read(); addedge(u,v); addedge(v,u); &#125; for (int i=1;i&lt;=n;i++) p[i].x=read(),p[i].y=read(); p[n+1].x=-1e9; p[n+1].y=-1e9; int rt=1; for (int i=2;i&lt;=n;i++) if (p[i].x&lt;p[rt].x) rt=i; addedge(n+1,rt); dfs(n+1); for (int u=1;u&lt;=n;u++)&#123; cnt=0; for (int e=Head[u];e;e=Next[e])&#123; tmp[++cnt]=e; v=vet[e]; ang[e]=atan2(p[v].y-p[u].y,p[v].x-p[u].x); &#125; sort(tmp+1,tmp+cnt+1,cmp); sum[u].push_back(0); for (int i=1;i&lt;=cnt;i++)&#123; rnk[pii(u,vet[tmp[i]])]=i; sum[u].push_back(sum[u].back()+val[tmp[i]]); &#125; &#125; q=read(); int l,r; while (q--)&#123; k=read(); for (int i=1;i&lt;=k;i++) a[i]=read(); ll s=0,ans=k; for (int i=2;i&lt;k;i++) s+=cross(p[a[i]]-p[a[1]],p[a[i+1]]-p[a[1]]); if (s&lt;0) reverse(a+1,a+k+1); //现在必定是逆时针 a[0]=a[k]; a[k+1]=a[1]; for (int i=1;i&lt;=k;i++)&#123; l=rnk[pii(a[i],a[i+1])]; r=rnk[pii(a[i],a[i-1])]; ans+=sum[a[i]][r]-sum[a[i]][l-1]; if (l&gt;r) ans+=sum[a[i]][(int)sum[a[i]].size()-1]; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"省选模拟赛","slug":"省选模拟赛","permalink":"http://hydd.cf/categories/%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"CF1188D","slug":"sol_22","date":"2020-10-13T16:00:00.000Z","updated":"2020-11-13T01:32:46.858Z","comments":true,"path":"2020/10/14/sol_22/","link":"","permalink":"http://hydd.cf/2020/10/14/sol_22/","excerpt":"","text":"题意 给定 $n$ 个数字 $a_1,a_2,\\cdots,a_n$，每次操作可以给某个 $a_i$ 加上 $2$ 的非负整数次幂。 求最少的操作次数使得 $n$ 个数相等。 $1\\leq n\\leq 10^5,0\\leq a_i\\leq 10^{17}$ 题解 不妨先将 $a$ 从小到大排序。 设最后每个数都等于 $a_n+x(x\\geq 0)$。那么总代价为 $\\sum\\limits_{i=1}^n popcount(a_n+x-a_i)$。 现在要找一个 $x$ 使得答案最小。不妨先将 $a_i$ 变为原先的 $a_n-a_i$。 那么现在总代价为 $\\sum\\limits_{i=1}^n popcount(x+a_i)$。 从低到高考虑每一位，那么 $x+a_i$ 的第 $k$ 位是 $0/1$ 由以下三个条件决定： $x$ 的第 $k$ 位是 $0$ 还是 $1$。 $a_i$ 的第 $k$ 位是 $0$ 还是 $1$。 $x+a_i$ 的第 $k-1$ 位有没有向前进位。 暴力的做法是从低到高枚举每一位，用 $2^n$ 的状态记录每个数有没有进位，显然复杂度接受不了。 但是可以发现，由于每个 $a_i$ 加的都是 $x$，所以 $a_i$ 的后 $k-1$ 位越大，越可能向第 $k$ 位进位。 所以，“每个数有没有进位”的状态数只有 $O(n)$ 个，每个进位状态为后 $k-1$ 位从小到大排序后的一个后缀。 记 $f[k][i]$ 表示考虑了后 $k$ 位，后 $k$ 位最大的 $i$ 个数进位的最小代价。 如何转移？考虑当前这一位 $x$ 是 $0$ 还是 $1$。 0： 对答案的贡献：“前一位没进位且第 $k$ 位为 $1$ 的数“的个数 + ”前一位进位且第 $k$ 位为 $0$ 的数“的个数（$x+a_i$ 在这一位为 $1$）。 进位的数量：”前一位进位且第 $k$ 位为 $1$ 的数”的个数。 1： 对答案的贡献：“前一位进位且第 $k$ 位为 $1$ 的数“的个数 + ”前一位没进位且第 $k$ 位为 $0$ 的数“的个数（$x+a_i$ 在这一位为 $1$）。 进位的数量：$n-$”前一位没进位且第 $k$ 位为 $0$ 的数”的个数。 至于如何求这些“个数”，就记个前缀和，存下后 $k$ 位从小到大前 $i$ 个中没进位数的个数和进位的数的个数即可。 可以用类似于基数排序的方法优化每次的排序，时间复杂度 $O(n \\log V)$，其中 $V=\\max{a_i}$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const ll INF=1ll&lt;&lt;60;int n,p[510000],sum[2][510000];int tmp1[510000],tmp2[510000];ll dp[60][510000],c1,c2,c3,p1,p2,m;ll sta,a[510000];/*bool cmp(int x,int y)&#123; return (a[x]&amp;sta)&lt;(a[y]&amp;sta);&#125;*/int main()&#123;// freopen(&quot;equal.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;equal.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); sort(a+1,a+n+1); for (int i=1;i&lt;=n;i++) a[i]=a[n]-a[i]; for (int w=0;w&lt;=58;w++) for (int i=0;i&lt;=n;i++) dp[w][i]=INF; for (int i=1;i&lt;=n;i++) p[i]=i; dp[0][0]=0; for (int w=0;w&lt;58;w++)&#123; sta=(1ll&lt;&lt;w)-1;// sort(p+1,p+n+1,cmp); for (int i=1;i&lt;=n;i++)&#123; sum[0][i]=sum[0][i-1]; sum[1][i]=sum[1][i-1]; sum[(a[p[i]]&gt;&gt;w)&amp;1][i]++; &#125; for (int i=0;i&lt;=n;i++)&#123; int tmp=(sum[0][n]-sum[0][n-i])+sum[1][n-i]; int sta=sum[1][n]-sum[1][n-i]; dp[w+1][sta]=min(dp[w+1][sta],dp[w][i]+tmp); &#125; for (int i=0;i&lt;=n;i++)&#123; int tmp=(sum[1][n]-sum[1][n-i])+sum[0][n-i]; int sta=n-sum[0][n-i]; dp[w+1][sta]=min(dp[w+1][sta],dp[w][i]+tmp); &#125; int cnt1=0,cnt2=0; for (int i=1;i&lt;=n;i++) if ((a[p[i]]&gt;&gt;w)&amp;1) tmp1[++cnt1]=p[i]; else tmp2[++cnt2]=p[i]; int k=0; for (int i=1;i&lt;=cnt2;i++) p[++k]=tmp2[i]; for (int i=1;i&lt;=cnt1;i++) p[++k]=tmp1[i]; &#125; printf(&quot;%lld\\n&quot;,dp[58][0]); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://hydd.cf/categories/Codeforces/"}],"tags":[]},{"title":"20201003 模拟赛题解","slug":"sol_21","date":"2020-10-02T16:00:00.000Z","updated":"2020-10-14T01:27:06.980Z","comments":true,"path":"2020/10/03/sol_21/","link":"","permalink":"http://hydd.cf/2020/10/03/sol_21/","excerpt":"","text":"整肃 可以发现，最后剩下一定是原矩阵的一个子矩形。 直接枚举左上角和右下角的时间复杂度是 $O(Tn^4)$ 的。 由于求的是矩形中 $1$ 的个数 $=k$，而矩形中 $1$ 的个数在上边界 $i$，下边界 $x$，左边界 $j$ 后，关于右边界 $y$ 从左到右是单调递增的，所以可以 $two\\ pointers$，计算个数可以直接二维前缀和。需要步数即为 $\\min(i-1,n-x)+\\min(j-1,m-y)+(i-1)+(j-1)+(n-x)+(m-y)$ 考场上由于一些细节只得了 $50pts$，因为有可能有 $k=0$ 的情况，此时矩形可能为空，即上边界可能大于下边界，左边界可能大于右边界，所以枚举的时候，下边界要从上边界减 $1$ 开始枚举。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int T,n,m,k,ans,s[210][210];char t[210];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) x=x*10+(ch-&#x27;0&#x27;),ch=Getchar(); return x*f;&#125;inline int getsum(int i,int j,int x,int y)&#123; return s[x][y]-s[x][j-1]-s[i-1][y]+s[i-1][j-1];&#125;int main()&#123; freopen(&quot;a.in&quot;,&quot;r&quot;,stdin); freopen(&quot;a.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%s&quot;,t+1); for (int j=1;j&lt;=m;j++) s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+(t[j]-&#x27;0&#x27;); &#125; ans=INF; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; int y=m; for (int x=i-1;x&lt;=n;x++)&#123;//注意为下界为i-1 while (y&gt;=j&amp;&amp;getsum(i,j,x,y)&gt;k) y--;//注意是&gt;=j而不是&gt;j if (getsum(i,j,x,y)==k) ans=min(ans,min(i-1,n-x)+min(j-1,m-y)+(i-1)+(j-1)+(n-x)+(m-y)); &#125; &#125; if (ans==INF) ans=-1; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; 情报将每个点按与初始有情报的点之间的最短路长分层。如果不连通则无解。 将初始有情报的点所在的层数设为 $0$，设层数最大的点的层数为 $d$。 结论1：答案 $\\leqslant d+1$。 具体的方法是每个点收到情报后，都按照先（上）后（下）的顺序传，即在第一天，第 $0$ 层的点传（上），在第二天，第 $0$ 层的点传（下），第 $1$ 层的点传（上），在第三天，第 $1$ 层的点传（下），第 $2$ 层的点传（上），以此类推。那么 $d+1$ 天所有点都收到了情报。 结论2：答案 $\\geqslant d$。 不管怎样，一份情报如果要传到层数最大的点，至少需要 $d$ 天。 我们 $2^n$ 枚举每个点是先传（上）还是先传（下），如果当前没有先传的情报就等着，否则就传先传的情报，然后传后传的情报。 再考虑答案 $=d$ 需要什么条件：对于所有层数 $=d$ 的点，都得有一条从初始有情报的点到当前点的 path，满足长度为 $d$，且路径上所有点都先传（上），还得有一条从初始有情报的点到当前点的 path，满足长度为 $d$，且路径上所有点都先传（下）。 为什么呢？ 如果不存在这样一条路径，那么到当前点的情报不能每天都往下走一层（因为分层图的定义，后传的话相当于停传一天）。那么答案就不可能达到 $d$ 了。 如果都存在，那么每个深度最深的点都可以在 $d$ 天得到情报。将不在任何 path 上的点，把它都当做先传（上）。而深度为 $c&lt;d$ 的点，必定有一条长度 $c$ 的路径，使得路径为（下）（下）…（下）（上）（上）…（上）或为（上）（上）…（上），那么答案不超过 $c+1\\leqslant d$，所以必定合法。 所以看是否有满足条件的状态即可。而怎么判定呢？ 我们记 $trans[sta]$ 表示 $sta$ 中的点，通过一步可以走到哪些点。 将为（上）的点或深度 $=d$ 的点的状态记为 $t1$，为（下）的点或深度 $=d$ 的点的状态记为 $t2$，深度 $=d$ 的状态为 $t$。 将初始有情报的（上）记作 $sta1$，每次令 $sta1=trans[sta1]\\operatorname{And} t1$，最后如果 $sta1\\operatorname{And} t=t$，那么说明所有层数 $=d$ 的点都有（上）的路径，同理做（下）的情况，判断即可。 考场上由于一些细节只得了 $20pts$，原因是 $trans$ 没清空。 时间复杂度 $O(2^nn)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int T,n,sta,d,now,dep[25];int a[25],trans[1100000]; char t[25];queue&lt;int&gt; que;int getdep()&#123; for (int i=0;i&lt;n;i++)&#123; dep[i]=-1; if (sta&amp;(1&lt;&lt;i))&#123; que.push(i); dep[i]=0; &#125; &#125; int res=-1; while (!que.empty())&#123; int u=que.front(); que.pop(); res=dep[u]; for (int i=0;i&lt;n;i++) if ((a[u]&amp;(1&lt;&lt;i))&amp;&amp;dep[i]==-1)&#123; que.push(i); dep[i]=dep[u]+1; &#125; &#125; now=0; for (int i=0;i&lt;n;i++)&#123; if (dep[i]==-1) return -1; if (dep[i]==res) now|=(1&lt;&lt;i); &#125; return res;&#125;bool check(int s,int S)&#123; for (int i=1;i&lt;=d;i++) s=trans[s]&amp;S; return ((s&amp;now)==now);&#125;int main()&#123; freopen(&quot;b.in&quot;,&quot;r&quot;,stdin); freopen(&quot;b.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,t); sta=0; for (int i=0;i&lt;n;i++) if (t[i]==&#x27;Y&#x27;) sta|=(1&lt;&lt;i); for (int i=0;i&lt;n;i++)&#123; scanf(&quot;%s&quot;,t); t[i]=&#x27;Y&#x27;; a[i]=0; for (int j=0;j&lt;n;j++) if (t[j]==&#x27;Y&#x27;) a[i]|=(1&lt;&lt;j); &#125; d=getdep(); if (d==-1)&#123; puts(&quot;-1&quot;); continue;&#125; if (d==0)&#123; puts(&quot;0&quot;); continue;&#125; int upperlim=(1&lt;&lt;n)-1; for (int i=0;i&lt;=upperlim;i++)&#123; trans[i]=0;//!!!!!!!! for (int j=0;j&lt;n;j++) if (i&amp;(1&lt;&lt;j)) trans[i]|=a[j]; &#125; int ans=d+1; for (int i=0;i&lt;=upperlim;i++) if (check(i&amp;sta,i|now)&amp;&amp;check((~i)&amp;sta,(~i)|now))&#123; ans=d; break; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; 研发首先题目的要求相当于对于每一位，所有 $w$ 里只有一个这一位为 $1$。 题目里规定了上界，我们就记每个数有没有压上界。 设 $dp[i][sta]$ 表示，从高到低考虑到第 $i$ 位，$sta$ 中的数压上界的方案数。 然后就转移，一种是这一位没有 $1$，一种是有 $1$ 在不压上界的数上，一种是有 $1$ 在压上界且上界为 $1$ 的数上，分别转移即可。 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int Mod=1e9+9;int n,dp[64][131072]; ll r[32];int cnt,tmp[32];inline int add(int x,int y)&#123; return x+y&gt;=Mod?x+y-Mod:x+y;&#125;int main()&#123; freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); freopen(&quot;c.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for (int i=0;i&lt;n;i++) scanf(&quot;%lld&quot;,&amp;r[i]); int upperlim=(1&lt;&lt;n)-1; dp[60][upperlim]=1; for (int i=59;i&gt;=0;i--) for (int s=0;s&lt;=upperlim;s++)&#123; int now=dp[i+1][s]; if (!now) continue; int cnt=0,news=0,tot=1; for (int k=0;k&lt;n;k++) if (!(s&amp;(1&lt;&lt;k))) tot++; else&#123; if (!(r[k]&amp;(1ll&lt;&lt;i))) news|=(1&lt;&lt;k);//这个数压上界0 else tmp[++cnt]=k; &#125; for (int k=1;k&lt;=cnt;k++) dp[i][news|(1&lt;&lt;tmp[k])]=add(dp[i][news|(1&lt;&lt;tmp[k])],now);//这个数压上界1 dp[i][news]=(dp[i][news]+1ll*tot*now)%Mod; &#125; /*for (int i=0;i&lt;4;i++,puts(&quot;&quot;)) for (int j=0;j&lt;=upperlim;j++) printf(&quot;%d &quot;,dp[i][j]);*/ int ans=0; for (int s=0;s&lt;=upperlim;s++) ans=add(ans,dp[0][s]); printf(&quot;%d\\n&quot;,ans); return 0;&#125; 检阅首先算出从 $(1,1)$ 到每个点所能经过的最多的重要点的个数和每个点到 $(n,m)$ 所能经过的最多的重要点的个数，分别记为 $f[]$ 和 $g[]$。在求出从 $(1,1)$ 到 $(n,m)$ 所能经过的最多的重要点的个数，记作 $mx$。具体做法是先离散化，然后按照坐标排序，之后从前往后/从后往前，做两遍，树状数组维护前/后缀 $max$ 即可。 如果 $f[u]+g[u]=mx$，那么这个点可以在路径上。将这些点的 $tot[f[u]]++$。 在扫一遍 $f[u]+g[u]=mx$ 的点，如果 $tot[f[u]]=1$，那么它是路径上的必经点，否则不是。 最后输出符合条件的点数即可。 考场上由于一些细节只得了 $10pts$，我树状数组的时候把数给加了上去。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int r,c,k,tree[110000];int f[110000],g[110000],tot[110000];int cntx,tmpx[110000],cnty,tmpy[110000];struct node&#123; int x,y; bool operator&lt;(const node &amp;a) const&#123; return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y);&#125;&#125; a[110000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) x=x*10+(ch-&#x27;0&#x27;),ch=Getchar(); return x*f;&#125;void add(int x,int y)&#123; for (;x&lt;=cnty;x+=x&amp;-x) tree[x]=max(tree[x],y);&#125;int query(int x)&#123; int res=0; for (;x;x-=x&amp;-x) res=max(res,tree[x]); return res;&#125;int main()&#123; freopen(&quot;d.in&quot;,&quot;r&quot;,stdin); freopen(&quot;d.out&quot;,&quot;w&quot;,stdout); r=read(); c=read(); for (int n=read(),x,y;n;n--)&#123; x=read(); y=read(); if (x&lt;1||y&lt;1||x&gt;r||y&gt;c) continue; k++; a[k].x=x; a[k].y=y; tmpx[++cntx]=a[k].x; tmpy[++cnty]=a[k].y; &#125; sort(tmpx+1,tmpx+cntx+1); cntx=unique(tmpx+1,tmpx+cntx+1)-tmpx-1; sort(tmpy+1,tmpy+cnty+1); cnty=unique(tmpy+1,tmpy+cnty+1)-tmpy-1; for (int i=1;i&lt;=k;i++)&#123; a[i].x=lower_bound(tmpx+1,tmpx+cntx+1,a[i].x)-tmpx; a[i].y=lower_bound(tmpy+1,tmpy+cnty+1,a[i].y)-tmpy; &#125; sort(a+1,a+k+1); for (int i=1;i&lt;=cnty;i++) tree[i]=0; for (int i=1;i&lt;=k;i++)&#123; f[i]=query(a[i].y)+1; add(a[i].y,f[i]); &#125; for (int i=1;i&lt;=cnty;i++) tree[i]=0; for (int i=k;i&gt;=1;i--)&#123; g[i]=query(cnty-a[i].y+1)+1; add(cnty-a[i].y+1,g[i]); &#125; int mx=0,ans=0; for (int i=1;i&lt;=k;i++) mx=max(mx,f[i]+g[i]); for (int i=1;i&lt;=k;i++) if (f[i]+g[i]==mx) tot[f[i]]++; for (int i=1;i&lt;=k;i++) if (f[i]+g[i]==mx&amp;&amp;tot[f[i]]==1) ans++; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://hydd.cf/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"一些有趣的题","slug":"funny","date":"2020-09-29T16:00:00.000Z","updated":"2020-10-01T04:54:07.104Z","comments":true,"path":"2020/09/30/funny/","link":"","permalink":"http://hydd.cf/2020/09/30/funny/","excerpt":"","text":"概率problem 1一个圆中等概率随机选取 $4$ 个点，那么存在一条直径，使得点全在直径一侧的概率是？ 解答参考：https://www.zhihu.com/question/339701586/answer/789026122 不妨设没有两个点 $A,B$，使得 $O,A,B$ 三点共线。因为这样的概率$\\rightarrow 0$。 定义点 $A$ 为 “最右点” 当且仅当剩下三个点的圆心角都在 $A$ 的圆心角+90°之内。 我们不妨来研究一下“最右点”和答案的关系。 如果四个点处于同一半圆，当且仅当存在“最右点”。 “最右点”要么没有，要么只有一个，所以每个点是“最右点”是互斥的。 第一次、第二次选的点、第三次、第四次选的点，成为“最右点”的概率都是$\\frac 18$，且它们互不影响。 那么，概率为 $4\\times \\frac 18=\\frac 12$。 这个问题可以推广到随机选取 $n$ 个点，概率为 $\\frac n{2^{n-1}}$。 problem 2$S$ 是集合 $1,2,\\cdots,2004$ 的子集，$S$ 中的任意两个数的差不等于 $4$ 或 $7$，问 $S$ 中最多含有多少个元素？ 解答参考：https://wenku.baidu.com/view/e634ddcc69eae009581becc1.html 我们将任意连续 $11$ 个数排成一圈，如右图所示： 显然，由题目条件，相邻的两个数不能同时选，那么最多只能选 $5$ 个数。即每 $11$ 个数至多只能选 $5$ 个数。又因为 $2004=182\\times 11+2$，所以至多能选 $182\\times 5+2=912$ 个数。 其次，令 $S=\\{x|x=11k+t,k\\in \\mathcal{Z},t=1,2,4,7,10,1\\leqslant x\\leqslant 2004\\}$ ，那么 $S$ 满足题目条件，且 $|S|=912$。故答案为 $912$。 有趣的题problem 1解答参考：https://www.bilibili.com/video/BV1UD4y1U7or 有一个 $64$ 个格子的棋盘，每个格子上放着一个正面朝上或反面朝上的棋子。有一个格子下有硬币。 有两个人想得到这枚硬币。开始前，两人均不知道棋盘上每个棋子的正反，只知道是个 $8\\times 8$ 的棋盘，但他们可以商量一个策略。 第一个人先可以看到棋盘上每个棋子的正反，同时裁判会告诉第一个人钥匙在哪个棋子的下面。然后这个人必须要翻转且仅翻转一枚棋子，然后离开。 然后，第二个人再看到棋盘，他只知道现在棋盘上每个棋子的正反，要说出硬币的位置。 问是否有固定策略。 首先考虑只有 $2$ 个格子怎么做。不妨设 $0$ 为正面，$1$ 为反面。 对于第一个人，如果硬币在第一个位置，它要翻成 $0,0$ 或 $0,1$ 中的一种。如果在第二个位置，他要翻成 $1,0$ 或 $1,1$ 中的一种。可以发现，不管初始局面如何，第一个人都可以通过一步达到要求。 为什么呢，，因为每个点都可以通过走一条边到达一个红点和蓝点，点代表的是局面，颜色代表的是硬币的位置。 我们可以轻易得到 $3$ 个格子是无解的。$3$ 个格子相当于一个立方体，每个顶点有三条边，相邻的点分别为红、绿、蓝三种颜色，每个点最多影响 $3$ 个点的相邻点，所以至少有 $3$ 个红顶点，$3$ 个绿顶点，$3$ 个蓝顶点。而总共只有 $8$ 个顶点，所以不合法。发现只有当 $\\frac{2^n}n\\in\\mathcal Z$ 合法，即 $n\\mid 2^n$，也就是说 $n$ 为 $2$ 的次幂。 那么显然 $64$ 个格子是合法的。 那么具体策略是什么呢？ 不妨将每个位置标号为 $0,1,2,\\cdots,63$，设有硬币的格子为 $x$。将反面棋子的位置异或起来，记为 $y$。 将 $x\\oplus y$ 翻转，那么硬币的位置为当前状态下反面棋子的位置的异或和。 为什么呢？因为 $y\\oplus(x\\oplus y)=x$，就做完了。","categories":[],"tags":[]},{"title":"城市","slug":"sol_3","date":"2020-09-23T16:00:00.000Z","updated":"2020-10-01T04:55:53.258Z","comments":true,"path":"2020/09/24/sol_3/","link":"","permalink":"http://hydd.cf/2020/09/24/sol_3/","excerpt":"","text":"设答案乘 $n^i$ 后的值为 $ans_i$。则： \\begin{align*} ans_i&=\\sum_{i\\texttt{次操作后得到的}\\\\\\texttt{可重有序点集}S}\\quad\\quad\\quad\\sum_{\\texttt{连通块}P}[S\\texttt{中的点都在}P\\texttt{中}]\\\\ &=\\sum_{\\texttt{连通块}P}\\sum_{i\\texttt{次操作后得到的}\\\\\\texttt{可重有序点集}S}\\quad[S\\texttt{中的点都在}P\\texttt{中}]\\\\ &=\\sum_{\\texttt{连通块}P}|P|^i \\end{align*}如果直接要求这个 $|P|^i$，要维护所有大小的连通块个数，而连通块大小可以达到 $O(n)$ 级别。 然后这里有个套路，将 $P^i$ 用斯特林数展开。展开公式：$x^k=\\sum \\limits_{i=1}^{x}S(k,i)C(x,i)i! $。（下界也可以从 $0$ 开始） 考虑证明：$x^k$ 可以理解为有 $x$ 个不同的盒子，把 $k$ 个不同的球放入盒子中的方案数，允许空盒。 现在把”允许空盒“转化成”不允许空盒“（所有盒子都至少放入一个球） 首先枚举非空的盒子个数，设为 $i$，那么存在 $k−i$ 个空盒。 选出这 $i$ 个不同的非空盒子有 $C(x,i)$ 种方案，将 $k$ 个不同的球放入 $i$ 个无序非空盒子有 $S(k,i)$ 种方案，现在这些盒子是有序的，再乘上 $i!$ 就是结果。 \\begin{align*} ans_i&=\\sum_{\\texttt{连通块}P}|P|^i\\\\ &=\\sum_{\\texttt{连通块}P}\\sum_{j=0}^iS(i,j)C(|P|,j)j!\\\\ &=\\sum_{j=0}^iS(i,j)j!\\sum_{\\texttt{连通块}P}C(|P|,j)\\\\ \\end{align*}那么现在就要求 $\\sum\\limits_{\\texttt{连通块}P}C(|P|,i),\\forall 0\\leqslant i\\leqslant k$。 考虑树形 $dp$，设 $dp[u][i]$ 表示以 $u$ 为根的所有连通块 $P$ 的 $C(|P|,i)$ 之和。 观察大小为 $a$ 的连通块和大小为 $b$ 的连通块合并后，现在的 $C(|P|,i)$ 的值和原来的值有什么关系，有$C(|a|+|b|,i)=\\sum\\limits_{j=0}^{|a|+|b|} C(|a|,j)C(|b|,|a|+|b|-j)$，可以直接背包合并（卷积），时间复杂度 $O(nk)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/********************************************************************* * Source：zr09 - day2 * Problem：city - T4 * Author：hydd * Date：2020/9/22*********************************************************************/#include&lt;cstdio&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;const int Mod=998244353;int n,k,dp[200005][105],S[105][105],sz[200005],f[200005],tmp[200005];int edgenum,vet[400005],Next[400005],Head[200005];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void dfs(int u,int fa)&#123; dp[u][0]=1; dp[u][1]=1; sz[u]=1; for (int e=Head[u];e;e=Next[e]) if (vet[e]!=fa)&#123; dfs(vet[e],u); for (int i=0;i&lt;=k&amp;&amp;i&lt;=sz[u]+sz[vet[e]];i++) tmp[i]=dp[u][i]; for (int i=0;i&lt;=k&amp;&amp;i&lt;=sz[u];i++) for (int j=0;i+j&lt;=k&amp;&amp;j&lt;=sz[vet[e]];j++) tmp[i+j]=(tmp[i+j]+1ll*dp[u][i]*dp[vet[e]][j])%Mod; for (int i=0;i&lt;=k&amp;&amp;i&lt;=sz[u]+sz[vet[e]];i++) dp[u][i]=tmp[i]; sz[u]+=sz[vet[e]]; &#125; for (int i=0;i&lt;=k&amp;&amp;i&lt;=sz[u];i++) f[i]=(f[i]+dp[u][i])%Mod;&#125;int main()&#123; freopen(&quot;city.in&quot;,&quot;r&quot;,stdin); freopen(&quot;city.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;k); int u,v; for (int i=1;i&lt;n;i++)&#123; u=read(); v=read(); addedge(u,v); addedge(v,u); &#125; S[0][0]=1; for (int i=1;i&lt;=k;i++) for (int j=1;j&lt;=k;j++) S[i][j]=(S[i-1][j-1]+1ll*S[i-1][j]*j)%Mod; dfs(1,0); int invn=qpow(n,Mod-2),tmp=1; for (int i=1;i&lt;=k;i++)&#123; int ans=0,mul=1; tmp=1ll*tmp*invn%Mod; for (int j=1;j&lt;=i;j++)&#123; mul=1ll*mul*j%Mod; ans=(ans+1ll*mul*S[i][j]%Mod*f[j])%Mod; &#125; printf(&quot;%lld\\n&quot;,1ll*ans*tmp%Mod); &#125; return 0;&#125;","categories":[{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://hydd.cf/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"树形dp","slug":"树形dp","permalink":"http://hydd.cf/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"概率/期望","slug":"概率-期望","permalink":"http://hydd.cf/tags/%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"},{"name":"斯特林数","slug":"斯特林数","permalink":"http://hydd.cf/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"}]},{"title":"ckw的树","slug":"sol_4","date":"2020-09-23T16:00:00.000Z","updated":"2020-10-13T01:36:06.601Z","comments":true,"path":"2020/09/24/sol_4/","link":"","permalink":"http://hydd.cf/2020/09/24/sol_4/","excerpt":"","text":"设 $f[u]$ 表示从 $u$ 开始游走的期望时间。不妨设 $f[u]=a_uf[fa(fa(u))]+b_uf[fa(u)]+c_usum[fa(u)]+d_u$。 不妨设 $fa(1)=0,fa(0)=0$，$f[0]=0$。设 $t_u$ 为与 $u$ 距离不超过 $2$ 的点的个数。 若它的子树中每个点的 $f[v]$ 都可以用 $a_v,b_v,c_v,d_v$ 表示出来，考虑怎么将 $f[u]$ 用 $a_u,b_u,c_u,d_u$ 表示出来。 根据题意，每次可以从 $u$ 到距离不超过 $2$ 的任意一个节点，记 $sum[u]=\\sum\\limits_{v\\in son(u)}f[v]$，那么满足： $t_uf[u]=f[fa(fa(u))]+f[fa(u)]+sum[fa(u)]+sum[u]+\\sum\\limits_{v\\in son(u)}sum[v]$（这个点不是标记点） $f[u]=0$（这个点是标记点） 若这个点是标记点，则 $a_u=0,b_u=0,c_u=0,d_u=0$，以下考虑不是标记点的情况。 我们发现这个 $sum[u]$ 和 $sum[v]$ 比较恶心，我们考虑把它拆开： \\begin{align*} sum[u] &=\\sum_{v\\in son(u)} f[v]\\\\ &=\\sum_{v\\in son(u)}(a_vf[fa(fa(v))]+b_vf[fa(v)]+c_vsum[fa(v)]+d_v)\\\\ &=\\sum_{v\\in son(u)}(a_vf[fa(u)]+b_vf[u]+c_vsum[u]+d_v)\\\\ &=\\sum_{v\\in son(u)}a_vf[fa(u)]+\\sum_{v\\in son(u)}b_vf[u]+\\sum_{v\\in son(u)}c_vsum[u]+\\sum_{v\\in son(u)}d_v \\end{align*}记 $sum_a=\\sum\\limits_{v\\in son(u)}a_v,sum_b=\\sum\\limits_{v\\in son(u)}b_v,sum_c=\\sum\\limits_{v\\in son(u)}c_v,sum_d=\\sum\\limits_{v\\in son(u)}d_v$。 则 $sum[u]=sum_a\\cdot f[fa(u)]+sum_b\\cdot f[u]+sum_c\\cdot sum[u]+sum_d$。 移项： $(1-sum_c)\\cdot sum[u]=sum_a\\cdot f[fa(u)]+sum_b\\cdot f[u]+sum_d$。 两边同除 $1-sum_c$ 可得：$sum[u]=\\dfrac{sum_a\\cdot f[fa(u)]+sum_b\\cdot f[u]+sum_d}{1-sum_c}$ 令 $sa[u]=\\dfrac{sum_a}{1-sum_c},sb[u]=\\dfrac{sum_b}{1-sum_c},sd[u]=\\dfrac{sum_d}{1-sum_c}$。 那么：$sum[u]=sa[u]f[fa(u)]+sb[u]f[u]+sd[u]$。由于 $a_v,b_v,c_v,d_v$ 已知，那么 $sa[u],sb[u],sd[u]$ 已知，即可求出 $sum[u],sum[v]$ 的表达式。 先将 $sum[v]$ 拆开，代入 $f[u]$ 所满足的式子：$t_uf[u]=f[fa(fa(u))]+f[fa(u)]+sum[fa(u)]+sum[u]+\\sum\\limits_{v\\in son(u)}(sa[v]f[u]+sb[v]f[v]+sd[v])$ 将和式拆分：$t_uf[u]=f[fa(fa(u))]+f[fa(u)]+sum[fa(u)]+sum[u]+f[u]\\sum\\limits_{v\\in son(u)}sa[v]+\\sum\\limits_{v\\in son(u)}sb[v]f[v]+\\sum\\limits_{v\\in son(u)} sd[v]$ 再将 $f[v]$ 拆开：$t_uf[u]=f[fa(fa(u))]+f[fa(u)]+sum[fa(u)]+sum[u]+f[u]\\sum\\limits_{v\\in son(u)}sa[v]+\\sum\\limits_{v\\in son(u)} sd[v]+\\sum\\limits_{v\\in son(u)} sb[v]\\cdot (a_vf[fa(u)]+b_vf[u]+c_vsum[u]+d_v)$ 整理：$t_uf[u]=f[fa(fa(u))]+f[fa(u)]+sum[fa(u)]+sum[u]+f[u]\\sum\\limits_{v\\in son(u)}sa[v]+\\sum\\limits_{v\\in son(u)} sd[v]+\\sum\\limits_{v\\in son(u)} sb[v]a_vf[fa(u)]+\\sum\\limits_{v\\in son(u)}sb[v]b_vf[u]+\\sum\\limits_{v\\in son(u)}sb[v]c_vsum[u]+\\sum\\limits_{v\\in son(u)}sb[v]d_v$ 移项：$f[fa(fa(u))]+(1+\\sum\\limits_{v\\in son(u)} sb[v]a_v)f[fa(u)]+sum[fa(u)]+(\\sum\\limits_{v\\in son(u)}sb[v]d_v+\\sum\\limits_{v\\in son(u)} sd[v])+(\\sum\\limits_{v\\in son(u)}sa[v]+\\sum\\limits_{v\\in son(u)}sb[v]b_v-t_u)f[u]+(1+\\sum\\limits_{v\\in son(u)}sb[v]c_v)sum[u]=0$ 再将 $sum[u]$ 拆开： $f[fa(fa(u))]+(1+\\sum\\limits_{v\\in son(u)} sb[v]a_v)f[fa(u)]+sum[fa(u)]+(\\sum\\limits_{v\\in son(u)}sb[v]d_v+\\sum\\limits_{v\\in son(u)} sd[v])+(\\sum\\limits_{v\\in son(u)}sa[v]+\\sum\\limits_{v\\in son(u)}sb[v]b_v-t_u)f[u]+(1+\\sum\\limits_{v\\in son(u)}sb[v]c_v)(sa[u]f[fa(u)]+sb[u]f[u]+sd[u])=0$ 记 $su=(1+\\sum\\limits_{v\\in son(u)}sb[v]c_v)$，可得： $f[fa(fa(u))]+(1+(\\sum\\limits_{v\\in son(u)} sb[v]a_v)+su\\cdot sa[u])f[fa(u)]+sum[fa(u)]+((\\sum\\limits_{v\\in son(u)}sa[v])+(\\sum\\limits_{v\\in son(u)}sb[v]b_v)-t_u+su\\cdot sb[u])f[u]+((\\sum\\limits_{v\\in son(u)}sb[v]d_v)+(\\sum\\limits_{v\\in son(u)} sd[v])+su\\cdot sd[u])=0$ 令 $c_1=t_u-(\\sum\\limits_{v\\in son(u)}sa[v])-(\\sum\\limits_{v\\in son(u)}sb[v]b_v)-su\\cdot sb[u],c_2=1+(\\sum\\limits_{v\\in son(u)} sb[v]a_v)+su\\cdot sa[u],c_3=(\\sum\\limits_{v\\in son(u)}sb[v]d_v)+(\\sum\\limits_{v\\in son(u)} sd[v])+su\\cdot sd[u]$ 整理：$c_1f[u]=f[fa(fa(u))]+c_2f[fa(u)]+sum[fa(u)]+c_3$ 两边同除 $c_1$：$f[u]=\\frac{1}{c_1}f[fa(fa(u))]+\\frac{c_2}{c_1}f[fa(u)]+\\frac{1}{c_1}sum[fa(u)]+\\frac{c_3}{c_1}$。 可得：$a_u=\\frac{1}{c_1},b_u=\\frac{c_2}{c_1},c_u=\\frac{1}{c_1},d_u=\\frac{c_3}{c_1}$。 至此可以求出所有点 $f$ 都可以用 $a,b,c,d$ 表达出来，同时也把所有点的 $sa,sb,sc,sd$ 也都求出来了。 $f[u]=a_uf[fa(fa(u))]+b_uf[fa(u)]+c_usum[fa(u)]+d_u$，那么可以将 $sum[fa(u)]$ 拆开，可得： $f[u]=a_uf[fa(fa(u))]+b_uf[fa(u)]+c_u(sa[fa(u)]f[fa(fa(u))]+sb[fa(u)]f[fa(u)]+sd[fa(u)])+d_u$ 整理：$f[u]=(a_u+c_usa[fa(u)])f[fa(fa(u))]+(b_u+c_usb[fa(u)])f[fa(u)]+(c_u\\cdot sd[fa(u)]+d_u)$。 令 $f[u]=a’_uf[fa(fa(u))]+b’_uf[fa(u)]+d’_u$ 则 $a’_u=a_u+c_usa[fa(u)],b’_u=b_u+c_usb[fa(u)],d’_u=c_u\\cdot sd[fa(u)]+d_u$。 注意，这个地方 $f[1]$ 不能这样拆开，因为 $fa(1)=0,sa[0],sb[0],sd[0]$ 没有处理，而 $sum[0]=f[1]$，解一下： $f[1]=c_1f[1]+d_1$，而 $(1-c_1)f[1]=d_1$，则 $f[1]=\\frac{d_1}{1-c_1}$。所有点的 $f$ 值可以用一遍从上到下的 $dfs$ 求得。 这样这道题就做完了，不过注意若一个点是标记点也要处理 $sa,sb,sc,sd$，它们会在转移它的父亲的时候用到。 时间复杂度 $O(n)$，空间复杂度 $O(n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/********************************************************************* * Source：zr09 - day3 * Problem：tree * Author：hydd * Date：2020/9/24*********************************************************************/#include&lt;cstdio&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;const int Mod=998244353;typedef long long ll;int n,m,tot[110000],f[110000]; bool vis[110000];int sa[110000],sb[110000],sd[110000];int a[110000],b[110000],c[110000],d[110000];int edgenum,vet[210000],Next[210000],Head[110000];inline void add(int &amp;x,int y)&#123; x+=y; if (x&gt;=Mod) x-=Mod;&#125;void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ll qpow(ll x,int a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline int getinv(int x)&#123; return qpow(x,Mod-2);&#125;void dfs(int u,int fa)&#123; tot[u]=1; for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; tot[u]++; dfs(vet[e],u); &#125;&#125;void dp(int u,int fa,int fa_2)&#123; int cnt=(fa?tot[fa]:1)+(fa_2!=0); for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; cnt+=tot[vet[e]]; dp(vet[e],u,fa); &#125; int fu=Mod-cnt,ffa=1,ffafa=1,sfa=1,fc=cnt,su=1; for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; add(fu,sa[vet[e]]); //sb[vet[e]]*f[vet[e]]; add(ffa,1ll*a[vet[e]]*sb[vet[e]]%Mod); add(fu,1ll*b[vet[e]]*sb[vet[e]]%Mod); add(su,1ll*c[vet[e]]*sb[vet[e]]%Mod); add(fc,1ll*d[vet[e]]*sb[vet[e]]%Mod); add(fc,sd[vet[e]]); &#125; int suma=0,sumb=0,sumc=0,sumd=0; for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; add(suma,a[vet[e]]); add(sumb,b[vet[e]]); add(sumc,c[vet[e]]); add(sumd,d[vet[e]]); &#125; ll inv=getinv(Mod+1-sumc); sa[u]=inv*suma%Mod; sb[u]=inv*sumb%Mod; sd[u]=inv*sumd%Mod; add(ffa,1ll*su*sa[u]%Mod); add(fu,1ll*su*sb[u]%Mod); add(fc,1ll*su*sd[u]%Mod); fu=(Mod-fu)%Mod; inv=getinv(fu); fu=inv*fu%Mod; ffa=inv*ffa%Mod; ffafa=inv*ffafa%Mod; sfa=inv*sfa%Mod; fc=inv*fc%Mod; a[u]=ffafa; b[u]=ffa; c[u]=sfa; d[u]=fc; if (vis[u]) a[u]=0,b[u]=0,c[u]=0,d[u]=0;&#125;void dfs2(int u,int fa)&#123; for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; add(a[vet[e]],1ll*c[vet[e]]*sa[u]%Mod); add(b[vet[e]],1ll*c[vet[e]]*sb[u]%Mod); add(d[vet[e]],1ll*c[vet[e]]*sd[u]%Mod); dfs2(vet[e],u); &#125;&#125;void getans(int u,int fa)&#123; for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; f[vet[e]]=(1ll*a[vet[e]]*f[fa]+1ll*b[vet[e]]*f[u]+d[vet[e]])%Mod; getans(vet[e],u); &#125;&#125;int main()&#123; freopen(&quot;tree.in&quot;,&quot;r&quot;,stdin); freopen(&quot;tree.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); int u,v; for (int i=1;i&lt;n;i++)&#123; u=read(); v=read(); addedge(u,v); addedge(v,u); &#125; int x; for (int i=1;i&lt;=m;i++)&#123; x=read(); vis[x]=true; &#125; dfs(1,0); dp(1,0,0); dfs2(1,0); f[1]=1ll*getinv(Mod+1-c[1])*d[1]%Mod; getans(1,0); for (int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,f[i]); return 0;&#125;","categories":[{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://hydd.cf/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"树形dp","slug":"树形dp","permalink":"http://hydd.cf/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"概率/期望","slug":"概率-期望","permalink":"http://hydd.cf/tags/%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"}]},{"title":"20200924 模拟赛题解","slug":"sol_5","date":"2020-09-23T16:00:00.000Z","updated":"2020-10-01T04:56:41.888Z","comments":true,"path":"2020/09/24/sol_5/","link":"","permalink":"http://hydd.cf/2020/09/24/sol_5/","excerpt":"","text":"number \\begin{align*} ans&=\\sum_{i=1}^n\\sum_{j=i}^n\\sum_{p\\in \\mathcal{P}} [p\\mid\\prod_{k=i}^ja_k]\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{j=i}^n [p\\mid\\prod_{k=i}^ja_k]\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{j=i}^n [(p\\mid a_i) \\lor (p\\mid a_{i+1}) \\lor (p\\mid a_{i+2})\\lor\\cdots\\lor(p\\mid a_j)]\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{j=i}^n \\sum_{k=i}^j[(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})\\land (p\\mid a_{k})]\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{k=i}^n \\sum_{j=k}^n[(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})\\land (p\\mid a_{k})]\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{k=i}^n [(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})\\land (p\\mid a_{k})]\\sum_{j=k}^n1\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{k=i}^n [(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})\\land (p\\mid a_{k})]\\cdot (n-k+1)\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{k=1}^n(\\sum_{i=1}^k [(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})\\land (p\\mid a_{k})])\\cdot (n-k+1)\\\\ &=\\sum_{k=1}^n\\sum_{p\\in \\mathcal{P},p\\mid a_k}(n-k+1)(\\sum_{i=1}^k [(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})]) \\end{align*}注意到，求出最大的 $j&lt;k$ 满足 $p\\mid a_j$，那么上式 $\\sum\\limits_{i=1}^k [(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})]=k-j$ 从左往右扫，对于每个 $p$ 记录满足条件的 $j$，就做完了。时间复杂度 $O(n \\ln n)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/********************************************************************* * Source：zr09 - day4 * Problem：number * Author：hydd * Date：2020/9/24*********************************************************************/#include&lt;cstdio&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;int n,lst[1100000],num[1100000];int cnt,prime[1100000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void init(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!lst[i])&#123; lst[i]=i; prime[++cnt]=i; &#125; for (int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123; lst[i*prime[j]]=prime[j]; if (i%prime[j]==0) break; &#125; &#125;&#125;int main()&#123; freopen(&quot;number.in&quot;,&quot;r&quot;,stdin); freopen(&quot;number.out&quot;,&quot;w&quot;,stdout); init(1000000); n=read(); for (int i=2;i&lt;=1000000;i++) num[i]=0; int x,y; ll ans=0; for (int i=1;i&lt;=n;i++)&#123; x=read(); y=-1; while (x!=1)&#123; if (y!=lst[x])&#123; ans+=1ll*(i-num[lst[x]])*(n-i+1); num[lst[x]]=i; &#125; y=lst[x]; x/=lst[x]; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; seq这个数列是个一阶递推数列。 又因为每个值都在 $[0,m)$ 内（除了 $x_0$ 有可能为 $m$）。 所以我们可以通过倍增轻易求出 $x_0=k,\\forall k\\in[0,m]$ 时，$x_i,\\forall i\\in[0,t]$ 的值。 然后，我们考虑每个 $k$，对于所有的 $t_1+t_2=k$，可能的 $|t_1-t_2|$ 的值。 若 $k\\leqslant m$ 若 $k$ 是偶数，可能为 $k,k-2,\\cdots ,2,0,2,\\cdots k-2,k$。即 $0,2,2,4,4,6,6,\\cdots,k,k$。 若 $k$ 是奇数，可能为 $k,k-2,\\cdots ,3,1,1,3,\\cdots k-2,k$。即 $1,1,3,3,5,5,\\cdots,k,k$。 若 $m+1\\leqslant k\\leqslant 2m$ 若 $k$ 是偶数，可能为 $2m-k,2m-k-2,\\cdots ,2,0,2,\\cdots 2m-k-2,2m-k$。即 $0,2,2,4,4,6,6,\\cdots,2m-k,2m-k$。 若 $k$ 是奇数，可能为 $2m-k,2m-k-2,\\cdots ,3,1,1,3,\\cdots 2m-k-2,2m-k$。即 $1,1,3,3,5,5,\\cdots,2m-k,2m-k$。 我们可以倍增记录 $x_0=a,\\forall 0\\leqslant l\\leqslant m,x_0+x_2+x_4+\\cdots,x_{2l}$。 那么偶数的答案可以轻松的算出，奇数的答案的话，先将 $x’_0$ 变为 $x_1$，再类似的做即可。 时间复杂度 $O(n\\log n)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/********************************************************************* * Source：zr09 - day4 * Problem：seq * Author：hydd * Date：2020/9/24*********************************************************************/#include&lt;cstdio&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;const int Mod=1e9+7;int t,a,c,m,k,f[1100000],fa[1100000][21],sum[1100000][21];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;int getsum(int x,int d)&#123; d++; int res=0; for (int i=20;i&gt;=0;i--) if (d&amp;(1&lt;&lt;i))&#123; res=(res+sum[x][i])%Mod; x=fa[x][i]; &#125; return res;&#125;int main()&#123; freopen(&quot;seq.in&quot;,&quot;r&quot;,stdin); freopen(&quot;seq.out&quot;,&quot;w&quot;,stdout); t=read(); a=read(); c=read(); m=read(); k=read(); for (int i=0;i&lt;=m;i++) f[i]=(1ll*a*i+c)%m; for (int i=0;i&lt;=m;i++)&#123; fa[i][0]=f[f[i]]; sum[i][0]=i%k; &#125; for (int j=1;j&lt;=20;j++) for (int i=0;i&lt;=m;i++)&#123; fa[i][j]=fa[fa[i][j-1]][j-1]; sum[i][j]=((sum[i][j-1]+sum[fa[i][j-1]][j-1])%Mod)%Mod; &#125; int ans=0; for (int i=0;i&lt;=t;i++) if (i&amp;1) ans=(ans+2ll*getsum(f[i],(i-1)/2))%Mod; else ans=(ans+2ll*getsum(i,i/2)-i%k)%Mod; for (int i=t+1;i&lt;=t+t;i++) if (i&amp;1) ans=(ans+2ll*getsum(f[i],(2*t-i-1)/2))%Mod; else ans=(ans+2ll*getsum(i,(2*t-i)/2)-i%k)%Mod; printf(&quot;%d\\n&quot;,ans); return 0;&#125; kth将相同的数也钦定一个大小关系，不妨设相同的情况下越靠后的数越大。 将数从大到小排序，求出当前数左边最靠右的 $k$ 个比它大的数和当前数右边靠左的 $k$ 个比它大的数。 这个可以用个链表串起来（直接 $set$ 暴力查是 $k\\log n$ 的，链表的话少个 $\\log$）然后求。 之后就随便求就好了，枚举左边有多少个比它大的即可。 时间复杂度 $O(n\\log n+nk)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/********************************************************************* * Source：zr09 - day4 * Problem：kth * Author：hydd * Date：2020/9/24*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;utility&gt;#include&lt;functional&gt;#include&lt;set&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;const int Mod=1e9+7;typedef pair&lt;int,int&gt; pii;int n,k,a[210000];int num1[210000],num2[210000];int nxt[210000],lst[210000];pii tmp[210000]; set&lt;int&gt; s;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;int main()&#123; freopen(&quot;kth.in&quot;,&quot;r&quot;,stdin); freopen(&quot;kth.out&quot;,&quot;w&quot;,stdout); n=read(); k=read(); for (int i=0;i&lt;=n+1;i++) nxt[i]=i,lst[i]=i; for (int i=1;i&lt;=n;i++) tmp[i].first=read(),tmp[i].second=i; sort(tmp+1,tmp+n+1,greater&lt;pii&gt;()); s.insert(0); s.insert(n+1); int x,l,r,ans=0; for (int i=1;i&lt;=n;i++)&#123; x=tmp[i].second; l=*--s.lower_bound(x); r=*s.upper_bound(x); s.insert(x); nxt[l]=x; lst[x]=l; lst[r]=x; nxt[x]=r; for (int i=1;i&lt;=k+1;i++) num1[i]=0,num2[i]=n+1; int cnt1=0,cnt2=0,now; now=x; while (cnt1&lt;=k&amp;&amp;now)&#123; num1[++cnt1]=now; now=lst[now];&#125; now=nxt[x]; while (cnt2&lt;=k&amp;&amp;now)&#123; num2[++cnt2]=now; now=nxt[now];&#125; for (int l=1;l&lt;=k;l++)&#123; int r=k-l+1; ans=(ans+1ll*(num1[l]-num1[l+1])*(num2[r]-x)%Mod*tmp[i].first)%Mod; &#125;// printf(&quot;%d\\n&quot;,ans); &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;/*6 296 29 71 28 91 64*/ subseq一般子序列的 $dp$，就是 $dp[i][j]=\\begin{cases} 1+\\sum\\limits_k dp[i-1][k] &amp; j=s_i \\\\ dp[i-1][j] &amp; j\\neq s_i\\end{cases}$ 现在要求 $\\bmod 2$ 的值，那就是 $dp[i][j]=\\begin{cases} 1\\oplus\\bigoplus\\limits_k dp[i-1][k] &amp; j=s_i \\\\ dp[i-1][j] &amp; j\\neq s_i\\end{cases}$ 可以发现一些性质： 若原来 $dp[i-1]$ 有奇数个 $1$，现在是一个 $dp[i-1][c]=0$ 的字符 $c$，那么 $dp[i-1][c]$ 没有任何变化。 若原来 $dp[i-1]$ 有奇数个 $1$，现在是一个 $dp[i-1][c]=1$ 的字符 $c$，那么 $dp[i-1][c]$ 变为了 $0$。 若原来 $dp[i-1]$ 有偶数个 $1$，现在是一个 $dp[i-1][c]=0$ 的字符 $c$，那么 $dp[i-1][c]$ 变为了 $1$。 若原来 $dp[i-1]$ 有偶数个 $1$，现在是一个 $dp[i-1][c]=1$ 的字符 $c$，那么 $dp[i-1][c]$ 没有任何变化。 那么，我们会发现，$dp[i-1]$ 中只有一个字符 $c$ 满足 $dp[i][c]=1$，其余位置都为 $0$。不妨记录这个字符。 考虑加入一个字符 $s_i$： 若 $c=\\emptyset$，由性质 3.，$c’=s_i$。 若 $c=s_i$，由性质 2.，$c’=\\emptyset$。 否则，由性质 1.，$c’=c$。 由于我们要合并两个字符串，所有需要知道所有 $c$ 作为初始时，每个字符串最后会变成哪个 $c’$。 然后直接设 $dp[i][j]$ 表示已经选了状态为 $i$ 的字符串，现在的 $c=j$ 的方案数，直接转移即可。 时间复杂度 $O(2^nn|\\Sigma|)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/********************************************************************* * Source：zr09 - day4 * Problem：subseq * Author：hydd * Date：2020/9/24*********************************************************************/#include&lt;cstdio&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;int n,trans[31][31];ll f[1100000][31];int len,s[110000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void readst()&#123; len=0; char ch=Getchar(); while (ch&lt;&#x27;a&#x27;||ch&gt;&#x27;z&#x27;) ch=Getchar(); while (ch&lt;=&#x27;z&#x27;&amp;&amp;ch&gt;=&#x27;a&#x27;) s[++len]=ch-&#x27;a&#x27;,ch=Getchar();&#125;int main()&#123; freopen(&quot;subseq.in&quot;,&quot;r&quot;,stdin); freopen(&quot;subseq.out&quot;,&quot;w&quot;,stdout); n=read(); for (int i=0;i&lt;n;i++)&#123; readst(); for (int c=0;c&lt;=26;c++)&#123; int now=c; for (int j=1;j&lt;=len;j++) if (now==26) now=s[j]; else if (now==s[j]) now=26; trans[i][c]=now; &#125; &#125; int upperlim=(1&lt;&lt;n)-1; f[0][26]=1; for (int i=0;i&lt;upperlim;i++) for (int j=0;j&lt;n;j++) if (!(i&amp;(1&lt;&lt;j))) for (int c=0;c&lt;=26;c++) f[i|(1&lt;&lt;j)][trans[j][c]]+=f[i][c]; ll ans=0; for (int c=0;c&lt;=25;c++) ans+=f[upperlim][c]; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;","categories":[{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://hydd.cf/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"CF555E","slug":"sol_6","date":"2020-09-23T16:00:00.000Z","updated":"2020-11-13T01:33:18.171Z","comments":true,"path":"2020/09/24/sol_6/","link":"","permalink":"http://hydd.cf/2020/09/24/sol_6/","excerpt":"","text":"题意给定一个 $n$ 个点 $m$ 条边的无向图。有 $q$ 个人，第 $i$ 个人要从 $s_i$ 到 $t_i$。 现在你要给无向图的每条边定向。问是否存在一种定向方法使得所有人都能够到达目的地。 $n,m,q\\leqslant 2\\times 10^5,u_i\\neq v_i,s_i\\neq t_i$ subtask1（1-8，20pts）：$n\\leqslant 8,m\\leqslant 15,q\\leqslant 8$。 subtask2（11-13，10pts）：保证原图是一个菊花图，$m=n-1$。（即有且仅有一个点 $u$，它向其它所有点都有一条边） subtask3（14-15，10pts）：保证图是一条链，$m=n-1$。 subtask4（16-20，30pts）：保证图是一棵树，$m=n-1$。（依赖subtask 2,3） subtask5（20-30,9,10，30pts）：无特殊限制。（依赖subtask 1,2,3,4） 题解我的做法（186ms）可以发现，对于一个边双来说，一定存在一种定向方法，使得边数内两两点之间均可到达。 所以一个边双相当于一个点。那么我们缩点，把图变成一颗树。这样，$s$ 到 $t$ 只能走树上简单路径。 我们把 $s\\rightarrow LCA$ 的路径打向上的标记，把 $LCA\\rightarrow t$ 的路径打向下的标记。$LCA$ 可以通过倍增预处理。 只要没有一条边同时有两种标记，就是合法的。打标记使用树上差分实现。 时间复杂度：$ O(n+m+q\\log n)$。 有一些细节： 原图不保证连通，所以在缩点，预处理倍增，判断答案的时候要在每个连通块都做一次。 原图可能有重边，所以 $\\rm tarjan$ 的时候要记上一条边的编号而不是父亲节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/********************************************************************* * Source：互测 * Problem：CF555E * Author：hydd * Date：2020/8/30 - 2020/8/31 * Encoding：Simplified Chinese (GB2312)*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;const int MAXN=210000;const int MAXM=410000;int n,m,q,u[MAXN],v[MAXN];int top,st[MAXN],fr[MAXN],dep[MAXN];int cnt2,fa[MAXN][19]; bool vis[MAXN];int cnt,num[MAXN],up[MAXN],dw[MAXN];int dtime,dfn[MAXN],low[MAXN];vector&lt;int&gt; vec[MAXN];int edgenum=1,vet[MAXM],Next[MAXM],Head[MAXN];void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void tarjan(int u,int le)&#123;//2. dfn[u]=low[u]=++dtime; st[++top]=u; int v; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (e==(le^1)) continue; if (!dfn[v])&#123; tarjan(v,e); low[u]=min(low[u],low[v]); &#125; else low[u]=min(low[u],dfn[v]); &#125; if (dfn[u]==low[u])&#123; cnt++; while (st[top]!=u)&#123; num[st[top]]=cnt; top--;&#125; num[st[top]]=cnt; top--; &#125;&#125;void dfs(int u,int f)&#123; fr[u]=cnt2; dep[u]=dep[f]+1; fa[u][0]=f; for (int i=1;(1&lt;&lt;i)&lt;dep[u];i++) fa[u][i]=fa[fa[u][i-1]][i-1]; for (int v:vec[u])&#123; if (v==f) continue; dfs(v,u); &#125;&#125;void dfs2(int u,int f)&#123; vis[u]=true; for (int v:vec[u])&#123; if (v==f) continue; dfs2(v,u); up[u]+=up[v]; dw[u]+=dw[v]; &#125;&#125;int LCA(int x,int y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); int d=dep[x]-dep[y]; for (int i=0;i&lt;=18;i++) if (d&amp;(1&lt;&lt;i)) x=fa[x][i]; if (x==y) return x; for (int i=18;i&gt;=0;i--) if (fa[x][i]!=fa[y][i])&#123; x=fa[x][i]; y=fa[y][i]; &#125; return fa[x][0];&#125;bool check()&#123; int s,t; while (q--)&#123; s=read(); t=read(); s=num[s]; t=num[t]; if (fr[s]!=fr[t]) return false; int w=LCA(s,t); up[s]++; up[w]--; dw[t]++; dw[w]--; &#125; for (int i=1;i&lt;=n;i++) if (!vis[i]) dfs2(i,0);//1. for (int i=1;i&lt;=cnt;i++) if (up[i]&amp;&amp;dw[i]) return false; return true;&#125;int main()&#123; n=read(); m=read(); q=read(); edgenum=1; for (int i=1;i&lt;=m;i++)&#123; u[i]=read(); v[i]=read(); addedge(u[i],v[i]); addedge(v[i],u[i]); &#125; for (int i=1;i&lt;=n;i++) if (!dfn[i]) tarjan(i,0);//1. int x,y; for (int i=1;i&lt;=m;i++)&#123; x=num[u[i]]; y=num[v[i]]; if (x==y) continue; vec[x].push_back(y); vec[y].push_back(x); &#125; for (int i=1;i&lt;=cnt;i++) if (!fr[i])&#123; cnt2++; dfs(i,0);&#125;//1. if (check()) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; CodeForces 最快做法（124ms）思路与前述相同。 使用了 $\\rm tarjan$ 求 $LCA$，时间复杂度 $O(n+m+q)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define N 200002#define E 400003#define Spush(x) (in[sk[++sp]=x]=true)#define Spop() (in[sk[sp--]]=false)#define Stop() (sk[sp])#define Dp (puts(&quot;&quot;))#define Dw printf#define Df(i,s,t) for(int i=s;i&lt;=t;i++)struct Edge&#123;int y,t;&#125;e[E];struct Query&#123;int y,t,ans;&#125;Q[E];bool in[N],used[N],done[N],vis[N],IsPos[N];char ch;int n,m,q,x[N],y[N],qx,qy,h[N],ep=1,sk[N],sp,dfn[N],low[N],tm,color[N],cp,hq[N],qp=1,f[N],djw,djf,djt,dep[N],fa[N],pos[N],neg[N];inline void read(int &amp;x)&#123;x=0;do&#123;ch=getchar();&#125;while(ch&lt;&#x27;0&#x27;||&#x27;9&#x27;&lt;ch);do&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;while(&#x27;0&#x27;&lt;=ch&amp;&amp;ch&lt;=&#x27;9&#x27;);&#125;inline void AddEdge(const int &amp;x,const int &amp;y)&#123;e[++ep].y=y;e[ep].t=h[x];h[x]=ep;&#125;inline void AddQuery(const int &amp;x,const int &amp;y)&#123;Q[++qp].y=y;Q[qp].t=hq[x];hq[x]=qp;&#125;inline int F(const int &amp;x)&#123; djw=x;while(f[djw]!=djw)djw=f[djw];djf=djw; djw=x;while(djw!=djf)&#123;djt=f[djw];f[djw]=djf;djw=djt;&#125; return djf;&#125;void TarjanSCC(const int &amp;x)&#123; dfn[x]=low[x]=++tm; Spush(x); for(int i=h[x];i;i=e[i].t) if(!used[i&gt;&gt;1]) &#123; if(!dfn[e[i].y]) &#123; used[i&gt;&gt;1]=true; TarjanSCC(e[i].y); low[x]=min(low[x],low[e[i].y]); used[i&gt;&gt;1]=false; &#125; else if(in[e[i].y])low[x]=min(low[x],dfn[e[i].y]); &#125; if(dfn[x]==low[x]) &#123; color[x]=++cp; while(Stop()!=x) &#123; color[Stop()]=cp; Spop(); &#125; Spop(); &#125;&#125;void TarjanLCA(const int &amp;x)&#123; done[x]=true; for(int i=h[x];i;i=e[i].t) if(!done[e[i].y])TarjanLCA(e[i].y),f[e[i].y]=x; for(int i=hq[x];i;i=Q[i].t) if(done[Q[i].y])Q[i|1].ans=F(Q[i].y);&#125;void dfs(const int &amp;x)&#123; for(int i=h[x];i;i=e[i].t) if(e[i].y!=fa[x]) &#123; fa[e[i].y]=x; dep[e[i].y]=dep[x]+1; dfs(e[i].y); &#125;&#125;void GetPosUp(const int &amp;x)&#123; vis[x]=true; for(int i=h[x];i;i=e[i].t) if(!vis[e[i].y]) &#123; GetPosUp(e[i].y); pos[x]=max(pos[x],pos[e[i].y]-1); &#125; if(pos[x])IsPos[x]=true;&#125;void GetNegUp(const int &amp;x)&#123; vis[x]=true; for(int i=h[x];i;i=e[i].t) if(!vis[e[i].y]) &#123; GetNegUp(e[i].y); neg[x]=max(neg[x],neg[e[i].y]-1); &#125; if(neg[x])if(IsPos[x])&#123;puts(&quot;No&quot;);exit(0);&#125;&#125;int main(void)&#123; read(n),read(m),read(q); for(int i=1;i&lt;=m;i++)read(x[i]),read(y[i]),AddEdge(x[i],y[i]),AddEdge(y[i],x[i]); for(int i=1;i&lt;=n;i++)if(!dfn[i])TarjanSCC(i); memset(e,0,sizeof(e)); memset(h,0,sizeof(h)); ep=1; for(int i=1;i&lt;=m;i++)if(color[x[i]]!=color[y[i]])AddEdge(color[x[i]],color[y[i]]),AddEdge(color[y[i]],color[x[i]]); for(int i=1;i&lt;=q;i++) &#123; read(qx),read(qy); if(color[qx]!=color[qy])AddQuery(color[qx],color[qy]),AddQuery(color[qy],color[qx]); &#125; for(int i=1;i&lt;=cp;i++)f[i]=i; for(int i=1;i&lt;=cp;i++)if(!done[i])TarjanLCA(i); for(int i=1;i&lt;=cp;i++)if(!dep[i])dep[i]=1,dfs(i); for(int i=2;i&lt;=qp;i+=2) &#123; pos[Q[i|1].y]=dep[Q[i|1].y]-dep[Q[i|1].ans]; neg[Q[i].y]=dep[Q[i].y]-dep[Q[i|1].ans]; &#125; for(int i=1;i&lt;=n;i++)if(!vis[i])GetPosUp(i); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++)if(!vis[i])GetNegUp(i); puts(&quot;Yes&quot;); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://hydd.cf/categories/Codeforces/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"http://hydd.cf/tags/Tarjan/"},{"name":"树上差分","slug":"树上差分","permalink":"http://hydd.cf/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"}]},{"title":"20200825 day2题解","slug":"sol_9","date":"2020-08-24T16:00:00.000Z","updated":"2020-10-01T04:58:00.519Z","comments":true,"path":"2020/08/25/sol_9/","link":"","permalink":"http://hydd.cf/2020/08/25/sol_9/","excerpt":"","text":"树状数组 考场 $AC$。 首先，对于一个点 $x$，它管辖的点数为 $lowbit(x)$，如下图： $1$ 管辖了 $[1,1]$，$2$ 管辖了 $[1,2]$，$3$ 管辖了 $[3,3]$，$4$ 管辖了 $[1,4]\\cdots$。 首先先从 $S$ 个数中选出不同的 $m$ 个数，方案数为 $\\binom Sm$，之后我们只考虑这 $m$ 个数。算这个可以直接 $\\frac{(S-m+1)(S-m+2)\\cdots S}{m!}$ 暴力 $O(m)$ 计算。 题目要求的是计数器上和值的和，不妨对每个点的贡献分开来考虑，下面我们计算点 $x$ 对答案的贡献。 记 $u=lowbit(x)$（即管辖的点数），那么贡献应为 $\\sum\\limits_{i=0}^m \\binom mi\\binom mi\\times u^i (n-u)^{m-i}\\times f(i)\\times(m-i)!$ 解释一下：枚举的 $i$ 表示有 $i$ 次操作在 $\\rm mdf$ 时经过了 $x$。 在 $m$ 次操作中，选出一些操作，使得这几次操作经过了 $x$，其它操作不经过 $x$，所以有 $\\binom mi$ 种方案。 在 $m$ 次操作中，选出 $i$ 次经过 $x$ 的操作使用的 $b_i$，所以有 $\\binom mi$ 种方案。 选 $[x-u+1,x]$ 这些点中的任一点都会经过 $x$ ，所以有 $u$ 种方案，$i$ 次操作共有 $u^i$ 种方案。 同理，选除了 $[x-u+1,x]$ 这些点外的任一点都不会经过 $x$，所以有 $n-u$ 种方案，$m-i$ 次操作共有 $(n-u)^{m-i}$ 种方案。 $f(i)$ 表示所有长度为 $i$ 的排列，当前值为前缀最大值的位置数量之和，也就是 $x$ 点的贡献。 而剩下的 $(m-i)!$ 即为剩下的不经过 $x$ 的操作，它们的 $b_i$ 可以随便排列。 现在比较重要的是这个 $f(i)$ 怎么算，考虑递推。 如果现在知道了 $f(i-1)$，设它排列中的数均在 $[2,i]$ 之间。那么，我们在长度为 $i$ 的排列中任意的位置插入一个 $1$，那么它对其它位置的贡献没有影响，依旧为 $f(i-1)$，因为它是最小的数，而插入有 $i$ 种方案。 而 $1$ 本身有没有贡献呢？可以发现，只有 $1$ 在第一个位置才会有 $1$ 的贡献，在其它位置没有贡献。而 $1$ 在第一个位置有 $(n-1)!$ 种方案。 所以，$f(i)=i\\times f(i-1)+(i-1)!$。 官方题解用的是第一类斯特林数 $n\\brack m$ 表示将 $n$ 个数的序列划分为 $m$ 个圆排列的方案数，顺便提一句，第二类斯特林数 $n\\brace m$ 表示将 $n$ 个数的序列划分为 $m$ 个非空集合的方案数。 $n$ 个数的排列，有 $m$ 个数满足这个数是前缀中最大的的方案数为 $n\\brack m$。原因是把 $n$ 个数分成了 $m$ 段，每段中最大数一定在最前面，即每一段内的排列，只有相对位置不同，才算不同的排列，就是圆排列。而 $f(i)=\\sum_{j=0}^i {i\\brack j}\\times j$，通过 ${n\\brack m}={n-1 \\brack m-1}+{n-1\\brack m}\\times (n-1)$ 也可推出相同的结果，这里不再赘述。 这样直接模拟的复杂度是 $O(nm)$，还是过不去。但是我们可以发现，它们的 $lowbit$ 只有 $\\log n$ 种。 于是我们可以计算出 $lowbit(x)=2^i$ 的 $1\\leqslant x\\leqslant n$ 的个数一起计算。可以发现即为 $\\lfloor \\frac{\\lfloor \\frac n{2^i}\\rfloor+1}2\\rfloor$。（即要保证后 $i-1$ 位为 $0$，$i$ 位为 $1$）。 时间复杂度 $O(m\\log n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/********************************************************************* * Source：FOI2020算法高级培训第2试 * Problem：bit * Author：hydd * Date：2020/8/25 * Encoding：Simplified Chinese (GB2312)*********************************************************************/#include&lt;cstdio&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;const int Mod=998244353;int n,m,S; ll ans,sum,s;ll fac[510000],inv[510000],num[510000];ll p1[510000],p2[510000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ll C(int n,int m)&#123; if (n&lt;m) return 0; return fac[n]*inv[m]%Mod*inv[n-m]%Mod;&#125;int main()&#123; freopen(&quot;bit.in&quot;,&quot;r&quot;,stdin); freopen(&quot;bit.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); S=read(); fac[0]=1; for (int i=1;i&lt;=m;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=m;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=m;i++) inv[i]=inv[i-1]*inv[i]%Mod; num[0]=0; for (int i=1;i&lt;=m;i++) num[i]=(num[i-1]*i+fac[i-1])%Mod; ans=inv[m]; sum=0; for (int i=S-m+1;i&lt;=S;i++) ans=ans*i%Mod; if (!ans)&#123; puts(&quot;0&quot;); return 0;&#125; int u,tot; for (int i=0;(1&lt;&lt;i)&lt;=n;i++)&#123;//lowbit(x)==2^i,1&lt;=x&lt;=n u=(1&lt;&lt;i); tot=(((n&gt;&gt;i)+1)&gt;&gt;1); s=0;//tot_x p1[0]=1; for (int j=1;j&lt;=m;j++) p1[j]=p1[j-1]*u%Mod; p2[0]=1; for (int j=1;j&lt;=m;j++) p2[j]=p2[j-1]*(n-u)%Mod; for (int j=0;j&lt;=m;j++) s=(s+p1[j]*p2[m-j]%Mod*num[j]%Mod*C(m,j)%Mod*C(m,j)%Mod*fac[m-j])%Mod; sum=(sum+s*tot)%Mod; &#125; ans=ans*sum%Mod; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; 矩形计数 考场上没有想到这种类似根号分治的做法，得了 $60pts$。 设 $blo=\\sqrt n$。 按每列点的个数分类：第一种 $\\leqslant blo$，第二种 $&gt;blo$。分情况考虑： 矩形左右两边的列都是第一类的方案数： 对于所有第一类的列，将列中所有点两两横坐标组成的二元组的数量 $+1$。由于点都不同，所以同一列中不会有重复的二元组。 执行完之后，每个二元组的数量即有这个二元组的列的个数 然后看每个二元组的数量，若数量为 $u$，则对答案贡献 $\\binom u2$。因为它们两两之间都可以组成矩形，$x_1,x_2$ 为二元组中的两个数，$y_1,y_2$ 为这两列的编号。 这个复杂度为 $\\sum a_i^2$，满足 $\\sum a_i\\leqslant n，a_i\\leqslant blo$。推导一下可以发现它不超过 $blo^2\\times \\frac n{blo}=n\\times blo$。 矩形左右两边的列至少有一种是第二类的方案数： 枚举第二类的列，将列中所有横坐标的位置标记。标记后枚举其它所有列，对于某一列，看它有的横坐标有多少个被标记，若数量为 $u$，则对答案贡献 $\\binom u2$。因为它们两两之间都可以组成矩形，$x_1,x_2$ 为 $u$ 中的两个数，$y_1,y_2$ 为这两列的编号。（注意，若两列都是第二类，则有可能算重，可以钦定两列的编号大小，比如只在编号大的列统计编号小的对它的贡献） 对于一个第二类的列，复杂度为 $O(n)$。（点数之和为 $n$）。而第二类的列最多有 $\\frac n{blo}$ 个，复杂度为 $O(\\frac{n^2}{blo})$。 而 $blo=\\sqrt n$，故时间复杂度为 $O(n\\sqrt n)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/********************************************************************* * Source：FOI2020算法高级培训第2试 * Problem：rec * Author：hydd * Date：2020/8/25 * Encoding：Simplified Chinese (GB2312)*********************************************************************/#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;int n,x[110000],y[110000],tmp[110000],s[110000];int cnt1,a[110000],cnt2,b[110000]; ll ans;vector&lt;int&gt; vec[110000],num[110000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ll calc(int x)&#123; return 1ll*x*(x-1)/2;&#125;int main()&#123; freopen(&quot;rec.in&quot;,&quot;r&quot;,stdin); freopen(&quot;rec.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); int blo=(int)sqrt(n); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); a[++cnt1]=x[i]; b[++cnt2]=y[i]; &#125; sort(a+1,a+cnt1+1); cnt1=unique(a+1,a+cnt1+1)-a-1; sort(b+1,b+cnt2+1); cnt2=unique(b+1,b+cnt2+1)-b-1; for (int i=1;i&lt;=n;i++)&#123; x[i]=lower_bound(a+1,a+cnt1+1,x[i])-a; y[i]=lower_bound(b+1,b+cnt2+1,y[i])-b; vec[x[i]].push_back(y[i]); &#125; for (int i=1;i&lt;=cnt1;i++) sort(vec[i].begin(),vec[i].end()); for (int i=1;i&lt;=cnt1;i++)&#123; int len=vec[i].size(); if (len&gt;blo) continue; for (int a=0;a&lt;len;a++) for (int b=a+1;b&lt;len;b++) num[vec[i][a]].push_back(vec[i][b]); &#125; for (int i=1;i&lt;=cnt2;i++)&#123; int len=num[i].size(),cnt=0; for (int j=0;j&lt;len;j++)&#123; if (!tmp[num[i][j]]) s[++cnt]=num[i][j]; tmp[num[i][j]]++; &#125; for (int i=1;i&lt;=cnt;i++)&#123; ans+=calc(tmp[s[i]]); tmp[s[i]]=0; &#125; &#125; for (int i=1;i&lt;=cnt1;i++)&#123; int len=vec[i].size(); if (len&lt;=blo) continue; for (int j=0;j&lt;len;j++) tmp[vec[i][j]]=1; for (int a=1;a&lt;=cnt1;a++)&#123; int len2=vec[a].size(); if (len2&gt;blo&amp;&amp;i&lt;=a) continue; int tot=0; for (int b=0;b&lt;len2;b++) if (tmp[vec[a][b]]) tot++; ans+=calc(tot); &#125; for (int j=0;j&lt;len;j++) tmp[vec[i][j]]=0; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; 分果汁 考场上没有想到合并 $k$，得了 $60pts$。 首先要证明几个定理： 定理一：$n(n&gt;1)$ 种果汁必能分入 $n-1$ 个瓶子。 这个类似于 $NOI2020$ 制作菜品。设 $sum$ 为总体积，$k$ 为每个瓶子的容积。有以下关系：$k=\\frac{sum}{n-1}$。 每次选择体积最小的和体积最大的果汁，它们之和必定 $&gt;k$（如果 $\\leqslant k$，那么剩下的果汁的体积也必定 $&lt;k$，所以总体积 $&lt; k+(n-2)k=(n-1)k=sum$，矛盾）。 那么必定有剩余，将剩余的当做一种新的果汁，即变成了 $n-1$ 种果汁分入 $n-2$ 个瓶子。 而 $2$ 种果汁必能分入 $1$ 个瓶子，归纳得证。 定理二：$m=n−p(p\\geqslant 1)$ 的问题有解当且仅当能划分为 $p$ 个 $m=n−1$ 的问题 考虑建图，把果汁看成点，将放入同一个瓶子的果汁连边。 $n$ 个点，$\\leqslant n-p$ 条边，必定存在一个连通块满足 边数$=$点数$-1$。（否则所有连通块边数 $\\geqslant$ 点数，那么总边数$\\geqslant$总点数，即 $n-p\\geqslant n(p\\geqslant 1)$，矛盾。将这个连通块删去，变为 $m’=n’-(p-1)$ 的问题。 当 $p=1$ 时显然成立，归纳得证。 记 $f_(S,j)$ 为果汁集合为 $S$，分成了 $j$ 个 $m=n-1$ 的子问题，用一个长度为 $n$ 的 $01$ 串表示（$n$ 个位置代表的是不同的 $k$）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/********************************************************************* * Source：FOI2020算法高级培训第2试 * Problem：juice * Author：hydd * Date：2020/8/25 * Encoding：Simplified Chinese (GB2312)*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;int n,a[22],f[1100000],ans;ll sum[1100000],tot[1100000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;int main()&#123; freopen(&quot;juice.in&quot;,&quot;r&quot;,stdin); freopen(&quot;juice.out&quot;,&quot;w&quot;,stdout); n=read(); ans=n; for (int i=0;i&lt;n;i++) a[i]=read(); for (int i=0;i&lt;1&lt;&lt;n;i++) for (int j=0;j&lt;n;j++) if (i&amp;(1&lt;&lt;j))&#123; tot[i]++; sum[i]+=a[j]; &#125; f[0]=(1&lt;&lt;(n+1))-1; int upperlim=(1&lt;&lt;n)-1; for (int now=1;now&lt;n;now++)&#123; for (int j=0;j&lt;=upperlim;j++) for (int k=0;k&lt;n;k++) f[j|(1&lt;&lt;k)]|=f[j]; for (int i=0;i&lt;=upperlim;i++)&#123;//K=sum[(1&lt;&lt;n)-1]/m,sum[i]==(tot[i]-now)*K ===&gt; m=p/q 要分出n-m个，答案为m ll p=sum[(1&lt;&lt;n)-1]*(tot[i]-now),q=sum[i]; if (i&amp;&amp;p&gt;0&amp;&amp;p%q==0)&#123; int x=max(n-p/q,0ll); f[i]&amp;=(1&lt;&lt;x);//原来符合条件，并且现在也符合条件才行，否则不行。 &#125; else f[i]=0; &#125; if (f[(1&lt;&lt;n)-1]&amp;(1&lt;&lt;now)) ans=n-now; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"FOI2020高级培训","slug":"FOI2020高级培训","permalink":"http://hydd.cf/categories/FOI2020%E9%AB%98%E7%BA%A7%E5%9F%B9%E8%AE%AD/"}],"tags":[]},{"title":"僵尸","slug":"sol_1","date":"2020-08-22T16:00:00.000Z","updated":"2020-11-13T01:33:36.015Z","comments":true,"path":"2020/08/23/sol_1/","link":"","permalink":"http://hydd.cf/2020/08/23/sol_1/","excerpt":"","text":"题目大意 给定一棵 $n$ 个点的无根树，每条边有一堵墙，高度在 $[l_i,r_i]$ 等概率出现。 有 $m$ 个僵尸，第 $i$ 只僵尸初始出生在 $x_i$ 点，能力值为 $h_i$，表示可以走过墙的高度 $&lt;h_i$ 的边。 称一个点是安全的，当且仅当它不能被任何一个僵尸走到。 求树上至少有一个点是安全的概率，对 $998244353$ 取模，有 $T$ 组数据。 $T\\leqslant 5,1\\leqslant n,m\\leqslant 2000,1\\leqslant x_i\\leqslant n,1\\leqslant l_i,r_i,h_i\\leqslant 10^9$，保证 $r_i-l_i+1\\neq 998244353$。 $\\texttt{source:[Nowcoder2018 ACM多校第十场 I] Rikka with Zombies}$。 题解先说说考场的思路： 首先，因为所有高度都是等概率的，所以可以用 $p=\\frac{\\texttt{至少有一个点是安全的方案数}}{\\texttt{总方案数}}$ 得到答案，而 $1-p=\\frac{\\texttt{所有点都不安全的方案数}}{\\texttt{总方案数}}$，所以我们可以算所有点都不安全的方案数。 这个东西并不容易直接算，而这种树上计数问题一般考虑树形 $dp$。 所以，我当时设的是 $dp[u][i]$ 表示以 $u$ 为根，$u$ 子树内的所有点都是不安全的，且 $u$ 子树内能走到 $u$ 的能力值最大的僵尸编号。然后我们会发现，$u$ 子树内的一些点可能可以从子树外的僵尸走到，所以就不行了。 正解： 一般的树形 $dp$ 是只考虑子树内的，但是这题是要考虑子树外的。 设的是 $dp[u][i]$ 表示以 $u$ 为根，$u$ 子树内的所有点都是不安全的，子树外皆有可能，且能走到 $u$ 的能力值最大的僵尸编号（可以在子树外）。 考虑 $f[v][b]$ 对 $f[u][a]$ 的贡献， $v$ 是 $u$ 的一个孩子。 若 $a=b$，不论 $a$ 在 $v$ 子树内还是子树外，都必须能跨过 $(u,v)$。那么 $f[u][a]+=f[u][a]\\times f[v][b]\\times(a\\texttt{能跨过}(u,v)\\texttt{的方案数})$。 若 $a\\neq b$，那么 $a,b$ 必定不同时在 $v$ 子树内或 $v$ 子树外，且它们两者能力值较大的必定不能跨过 $(u,v)$。 具体来说，若 $a &lt; b$，且 $a$ 在子树 $v$ 外，$b$ 在子树 $v$ 内，那么 $f[u][a]+=f[u][a]\\times f[v][b]\\times(b\\texttt{不能跨过}(u,v)\\texttt{的方案数})$。若 $a &gt; b$，且 $a$ 在子树 $v$ 外，$b$ 在子树 $v$ 内，那么 $f[u][a]+=f[u][a]\\times f[v][b]\\times(a\\texttt{不能跨过}(u,v)\\texttt{的方案数})$。 初值怎么设呢？设 $u$ 点出生的能力值最大的僵尸为 $k$（没有则为 $1$）， 则对于所有 $i\\geqslant k$，$f[u][i]=1$。 但是，如果 $x[a]..u$ 之间的最小的 $l$ 都 $\\geqslant h_a$ 的话，那贡献应该为 $0$，那它在 $dp$ 中会不会有贡献？ 而在它们两个的 $LCA$ 的时候，贡献必定已经消失了，因为必定有一条边不能跨过，贡献是乘起来的，所以就是 $0$。也就是，它在 $LCA$ 的时候才能保证 $dp$ 值是正确的，在其他位置有可能是错误的，比较奇怪。显然的是， $f[1]$ 的值是对的，答案显然是 $\\sum_i f[1][i]$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/********************************************************************* * Source：CSP-S模拟赛 * Problem：zombie * Author：hydd * Date：2020/8/21 * Encoding：Simplified Chinese (GB2312)*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;bitset&gt;using namespace std;typedef long long ll;const int MAXN=2100;const int MAXE=4100;const int Mod=998244353;int T,n,m,l[MAXN],r[MAXN],f[MAXN][MAXN],tmp[MAXN];int edgenum,vet[MAXE],Next[MAXE],Head[MAXN];bitset&lt;MAXN&gt; vis[MAXN];struct node&#123; int x,v; bool operator&lt;(const node &amp;a) const&#123; return v&lt;a.v;&#125;&#125; a[MAXN];inline int getnum(int t,int v)&#123; return max(0,min(v-1,r[t])-l[t]+1);&#125;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ll qpow(ll x,int a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void dfs(int u,int fa)&#123; int pos=1,v,sum; for (int i=1;i&lt;=m;i++) if (a[i].x==u) vis[u][i]=1,pos=i; else vis[u][i]=0; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (v==fa) continue; dfs(v,u); vis[u]|=vis[v]; &#125; for (int i=1;i&lt;=m;i++) f[u][i]=(i&gt;=pos); for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (v==fa) continue; int t=e&gt;&gt;1; for (int i=1;i&lt;=m;i++) tmp[i]=f[u][i],f[u][i]=0; for (int i=1;i&lt;=m;i++)&#123;//i=j int k=getnum(t,a[i].v); f[u][i]=(f[u][i]+1ll*tmp[i]*f[v][i]%Mod*k)%Mod; &#125; sum=0; for (int i=1;i&lt;=m;i++)&#123;//i&gt;j，i在子树外，j在子树内 int k=getnum(t,a[i].v); if (vis[v][i]) sum=(sum+f[v][i])%Mod;//在子树内，记录前缀和 else f[u][i]=(f[u][i]+1ll*tmp[i]*sum%Mod*(r[t]-l[t]+1-k))%Mod; &#125; sum=0; for (int i=m;i&gt;=1;i--)&#123;//i&lt;j，i在子树外，j在子树内 int k=getnum(t,a[i].v); if (vis[v][i]) sum=(sum+1ll*f[v][i]*(r[t]-l[t]+1-k))%Mod;//在子树内，记录前缀和 else f[u][i]=(f[u][i]+1ll*tmp[i]*sum)%Mod; &#125; &#125;&#125;int main()&#123; freopen(&quot;zombie.in&quot;,&quot;r&quot;,stdin); freopen(&quot;zombie.out&quot;,&quot;w&quot;,stdout); T=read(); while (T--)&#123; n=read(); m=read(); int ans=0,ans2=1; edgenum=1; for (int i=1;i&lt;=n;i++) Head[i]=0; int u,v; for (int i=1;i&lt;n;i++)&#123; u=read(); v=read(); l[i]=read(); r[i]=read(); ans2=1ll*ans2*(r[i]-l[i]+1)%Mod; addedge(u,v); addedge(v,u); &#125; for (int i=1;i&lt;=m;i++) a[i].x=read(),a[i].v=read(); sort(a+1,a+m+1); dfs(1,0); for (int i=1;i&lt;=m;i++) ans=(ans+f[1][i])%Mod; ans=1ll*ans*qpow(ans2,Mod-2)%Mod; printf(&quot;%d\\n&quot;,(Mod+1-ans)%Mod); &#125; return 0;&#125;","categories":[{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://hydd.cf/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"树形dp","slug":"树形dp","permalink":"http://hydd.cf/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"概率/期望","slug":"概率-期望","permalink":"http://hydd.cf/tags/%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"}]},{"title":"NOI2020网络同步赛 总结","slug":"sum_2","date":"2020-08-21T16:00:00.000Z","updated":"2020-10-01T05:05:46.874Z","comments":true,"path":"2020/08/22/sum_2/","link":"","permalink":"http://hydd.cf/2020/08/22/sum_2/","excerpt":"","text":"$Day1 \\ T1:$ 矩阵乘法套路题，先把每个点拆成 $5$ 个点，然后把点权放到边上，直接广义矩乘矩阵做是三次方，后面发现它只要取第一行第一列，可以最后乘上一个列向量，然后再取最后的列向量的第一个数即可。剩下的可以直接类似于 $NOI\\ Online\\ 3$ 的 $T2$ 做就可以了。但是考试的时候并没有过，原因是循环的时候数组越界了，而且极限数据它并没有显示 $RE$，只不过是答案错了，找不出来（可能 $Linux$ 会直接显示 $RE$）。 $Day1 \\ T2:$ 线段树合并优化 $dp$ 题，考试上确实往 $dp$ 方面想了，状态设计的也没有问题，但是我用是刷表法，导致 $dp$ 没什么优化思路，复杂度 $O(\\sum dep_i)$，得了 $44pts$。用填表法就可以前缀和优化了，可以得 $64pts$。后面就可以线段树合并了。 $Day1\\ T3:$ 毒瘤分块题，给定下标区间和值域区间，求逆序对个数。我在考场上写了个大暴力，用莫队写了 $O(n\\sqrt n\\log n)$ 的算法，期望 $40$ 分，最后拿到了 $36pts$（数组开小了）。最后算法是分块。 $Day2 \\ T1:$ 贪心 $+$ 背包题。我刚开始想到两种贪心，都写了，第一种过了前两个样例，第二种过了第三个样例。读题的时候没有发现 $m\\geq n-2$ 这个条件的性质。最后写了个暴力，考后才发现第二种暴力在 $m=n-1$ 时就是对的，而且第三个样例就是 $m=n-1$，可以多得 $15pts$。 $Day2 \\ T2:$ 分治乱搞题，刚开始想到了一个思路，就是每次将一个点的三种情况合并，然后继续合并，如果能合并成一个点，那么有解，否则无解。然后实在太难写了，就没有去写。然后写了很假的贪心，刚开始第四个样例中第二个没过，调了一会儿，第四个样例第四个又没过，然后手动模拟发现假了，最后只有 $12pts$。 $Day2\\ T3:$ 不可做图论题，图是个三角剖分，可以发现情况 $A$ 只要先跑最短路，再看删去最短路两点是否联通即可，有 $20pts$。 总结这次 $NOI$ 同步赛，主要问题还是出在细节和草稿、思维能力上。 在草稿上手动模拟贪心过程，就可以免去很多打代码，调试的时间。 注意细节，可以避免许多不必要的错误。","categories":[{"name":"NOI2020","slug":"NOI2020","permalink":"http://hydd.cf/categories/NOI2020/"}],"tags":[]},{"title":"APIO2020 记录和总结","slug":"sum_1","date":"2020-08-17T16:00:00.000Z","updated":"2020-10-01T05:05:42.696Z","comments":true,"path":"2020/08/18/sum_1/","link":"","permalink":"http://hydd.cf/2020/08/18/sum_1/","excerpt":"","text":"记录 看了看三道题，感觉 $T1,T3$ 都不好做，然后先去做 $T2$。 最开始的思路是二分后判断，然后感觉不太行，因为二分判断的话复杂度必定不低于线性，而询问直接又不可以重复利用（整体二分），复杂度是平方级别的。 于是就先放下这个思路，往贪心方面想，但是没有想出来。 去想 $T1$，发现有个 $\\sum f^2(i)\\leqslant 4\\times 10^5$ 的条件。然后发现有个必要条件：$f(i)\\leqslant 632$。 开始只有一个类似于 $O(N(\\max f(i))^2)$ 的复杂度的预处理 $dp$，再 $O(N)$ 进行 $dp$ 的方法。具体来说， 先预处理出合法的，可以染色的长为 $M$ 的区间，处理的方法是先设 $f[i][j]$ 表示第 $i$ 个位置以第 $j$ 个可以染当前位置的承包商结尾的最长能染多长。 从左往右枚举每一个位置 $i$ 。再枚举 $i$ 位置的颜色所有可以染的承包商 $j$，再枚举 $i-1$ 位置所有可以染的承包商 $k$，看它们的差是否为 $1$。如果为 $1$，$f[i][j]$ 就可以从 $f[i-1][k]+1$ 转移过来。如果 $dp[i][*]$ 有 $\\geq K$ 的，那么这个位置往前 $M$ 个是可以染的。 之后 $dp$ 的方法就是 $dp_i=\\min_\\limits{i-k\\leq j&lt;i} dp_j+1$。里面这个可以直接用单调队列维护。 后来发现这个预处理可以直接用类似桶的东西来解决，就直接写好交了，一遍过。 去想 $T2$，又重新往二分方面想。 保留边权 $\\leqslant mid$ 的边后，发现了一个性质：当且仅当 $x,y$ 不在同一连通块或所在的连通块是一条链的时候，是非法的，否则是合法的。这样会有 $37pts$。 然后就直接暴力判断啊，当时又想了想其它算法，想不出，然后开始写，$11:00$ 交了第一发，$WA$ 了。调了 $30$ 多分钟也没调出来。就先去写前面的 $6pts$，认为是一条链，开始还想 $ST$ 表啥的，后来发现直接是 $-1$。但是交上去又 $WA$ 了（心态有点爆炸）。就再去写那个 $7pts$，也调了好久，调过了，就先去看 $T3$。 $T3$ 暴力的 $26pts$ 就是先找最长的，再找剩下最长的，再找 $\\cdots$ 即可，询问次数为 $O(n^2)$。 然后重构 $T2$ $37pts$ 的代码，然后过了。又发现那个 $6pts$ 除了一条链之外还有可能是一个环。然后又想 $ST$ 表啥的，发现就是环上最大值，也过了。 再去想 $T3$ 的完全二叉树部分，发现找最长的可以通过枚举 $LCA$ 然后 $set$ 解决，也写完过了，时间也差不多结束了。 总得分：$100+50+47=197$。 总结 总体发挥还算可以（我可能比较适合 $IOI$ 赛制？） 这种交互式的题型不太会调试，导致调的比较慢（后来知道可以用 $dev-c++$ 开工程解决）。但好处是不需要手动把部分分拼起来。 然后实在调不出来可以重构代码，要仔细注意题目的条件，考虑所有情况（比如连通图每个点度数 $\\leqslant 2$ 可以是一条链，也可以是一个环 ）。","categories":[{"name":"APIO2020","slug":"APIO2020","permalink":"http://hydd.cf/categories/APIO2020/"}],"tags":[]},{"title":"WC2020 题解","slug":"sol_10","date":"2020-08-13T16:00:00.000Z","updated":"2020-09-30T13:02:17.839Z","comments":true,"path":"2020/08/14/sol_10/","link":"","permalink":"http://hydd.cf/2020/08/14/sol_10/","excerpt":"","text":"「WC2020」有根树题面描述 给定一棵包含 $n$ 个结点的有根树，结点从 $1 \\sim n$ 编号，$1$ 号点为根结点。小明有一个结点集合 $S$，对于 $S$ 中的结点 $u$，他定义 $w_u$ 的值为 $u$ 的子树中（包括 $u$ 本身）被包含在集合 $S$ 内的结点数，为了方便叙述，对于不在 $S$ 中的结点，我们认为其 $w_u=0$ 。 接下来，小明需要你选择一个包含根结点的连通块 $C$。记 $a$ 表示连通块 $C$ 中被包含在集合 $S$ 内的结点数，$b$ 表示不在连通块 $C$ 中的结点的 $w$ 值最大值，若不存在不在 $C$ 中的结点，则 $b = 0$，小明希望你能最小化 $\\max(a,b)$。 小明觉得这个问题还比较简单，所以还给出了 $q$ 次操作，每次会令集合 $S$ 加入或删除一个结点，请你对每次操作后的集合 $S$ 给出 $\\max(a,b)$ 的最小值。 输入格式 第一行一个正整数 $n$ 表示结点数。 接下来 $n-1$ 行，每行两个整数 $x,y$，表示树上的一条边 $(x,y)$。 接下来一行一个正整数 $q$ 表示操作数。 接下来 $q$ 行，每行两个数 $t,v$ 表示一次操作。若 $t=1$ 则该操作为将结点 $v$ 加入 $S$，保证操作前 $v \\not \\in S$。若 $t=2$ 则该操作为将结点 $v$ 从 $S$ 中删去，保证操作前 $v\\in S$。 初始时 $S$ 为空集。 输出格式 每次操作后，输出一行一个整数表示答案。 样例1input123456789101151 21 31 42 551 41 11 21 52 2 output1234511121 explanation 第一次操作后 $S=\\{4\\}$，一个选择方案为 $C=\\{1\\}$，此时 $a=0,b=1$。 第二次操作后 $S=\\{1,4\\}$，一个选择方案为 $C=\\{1\\}$，此时 $a=1,b=1$。 第三次操作后 $S=\\{1,2,4\\}$，一个选择方案为 $C=\\{1\\}$，此时 $a=1,b=1$。 第四次操作后 $S=\\{1,2,4,5\\}$，一个选择方案为 $C=\\{1,2\\}$，此时 $a=2,b=1$。 第五次操作后 $S=\\{1,4,5\\}$，一个选择方案为 $C=\\{1\\}$，此时 $a=0,b=1$。 样例2 见附加文件。 样例3 见附加文件。 数据范围 对于所有测试点：$1\\le n\\le 5\\times 10^5$，$1\\le q\\le 10^6$,$1\\le x,y,v\\le n$,$t\\in \\{1,2\\}$。 表格中特殊限制一栏符号的含义为： $A$：任意时刻集合 $S$ 的大小不超过 $50$。 $B$：树的形态是一条链且 $1$ 号结点度数为 $1$。 $C$：树上每个结点的双亲结点编号小于它本身，$n=q$ 且第 $i$ 次操作为将 $i$ 号点加入 $S$。 时间限制: $4\\texttt{s}$ 空间限制: $512\\texttt{MB}$ Solution 一个性质：$C$ 一定是 $S$ 集合中 $w$ 值最大的若干个点（记作集合 $A$）和根形成的连通块。 考虑反证：若 $\\exists x,x\\in S\\backslash A$，那 $x$ 必为 $A$ 中某个点（设为 $y$）的祖先，所以 $w_x&gt;w_y$，不满足 $A$ 的定义。 令 $B=S-A$，我们强制钦定 $|A|\\geq\\max_{x\\in B} w_x$。每一次询问要求的答案就是当前的 $|A|$。 根据定义，显然有：$\\max_{x\\in B} w_x\\leq \\min_{x\\in A} w_x$。记 $ans=|A|$。 $O(n \\log^2 n)$ 做法 对原树进行轻重链剖分。 线段树维护每个节点子树内的 $\\max_{x\\in B} w_x$和 $\\min_{x\\in A} w_x$（分别记为 $mx[now],mn[now]$），询问时调整。 初始时，$mx[now]=-INF,mn[now]=INF$，代表子树中没有在 $S$ 中的点。 加入一个数 $x$ 时，先将它加入到 $B$ 中。那么相当于在将 $x$ 的 $mx+=INF$。若原来的值为 $-INF+k$，那么现在的值为 $k$（$k$ 即为 $x$ 子树在 $S$ 中的点的个数）。然后将 $x$ 到根路径上的所有 $w++$。 删除一个数 $x$ 时，若当前位置 $mx&lt;0$，说明并不在 $A$ 中，就从 $B$ 中删除，$mx-=INF$。否则从 $A$ 中删除，$mn+=INF$，同时 $ans—$。（$A$ 的大小减少了 $1$）。然后将 $x$ 到根路径上的所有 $w—$。 若 $\\max_{x\\in B} w_x&gt; \\min_{x\\in A} w_x$，再将 $B$ 中的最大值移入 $A$ 中，使得其满足 $A$ 的定义。 若 $|A|&lt;\\max_{x\\in B} w_x$，再将 $B$ 中的最大值移入 $A$ 中。（已强制钦定 $|A|\\geq\\max_{x\\in B} w_x$） 若 $|A|&gt;min_{x\\in A} w_x$，当前答案必大于 $min_{x\\in A} w_x$，那么将 $A$ 中的最小值移到 $B$ 中，答案必定不会变劣。 最后得到的 $|A|$ 就是答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/********************************************************************* Problem:「WC2020」有根树 Author:hydd Date:2020/8/13 Encoding:Simplified Chinese (GB2312)*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;const int INF=0x3f3f3f3f;char Getchar()&#123; static char now[1&lt;&lt;20],*A,*B; if (B==A)&#123; B=(A=now)+fread(now,1,1&lt;&lt;20,stdin); if (B==A) return EOF; &#125; return *A++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;int n,q,ans,fa[510000],sz[510000];int dtime,son[510000],top[510000],dfn[510000];int edgenum,vet[1100000],val[1100000],Next[1100000],Head[510000];void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void dfs(int u,int f)&#123; fa[u]=f; sz[u]=1; son[u]=0; for (int e=Head[u],v;e;e=Next[e])&#123; v=vet[e]; if (v==f) continue; dfs(v,u); sz[u]+=sz[v]; if (sz[v]&gt;sz[son[u]]) son[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++dtime; if (son[u]) dfs2(son[u],tp); for (int e=Head[u],v;e;e=Next[e])&#123; v=vet[e]; if (v==fa[u]||v==son[u]) continue; dfs2(v,v); &#125;&#125;//namespace Segment Treeint mn[2100000],mx[2100000],tag[2100000];inline void pushup(int now)&#123; mn[now]=min(mn[now&lt;&lt;1],mn[now&lt;&lt;1|1]); mx[now]=max(mx[now&lt;&lt;1],mx[now&lt;&lt;1|1]);&#125;inline void add(int now,int v)&#123; mn[now]+=v; mx[now]+=v; tag[now]+=v;&#125;inline void pushdown(int now)&#123; if (tag[now])&#123; add(now&lt;&lt;1,tag[now]); add(now&lt;&lt;1|1,tag[now]); tag[now]=0; &#125;&#125;void change(int now,int l,int r,int x,int v)&#123; if (l==r)&#123; if (v&gt;0) mx[now]+=INF;//B中加入 else if (mx[now]&lt;0) mn[now]+=INF,ans--;//A中删除 else mx[now]-=INF;//B中删除 return; &#125; pushdown(now); int mid=(l+r)&gt;&gt;1; if (x&lt;=mid) change(now&lt;&lt;1,l,mid,x,v); else change(now&lt;&lt;1|1,mid+1,r,x,v); pushup(now);&#125;void change(int now,int l,int r,int x,int y,int v)&#123; if (l==x&amp;&amp;r==y)&#123; add(now,v); return; &#125; pushdown(now); int mid=(l+r)&gt;&gt;1; if (y&lt;=mid) change(now&lt;&lt;1,l,mid,x,y,v); else if (x&gt;mid) change(now&lt;&lt;1|1,mid+1,r,x,y,v); else &#123; change(now&lt;&lt;1,l,mid,x,mid,v); change(now&lt;&lt;1|1,mid+1,r,mid+1,y,v);&#125; pushup(now);&#125;void BtoA(int now,int l,int r)&#123; if (l==r)&#123; ans++; mx[now]-=INF; mn[now]-=INF; return; &#125; pushdown(now); int mid=(l+r)&gt;&gt;1; if (mx[now]==mx[now&lt;&lt;1]) BtoA(now&lt;&lt;1,l,mid); else BtoA(now&lt;&lt;1|1,mid+1,r); pushup(now);&#125;void AtoB(int now,int l,int r)&#123; if (l==r)&#123; ans--; mx[now]+=INF; mn[now]+=INF; return; &#125; pushdown(now); int mid=(l+r)&gt;&gt;1; if (mn[now]==mn[now&lt;&lt;1]) AtoB(now&lt;&lt;1,l,mid); else AtoB(now&lt;&lt;1|1,mid+1,r); pushup(now);&#125;int main()&#123;// File(&quot;tree&quot;); n=read(); int op,u,v; for (int i=1;i&lt;n;i++)&#123; u=read(); v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); dfs2(1,1); q=read(); /* 答案必定是S中w最大的若干个点 我们选择的S中w最大的若干个点的子集为A，B=S-A 满足B中最大值&lt;=A中最小值 */ for (int i=1;i&lt;=4*n+1;i++) mn[i]=INF,mx[i]=-INF; while (q--)&#123; op=read(); v=read(); if (op==2) op=-1; change(1,1,n,dfn[v],op); for (;v;v=fa[top[v]]) change(1,1,n,dfn[top[v]],dfn[v],op); /*if (op==1)&#123; while (mn[1]&lt;mx[1]) BtoA(1,1,n);//A中最小值&lt;B中最大值 &#125; else&#123;*/ while (mn[1]&lt;mx[1]) BtoA(1,1,n);//A中最小值&lt;B中最大值 //&#125; while (ans&lt;mx[1]) BtoA(1,1,n);//钦定|A|&gt;=mx[1] while (ans&gt;mn[1]) AtoB(1,1,n);//答案已经比mn[1]大了，把它移到B答案不会变劣 printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; $O(n\\log n)$ 做法 对原树进行轻重链剖分后，维护每条重链上： 重链上的点的个数（记作 $tot$）。 最靠下的在 $A$ 中的点与链顶深度之差 $+1$。记作 $up$），如果没有，设为 $0$。$up$ 的 $w$ 值（记作 $up_w$）。 最靠上的在 $B$ 中的点与链顶深度之差 $+1$（记作 $dw$），如果没有，设为 $tot+1$。$dw$ 的 $w$ 值（记作 $dw_w$）。 维护一个 $cnt=|A|$，再维护 $lim$，要求 $\\min_{x\\in A} x&gt;lim,\\max_{x\\in B}\\leq lim$。 在 $S$ 中插入点 $x$ 找到 $x$ 所在的重链，先更新链上的 $up_w/dw_w$ 都 $+1$。 如果现在的 $dw_w&gt;lim$，就可以把它移动到 $A$ 中（而必定只有一个点会移到 $A$ 中，因为链上从上到下的 $w$ 值必定是严格递减的）。（此条件有可能满足只有可能最靠上的在 $B$ 中的点在 $x$ 上方） 否则，如果当前最靠上的在 $B$ 中的点在 $x$ 下方，那么： 如果 $w_x\\leqslant lim$，那么显然有 $t-fa[x]$ 链上所有点都在 $A$ 中，$son[x]-\\cdots$ 链上所有点都在 $B$ 中，且当前点可以加入 $B$，就可以考虑更新 $up$。 如果 $w_x&gt;lim$，那么显然有 $t-fa[x]$ 链上所有点都在 $A$ 中，$son[x]-\\cdots$ 链上所有点都在 $B$ 中。且当前点可以加入 $A$，就可以考虑更新 $dw$。 接下来，就是更新到根路径上的其他重链的 $up_w/dw_w$，然后看要不要上移分界点即可。 最后，当 $cnt&gt;lim$，不断将 $A$ 中值为 $lim$ 的点移到 $B$ 中即可。 在 $S$ 中删除点 $x$ 找到 $x$ 所在的重链，先更新链上的 $up_w/dw_w$ 都 $-1$。设 $d$ 为当前点的深度与链顶深度之差 $+1$。 如果现在的 $d\\leqslant up[t]$，说明它现在在 $A$ 中，删了之后要将 $cnt—$。同时如果 $d=up[t]$，说明它是 $A$ 中深度最大的点，删去之后要重新求深度最大的点。 如果现在的 $d=dw[t]$，说明它为 $B$ 中深度最小的点，删去之后要重新求深度最小的点。（在 $B$ 中但非深度最小的点删去没有影响）。 然后，若 $up_w[t]\\leq lim$ 且 $up[t]\\neq 0$ （这个点存在），那么就可以把它移动到 $B$ 中，$cnt—$。 接下来，就是更新到根路径上的其他重链的 $up_w/dw_w$，然后看要不要下移分界点即可。 最后，当 $cnt&lt;lim$，不断将 $B$ 值为 $lim$ 的点移到 $A$ 中即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252/********************************************************************* Problem:「WC2020」有根树 Author:hydd Date:2020/8/13-2020/8/14 Encoding:Simplified Chinese (GB2312)*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);//freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;const int INF=0x3f3f3f3f;const int MAXN=510000;const int MAXM=1100000;int n,q;namespace IO&#123; const int LEN=1&lt;&lt;20; char Getchar()&#123; static char now[LEN],*A,*B; if (B==A)&#123; B=(A=now)+fread(now,1,LEN,stdin); if (B==A) return EOF; &#125; return *A++; &#125; int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f; &#125; char pbuf[LEN],*pp=pbuf; void pc(const char c) &#123; if (pp-pbuf==LEN) fwrite(pbuf,1,LEN,stdout),pp=pbuf; *pp++=c; &#125; void write(int x)&#123; static int sta[35]; if (x&lt;0)&#123; pc(&#x27;-&#x27;); x=-x;&#125; int top=0; do&#123; sta[top++]=x%10; x/=10; &#125; while (x); while (top) pc(sta[--top]+&#x27;0&#x27;); &#125; void IOflush()&#123; fwrite(pbuf,1,pp-pbuf,stdout);&#125;&#125; using namespace IO;namespace Graph&#123; int edgenum,vet[MAXM],val[MAXM],Next[MAXM],Head[MAXN]; void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum; &#125;&#125; using namespace Graph;namespace HLD&#123;//Heavy-Light Decompositions int fa[MAXN],sz[MAXN],son[MAXN]; int dtime,L[MAXN],R[MAXN],num[MAXN]; int tot[MAXN],top[MAXN]; void dfs(int u,int f)&#123; fa[u]=f; sz[u]=1; son[u]=0; for (int e=Head[u],v;e;e=Next[e])&#123; v=vet[e]; if (v==f) continue; dfs(v,u); sz[u]+=sz[v]; if (sz[v]&gt;sz[son[u]]) son[u]=v; &#125; &#125; void dfs2(int u,int tp)&#123; top[u]=tp; tot[tp]++; num[++dtime]=u; L[u]=dtime; if (son[u]) dfs2(son[u],tp); for (int e=Head[u],v;e;e=Next[e])&#123; v=vet[e]; if (v==fa[u]||v==son[u]) continue; dfs2(v,v); &#125; R[u]=dtime; &#125;&#125; using namespace HLD;namespace BIT&#123;//Binary Index Tree int tree[MAXN]; void add(int x,int y)&#123; for (;x&lt;=n;x+=x&amp;-x) tree[x]+=y; &#125; int query(int x)&#123; int res=0; for (;x;x-=x&amp;-x) res+=tree[x]; return res; &#125;&#125; using namespace BIT;struct List&#123;//表头为权值，后面接着点的编号 int pre[MAXM],nxt[MAXM]; void del(int x)&#123; if (nxt[x]) pre[nxt[x]]=pre[x]; if (pre[x]) nxt[pre[x]]=nxt[x]; pre[x]=x; nxt[x]=x; &#125; void ins(int v,int x)&#123;//在权值v后插入点x v+=n+1; nxt[x]=nxt[v]; if (nxt[v]) pre[nxt[v]]=x; nxt[v]=x; pre[x]=v; &#125; int get(int v)&#123; return nxt[v+n+1];&#125;&#125; Up,Dw;int up[MAXN],dw[MAXN],up_w[MAXN],dw_w[MAXN];void update(int x)&#123;//更新每条链的分界点的值，存入Up,Dw Up.del(x); if (up[x]&gt;=1) Up.ins(up_w[x],x); Dw.del(x); if (dw[x]&lt;=tot[x]) Dw.ins(dw_w[x],x);&#125;/* up[x]为链上最深度最大的A中的点的深度，up_w[x]为其w值 dw[x]为链上最深度最小的B中的点的深度，dw_w[x]为其w值 &gt;lim的点放入A中，&lt;=lim的点放入B中*/void update_w(int x,int d,int w)&#123;//更新分界点的w值 if (1&lt;=up[x]&amp;&amp;up[x]&lt;=d) up_w[x]+=w; if (dw[x]&lt;=d) dw_w[x]+=w;&#125;int get_w(int x)&#123; return query(R[x])-query(L[x]-1);&#125;//获得一个在S中的点的w值set&lt;int&gt; s[MAXN];set&lt;int&gt;::iterator it;int pred(int x,int y)&#123; it=s[x].lower_bound(y); if (it==s[x].begin()) return 0; else return *--it;&#125;int succ(int x,int y)&#123; it=s[x].upper_bound(y); if (it==s[x].end()) return 0; else return *it;&#125;void delA(int x)&#123;//将链上的深度最大的A从A中删除 up[x]=pred(x,up[x]); up_w[x]=!up[x]?0:get_w(num[L[x]+up[x]-1]);&#125;void delB(int x)&#123;//将链上的深度最大的B从B中删除 dw[x]=succ(x,dw[x]); dw_w[x]=dw[x]&gt;tot[x]?0:get_w(num[L[x]+dw[x]-1]);&#125;void AtoB(int x)&#123;//将链上的深度最大的A移到B中 dw[x]=up[x]; dw_w[x]=up_w[x]; delA(x);&#125;void BtoA(int x)&#123;//将链上的深度最小的B移到A中 up[x]=dw[x]; up_w[x]=dw_w[x]; delB(x);&#125;int cnt,lim;void ins(int x)&#123; add(L[x],1); int t=top[x],d=L[x]-L[t]+1;//d为以t为根时x的深度（t深度为1） s[t].insert(d); update_w(t,d,1);//更新链上分界点的w（分界点在t--x的链上） if (dw_w[t]&gt;lim)&#123; cnt++; BtoA(t);&#125;//直接上移，因为最多分界点只会移动一步 else if (dw[t]&gt;d)&#123;//现在已知dw[t]满足条件且在x之下，看分界点是否能移动 int s=get_w(x); if (s&lt;=lim)&#123; dw[t]=d; dw_w[t]=s;&#125;//原先t--fa[x]链上所有点都在A中，son[x]--*所有点都在B中，且当前点可以加入B else &#123; cnt++; if (d&gt;up[t])&#123; up[t]=d; up_w[t]=s;&#125;//原先t--fa[x]链上所有点都在A中，son[x]--*所有点都在B中，且当前点可以加入A &#125; &#125; update(t); for (int x=fa[t],t=top[x];x;x=fa[t],t=top[x])&#123; d=L[x]-L[t]+1; update_w(t,d,1);//更新链上分界点的w if (dw_w[t]&gt;lim)&#123; cnt++; BtoA(t);&#125;//分界点上移 update(t); &#125; //前面的操作会导致cnt增大 while (cnt&gt;lim)&#123; int x=Up.get(lim); if (!x)&#123; lim++; continue;&#125;//没有权值为lim的A中的点 cnt--; AtoB(x); update(x); &#125; //做完后cnt==lim&#125;void del(int x)&#123; add(L[x],-1); int t=top[x],d=L[x]-L[t]+1;//d为以t为根时x的深度（t深度为1） s[t].erase(d); update_w(t,d,-1);//更新链上分界点的w（分界点在t--x的链上） if (d&lt;=up[t]) cnt--;//从A中删除，因为x已经不在S中了 if (d==up[t]) delA(t);//若x为A中深度最大的点，删去后要重新求深度最大的点 else if (d==dw[t]) delB(t);//若x为B中深度最大的点，删去后要重新求深度最大的点 if (up[t]&gt;=1&amp;&amp;up_w[t]&lt;=lim)&#123; cnt--; AtoB(t);&#125;//x到根路径所有w--，可能导致分界点下移 update(t); for (int x=fa[t],t=top[x];x;x=fa[t],t=top[x])&#123; d=L[x]-L[t]+1; update_w(t,d,-1);//更新链上分界点的w if (up[t]&gt;=1&amp;&amp;up_w[t]&lt;=lim)&#123; cnt--; AtoB(t);&#125;//分界点下移 update(t); &#125; //前面的操作会导致cnt减小 while (cnt&lt;lim)&#123; int x=Dw.get(lim); if (!x)&#123; lim--; continue;&#125;//没有权值为lim的A中的点 cnt++; BtoA(x); update(x); &#125;&#125;int main()&#123;// File(&quot;tree&quot;); n=read(); for (int i=1;i&lt;=(n&lt;&lt;1|1);i++)&#123; Up.pre[i]=0; Up.nxt[i]=0; Dw.pre[i]=0; Dw.nxt[i]=0; &#125; int t,u,v; for (int i=1;i&lt;n;i++)&#123; u=read(); v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); dfs2(1,1); for (int i=1;i&lt;=n;i++) if (top[i]==i)&#123; dw[i]=tot[i]+1;//B中深度最小的点是i往下dw[i]深度的点 s[i].insert(0); s[i].insert(tot[i]+1); &#125; q=read(); while (q--)&#123; t=read(); v=read(); if (t==1) ins(v); else del(v); write(cnt); pc(&#x27;\\n&#x27;); &#125; IOflush(); return 0;&#125;/*51 21 31 42 561 41 11 21 52 21 3*/","categories":[{"name":"WC2020","slug":"WC2020","permalink":"http://hydd.cf/categories/WC2020/"}],"tags":[]},{"title":"20200812 zzq模拟赛题解","slug":"sol_7","date":"2020-08-11T16:00:00.000Z","updated":"2020-10-01T10:23:49.688Z","comments":true,"path":"2020/08/12/sol_7/","link":"","permalink":"http://hydd.cf/2020/08/12/sol_7/","excerpt":"","text":"Query在一次询问后，“预测答案”，并安排后两次询问。 预测成功，两次询问有效。预测失败，就浪费了两次询问。 我们定义一个数列 $a[x]=a[x-1]+a[x-3]+1$（$+1$是等号的情况），$a[1]=0,a[2]=0,a[3]=1$。表示通过这个方法，用 $x$ 次可以询问出值域在 $[1,a[x]]$ 之间的所有数。显然，$3$ 次可以问出一个数。 在第三步询问时，第一步询问的答案已经出来了。 若答案为 $=$，即为这个数； 若答案为 $&gt;$，则后面两次询问浪费，结构和后面的询问没关系。将 $x-=3$，当做一个子问题递归处理； 若答案为 $&lt;$，用类似的方法，第四步询问 $a[x-2]$ 的左子区间（长度为 $a[x-3]$）的第 $a[x-4]+1$ 个数，此时得出了第二步的答案，类似的处理即可。 不管怎样，三步询问后，下一次询问的区间长度都为 $a[x-3]$。则总共需要的次数是 $O(x)$级别的。 又因为 $a[56]&gt;10^9$，所以次数不超过 $56$ 次。 12345678910111213141516171819202122232425#include &quot;query.hpp&quot;#include&lt;algorithm&gt;using namespace std;int a[510];void guess()&#123; a[3]=1; int x; for (int i=4;i&lt;=500;i++)&#123; a[i]=a[i-1]+a[i-3]+1; if (a[i]&gt;=1000000000)&#123; x=i; break;&#125; &#125; int L=1; while (true)&#123; if (query(L+a[max(x-1,0)])==&#x27;=&#x27;) return; if (query(L+a[max(x-2,0)])==&#x27;=&#x27;) return; while (true)&#123; char ch=query(L+a[max(x-3,0)]); if (ch==&#x27;=&#x27;) return; if (ch==&#x27;&lt;&#x27;)&#123; L+=a[max(x-1,0)]+1; x-=3; break; &#125; x--; &#125; &#125;&#125; Xorsum有一些显然的条件：和不小于异或和（$s\\geq x$），和与异或和奇偶性相同（$2\\mid s-x$）。 最大值最小显然可以二分答案 $mid$，如果我们知道每一位有几个 $1$，就可以贪心地得到答案。每次尽量分给 $&lt;m$ 的数（即没有压上界的），分不下的话剩下的分给前面几位暂时 $=m$ 的数（继续压上界）。 怎么求呢？先令 $b_i$ 的奇偶性和 $x$ 第 $2^i$ 位的奇偶性一样，然后再加上 $(s-x)/2$ 的这一位的两倍（此处十分巧妙，先从 $s$ 中减去 $x$ 来固定奇偶性，然后将剩下的每位都是 $2$ 的倍数的加上）。 我们设第 $i$ 位 $1$ 的个数为 $b_i$，我们先求出一个字典序最大的 $b_i$（即先满足 $b_{60}$ 最大，再满足 $b_{59}$ 最大，…）。那么所有可能的 $\\{b_i\\}$ 即为每次把某个 $u$，$b[u]-=2,b[u-1]+=4$ 就是所有答案（由于奇偶性不能变）。 直接 $dp$ 模拟这个过程。设 $dp[i][j]$ 表示决定好了从高到低的前 $i$ 位，当前有 $j$ 个数已经小于 $m$，这时候 $b[i-1]$ 加多少倍的 $4$ 。 那么当前的 $b[i-1]$ 是 $b_0[i-1]+4\\times dp[i][j]$（$b_0$ 就是初始时的那个字典序最大的 $\\{b_i\\}$），令 $u$ 为当前的 $b[i-1]$。 看 $m$ 的 $2^i$ 位 若为 $0$，就必须把 $u$ 整成不超过 $j$，转移到 $f[i-1][j]$（因为超过 $j$ 的话只能选当前暂时 $=m$，而 $m$ 当前位为 $0$，所以它们当前位不能为 $1$），那么要从当前的 $b$ 减去 $(max(u-j,0)+1)/2\\times 2$（必须减去偶数个，$(x+1)/2\\times 2$ 即为 $\\geq x$ 的最小偶数）。 若为 $1$，如果当前的 $u\\leq n$，那么新的 $j_new=\\max(\\min(n-(u-j),n),j)$ 时（先尽量把 $u$ 放在 $j$ 中，那么剩下的 $u-j$ 个必须为 $1$，它们依旧压上界，其它的可以不压上界）。对于其它的 $j’$，先尽量把 $j’$ 放在 $j$ 中，那么剩下的 $j’-j$ 必须为 $1$，而剩下必须要留下 $u\\bmod 2$ 个。令 $v=n-(j’-j)$，那么当前留下 $\\min(u,(v-u\\bmod 2)/2\\times 2+u\\bmod 2)$。那么当前行都减去 $u-\\min(u,(v-u\\bmod 2)/2\\times 2+u\\bmod 2)$，下一行减去 $2\\min(u,(v-u\\bmod 2)/2\\times 2+u\\bmod 2)$。 注意到：如果有 $f[i][j]=0$ 且 $j\\geq 3$，那么一定有解，因为初始的 $b$ 都不超过 $3$，把这些放到 $j$ 个数中即可；另外一个是我们并不需要用借位一次将 $j$ 增加太多，因为如果借了 $2$，后面就要还 $4$，所以不应该借太多（？）。 因此我们只需要转移到 $j&lt;5$ 或 $j’-j&lt;2$ 的状态，状态数就是 $O(\\log)$ 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/********************************************************************* Problem:Xor Sum Source:Easy Contest #2 - by zzq Author:hydd Date:2020/8/12 Encoding:UTF-8*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cassert&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;const ll INF=2e18;ll n,s,x,t,f[64],g[64];inline void chkmin(ll &amp;x,ll y)&#123; if (x&gt;y) x=y;&#125;bool check(ll mid)&#123; t=s-x; if (t&lt;0||(t&amp;1)) return false; t/=2; f[0]=0; for (ll j=1;j&lt;64;j++) f[j]=INF; ll m=min(3ll,n); for (ll i=59;i&gt;=0;i--)&#123; for (ll j=0;j&lt;64;j++) g[j]=INF; for (ll j=0;j&lt;=m;j++)&#123; ll u=f[j]*4; if (x&amp;1ll&lt;&lt;i) u++;//令b的奇偶性和x那位一样 if (t&amp;1ll&lt;&lt;i) u+=2;//然后再加上(s-x)/2的这一位的两倍 if (mid&amp;(1ll&lt;&lt;i))&#123; if (u&lt;=n)&#123; ll k=max(min(n-(u-j),n),(ll)j);//注意一定要开long long，否则可能越界边负数下面判不掉 if (k&gt;=3) return true; chkmin(g[k],0); &#125; for (int k=j;(k&lt;5||k-j&lt;2)&amp;&amp;k&lt;=n;k++)&#123; ll v=n-(k-j);//先尽量把k放在j中，那么剩下的k-j必须为1 if (v&gt;=u%2)&#123;//至少要留下u%2个数，e必须为偶数，奇偶性不变 ll e=u-min(u,(v-u%2)/2*2+u%2); assert(e%2==0); //当前减去e，下一行减去2e，即4(e/2) chkmin(g[k],e/2); &#125; &#125; &#125; else&#123; ll e=(max(u-j,0ll)+1)/2;//当前有u个数，而剩下不超过j个数，多余的下传 if (e*2&gt;u) continue;//当前减去2e，下一行减去4e，即4(e) chkmin(g[j],e); &#125; &#125; m++; m=min((ll)m,n); swap(f,g); &#125; for (int i=0;i&lt;=m;i++) if (!f[i]) return true; return false;&#125;void solve()&#123; scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;s,&amp;x); ll l=0,r=s+1,mid; while (l&lt;r)&#123; mid=(l+r)&gt;&gt;1; if (check(mid)) r=mid; else l=mid+1; &#125; if (r==s+1) puts(&quot;-1&quot;); else printf(&quot;%lld\\n&quot;,r);&#125;int T;int main()&#123; File(&quot;xs&quot;); scanf(&quot;%d&quot;,&amp;T); while (T--) solve(); return 0;&#125;/*14 8 0*/ Path首先，将它看成在坐标轴上，每次往右上或右下走一格，不能经过 $y=-1$ 和 $y=m-n+1$，问走到 $(n+m,m-n)$ 的方案数。 直接容斥翻折即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#define int long longusing namespace std;typedef long long ll;const int Mod=998244353;int n,m,a,b,tmp1,tmp2,ans;ll inv[20000005];inline int add(int x,int y)&#123; return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123; return x-y&lt;0?x-y+Mod:x-y;&#125;inline int C(int x)&#123; if (x&lt;0) return 0; if (x&gt;n+m) return 0; return inv[x]*inv[n+m-x]%Mod;&#125;signed main()&#123; freopen(&quot;path.in&quot;,&quot;r&quot;,stdin); freopen(&quot;path.out&quot;,&quot;w&quot;,stdout); inv[1]=1; for (int i=2;i&lt;=20000000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=20000000;i++) inv[i]=inv[i-1]*inv[i]%Mod; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); n--; m--; ans=C(m); ll mul=1; for (int i=1;i&lt;=n+m;i++) mul=mul*i%Mod; a=m-n; b=m-n; tmp1=2*(-1); tmp2=2*(m-n+1); for (int i=1;i&lt;=20000000;i++)&#123; if (i&amp;1)&#123; a=tmp1-a;//关于y=-1对称 b=tmp2-b;//关于y=m-n+1对称 &#125; else&#123; a=tmp2-a;//关于y=m-n+1对称 b=tmp1-b;//关于y=-1对称 &#125; if (i&amp;1)&#123; ans=dec(ans,C((a+n+m)&gt;&gt;1)); ans=dec(ans,C((b+n+m)&gt;&gt;1)); &#125; else&#123; ans=add(ans,C((a+n+m)&gt;&gt;1)); ans=add(ans,C((b+n+m)&gt;&gt;1)); &#125; &#125; printf(&quot;%lld\\n&quot;,1ll*ans*mul%Mod); return 0;&#125;/*5000000 10000000100000 200000*/","categories":[{"name":"NOI模拟赛","slug":"NOI模拟赛","permalink":"http://hydd.cf/categories/NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"20200811 zzq模拟赛题解","slug":"sol_8","date":"2020-08-10T16:00:00.000Z","updated":"2020-10-01T05:12:30.440Z","comments":true,"path":"2020/08/11/sol_8/","link":"","permalink":"http://hydd.cf/2020/08/11/sol_8/","excerpt":"","text":"Paint题解 首先可以猜个结论，就是只会不停选相同的格子，将它所在的连通块反色。请读者自行证明。 我们将任意相邻的不为障碍的格子连一条边，同色的边权为 $0$，异色的边权为 $1$。 然后可以发现，将一个格子所在的连通块不停反色，需要的总步数为：以当前格子为起点，到任意非障碍格子的最短距离的最大值。 那么直接从每个点开始 $bfs$ 进行 $0/1$ 最短路即可。时间复杂度 $O(n^2m^2)$。 细节 $bfs$ 的时候，需要注意的是，队列里面存的是一个结构体 node&#123;int x,y;&#125; u;，需要注意必须让 x=u.x,y=u.y ，后面的 nx,ny 才能写成 x+dx[k],y+dy[k]。类似的有 $dfs$ 时的 $v=vet[e]$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;deque&gt;using namespace std;const int INF=0x3f3f3f3f;const int dx[]=&#123;1,0,0,-1&#125;;const int dy[]=&#123;0,1,-1,0&#125;;int n,m; char s[55][55];bool vis[55][55]; int dis[55][55];struct node&#123; int x,y;&#125;;deque&lt;node&gt; q;int bfs(int x,int y)&#123; if (s[x][y]==&#x27;x&#x27;) return INF; memset(vis,false,sizeof(vis)); memset(dis,0x3f,sizeof(dis)); q.push_back((node)&#123;x,y&#125;); dis[x][y]=0; int res=0; while (!q.empty())&#123; node u=q.front(); q.pop_front(); x=u.x; y=u.y; if (vis[x][y]) continue; vis[x][y]=true; res=max(res,dis[x][y]); for (int i=0;i&lt;4;i++)&#123; int nx=u.x+dx[i],ny=u.y+dy[i]; if (nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m||s[nx][ny]==&#x27;x&#x27;) continue; if (s[nx][ny]==s[x][y])&#123; if (dis[x][y]&lt;dis[nx][ny]) dis[nx][ny]=dis[x][y],q.push_front((node)&#123;nx,ny&#125;); &#125;else&#123; if (dis[x][y]+1&lt;dis[nx][ny]) dis[nx][ny]=dis[x][y]+1,q.push_back((node)&#123;nx,ny&#125;); &#125; &#125; &#125; return res;&#125;int main()&#123; freopen(&quot;paint.in&quot;,&quot;r&quot;,stdin); freopen(&quot;paint.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,s[i]+1); int ans=INF,ansx,ansy,tmp; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; tmp=bfs(i,j); if (tmp&lt;ans)&#123; ans=tmp; ansx=i; ansy=j; &#125; &#125; printf(&quot;%d\\n&quot;,ans); for (int i=1;i&lt;=ans;i++) printf(&quot;%d %d\\n&quot;,ansx,ansy); return 0;&#125;/*5 510100xx100111110010000100*/ Chocolate $k\\leq 200$，$n=1,m=k$ 直接一行 $1,1,1,\\cdots 1$ 即可。 $k\\leq 40000$ 且 $k\\bmod 200=1$ 的情况： $k=201$，$n=1,m=200$，直接一行 $2,1,1,\\cdots 1$（只有第一个数为 $2$）即可。 $k=401$，$n=3,m=133$，第一行 $2,1,1,\\cdots 1$（只有第一个数为 $2$），第二、三行 $1,1,1,\\cdots 1$。 $k=601$，$n=2,m=200$，第一行 $2,2,2,\\cdots 2$，第二行 $1,2,1,\\cdots 1$（只有第二个数为 $2$）。 否则，$n=(k-1)/200-1,m=200$，第一行 $2,2,2,\\cdots 2$，第二行 $2,1,1,\\cdots 1$（只有第一个数为 $2$），剩下的行均为 $1,1,1,\\cdots 1$。 当上述情况都不满足时，且 $k&lt;400$： $k=301$，$n=13,m=23$，第一行第一个数为 $2$，网格中其它所有数均为 $1$。 否则，$n=\\lfloor k/100\\rfloor,m=100,y=k\\bmod 100$，第一行前 $y-1(y&gt;0)$ 个数为 $2$，网格中其它所有数均为 $1$。 当上述情况都不满足时，且 $k\\leq 40000$： $n=\\lfloor k/200\\rfloor,m=200,y=k\\bmod 200$，第一行前 $y-1(y&gt;0)$ 个数为 $2$，其它所有数均为 $1$。 当上述情况都不满足时： 首先，将 $k-=40000$。以下构造值域在 $[0,399]$ 之内。 从第一行开始从左到右将 $i(1\\leq i0$，那么修改，并将 $k$ 减去新增加的贡献（对于第一行为 $i+1$，最后一行为 $i-1$，其他行为 $i$）。 从上到下依次改每一行，有个坑点，就是在倒数第二行的时候，第一个位置修改成了 $199$，修改完后 $k=1$，那么第二个位置还是 $0$。 到最后一行的时候，第一个位置为贡献为 $0$，那么变为 $200$，第二个位置贡献为 $1$，那么变为 $199$。然后我们会发现，$199$ 和上面一行的 $0$ 产生了新的贡献。 所以我们需要保证每行的修改右边界单调递减。 其次，如果当前 $k$ 还不 $0$。那么从左往右考虑每一列，然后从上到下，第一个数 $+199$，第二个数 $+198$，以此类推，类似于行的情况，只是贡献固定为 $i$。 就做完了，输出的时候 $+1$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;cstdio&gt;#include&lt;cassert&gt;#include&lt;iostream&gt;using namespace std;int T,k,kk,a[810][210];inline int check(int n, int m)&#123; if (n&gt;200||m&gt;200) return -1; int res = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; ++res; if (j != m &amp;&amp; a[i][j] != a[i][j + 1]) ++res; for (int k = j + 2; k &lt;= m; ++k) if (1LL * (a[i][k] - a[i][k - 1]) * (a[i][k - 1] - a[i][k - 2]) &gt; 0) ++res; else break; &#125; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) &#123; if (j != n &amp;&amp; a[j][i] != a[j + 1][i]) ++res; for (int k = j + 2; k &lt;= n; ++k) if (1LL * (a[k][i] - a[k - 1][i]) * (a[k - 1][i] - a[k - 2][i]) &gt; 0) ++res; else break; &#125; cerr&lt;&lt;res&lt;&lt;&#x27; &#x27;&lt;&lt;kk&lt;&lt;endl; return res;&#125;void solve1()&#123; printf(&quot;1 %d\\n&quot;,k); for (int j=1;j&lt;k;j++) printf(&quot;1 &quot;); printf(&quot;1\\n&quot;); assert(check(1,k)==kk);&#125;void solve2()&#123; if (k==201)&#123; a[1][1]=1; printf(&quot;1 200\\n&quot;); for (int j=1;j&lt;200;j++) printf(&quot;%d &quot;,a[1][j]+1); printf(&quot;%d\\n&quot;,a[1][200]+1); assert(check(1,200)==kk); return; &#125; if (k==401)&#123; a[1][1]=1; printf(&quot;3 133\\n&quot;); for (int i=1;i&lt;=3;i++)&#123; for (int j=1;j&lt;133;j++) printf(&quot;%d &quot;,a[i][j]+1); printf(&quot;%d\\n&quot;,a[i][133]+1); &#125; assert(check(3,133)==kk); return; &#125; if (k==601)&#123; for (int j=1;j&lt;=200;j++) a[1][j]=1; a[2][2]=1; printf(&quot;2 200\\n&quot;); for (int i=1;i&lt;=2;i++)&#123; for (int j=1;j&lt;200;j++) printf(&quot;%d &quot;,a[i][j]+1); printf(&quot;%d\\n&quot;,a[i][200]+1); &#125; assert(check(2,200)==kk); return; &#125; int x=k/200-1; for (int j=1;j&lt;=200;j++) a[1][j]=1; a[2][1]=1; printf(&quot;%d 200\\n&quot;,x); for (int i=1;i&lt;=x;i++)&#123; for (int j=1;j&lt;200;j++) printf(&quot;%d &quot;,a[i][j]+1); printf(&quot;%d\\n&quot;,a[i][200]+1); &#125; assert(check(x,200)==kk);&#125;void solve3()&#123; if (k==301)&#123; a[1][1]=1; printf(&quot;13 23\\n&quot;); for (int i=1;i&lt;=13;i++)&#123; for (int j=1;j&lt;23;j++) printf(&quot;%d &quot;,a[i][j]+1); printf(&quot;%d\\n&quot;,a[i][23]+1); &#125; assert(check(13,23)==kk); return; &#125; int x=k/100,y=k%100; if (y)&#123; y--; for (int j=1;j&lt;=y;j++) a[1][j]=1; &#125; printf(&quot;%d 100\\n&quot;,x); for (int i=1;i&lt;=x;i++)&#123; for (int j=1;j&lt;100;j++) printf(&quot;%d &quot;,a[i][j]+1); printf(&quot;%d\\n&quot;,a[i][100]+1); &#125; assert(check(x,100)==kk);&#125;void solve4()&#123; int x=k/200,y=k%200; if (y)&#123; y--; for (int j=1;j&lt;=y;j++) a[1][j]=1; &#125; printf(&quot;%d 200\\n&quot;,x); for (int i=1;i&lt;=x;i++)&#123; for (int j=1;j&lt;200;j++) printf(&quot;%d &quot;,a[i][j]+1); printf(&quot;%d\\n&quot;,a[i][200]+1); &#125; assert(check(x,200)==kk);&#125;/*void solve5()&#123; int now=0,tmp; for (int i=200;i&gt;=1;i--)&#123; tmp=100*(i*i+202*i+2)+200; cerr&lt;&lt;tmp&lt;&lt;&#x27; &#x27;&lt;&lt;now&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl; while (tmp+399+400+200+200&lt;=k)&#123; for (int y=1;y&lt;=200;y++) a[now+1][y]=1; for (int x=1;x&lt;=i;x++) for (int y=1;y&lt;=200;y++) a[now+x+1][y]=x+y+1; now+=(i+1); k-=tmp; &#125; &#125; int nnn=1; if ((k-400-200-200)%399==1) nnn=a[now][1]-1,k++; while (k-400-200-200&gt;=399)&#123; k-=399; now++; for (int y=1;y&lt;=200;y++) a[now][y]=nnn+(y&amp;1); &#125; k-=400; now++; for (int y=1;y&lt;=200;y++) a[now][y]=nnn+2; k-=200; now++; for (int y=1;y&lt;=200;y++) a[now][y]=nnn+2; k-=200; now++; for (int y=1;y&lt;=200;y++) a[now][y]=nnn+2; if (k&gt;=200)&#123; k-=200; now++; for (int y=1;y&lt;=200;y++) a[now][y]=nnn+2; &#125; for (int y=1;y&lt;k;y++) a[now][y]++; printf(&quot;%d 200\\n&quot;,now); for (int i=1;i&lt;=now;i++)&#123; for (int j=1;j&lt;200;j++) printf(&quot;%d &quot;,a[i][j]); printf(&quot;%d\\n&quot;,a[i][200]); &#125; assert(check(now,200)==kk);&#125;*/void solve5()&#123; k-=40000; int lst=200; for (int i=1;i&lt;=200;i++)&#123; for (int j=1;j&lt;lst;j++)&#123; if (j+(i==1)-(i==200)&gt;k)&#123; lst=j; break;&#125; a[i][j]=200-j; k-=j+(i==1)-(i==200); &#125; &#125; /*for (int i=1;i&lt;=200;i++)&#123; for (int j=1;j&lt;200;j++) printf(&quot;%d &quot;,a[i][j]+1); printf(&quot;%d\\n&quot;,a[i][200]+1); &#125; check(200,200);*/ if (k) for (int j=1;j&lt;=200;j++) for (int i=1;i&lt;200;i++)&#123; if (i&gt;k) break; a[i][j]+=200-i; k-=i; &#125; puts(&quot;200 200&quot;); for (int i=1;i&lt;=200;i++)&#123; for (int j=1;j&lt;200;j++) printf(&quot;%d &quot;,a[i][j]+1); printf(&quot;%d\\n&quot;,a[i][200]+1); &#125; assert(check(200,200)==kk);&#125;int main()&#123; freopen(&quot;choco.in&quot;,&quot;r&quot;,stdin); freopen(&quot;choco.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%d&quot;,&amp;k); kk=k; for (int i=1;i&lt;=200;i++) for (int j=1;j&lt;=200;j++) a[i][j]=0; if (k&lt;=200) solve1(); else if (k%200==1&amp;&amp;k&lt;=40000) solve2(); else if (k&lt;400) solve3(); else if (k&lt;=40000) solve4(); else solve5(); &#125; return 0;&#125;","categories":[{"name":"NOI模拟赛","slug":"NOI模拟赛","permalink":"http://hydd.cf/categories/NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"正睿暑期AB班 题解","slug":"sol_11","date":"2020-08-06T16:00:00.000Z","updated":"2020-10-01T04:57:28.418Z","comments":true,"path":"2020/08/07/sol_11/","link":"","permalink":"http://hydd.cf/2020/08/07/sol_11/","excerpt":"","text":"day1B 某奇怪的论文？https://www.academia.edu/7310919/Enumeration_of_0_1_matrices_avoiding_some_2x2_matrices。相当于原矩形不存在论文第一页中的 $I$ 这个子矩阵（这里的子矩阵不需要连续，相当于选定 $x_1\\neq x_2,y_1\\neq y_2$，组合得到的 $4$ 个点就是子矩阵）。那么 Proposition2.2 中的 $B_n^{-k}$ 即为答案。 $NTT$ 求出斯特林数即可。 时间复杂度 $O(n\\log n)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/********************************************************************* Problem:W2B Author:hydd Date:2020/7/28*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int g=3;const int Mod=998244353;const int MAXN=1100000;ll fac[MAXN],inv[MAXN];inline ll qpow(ll x,int a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;struct S2&#123; int n,m,N,len,rev[MAXN]; ll a[MAXN],b[MAXN],c[MAXN]; inline int getinv(int x)&#123; return qpow(x,Mod-2);&#125; void NTT(ll *a,int inv)&#123; for (int i=0;i&lt;n;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;n;mid&lt;&lt;=1)&#123; int tmp=qpow(g,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;n;i+=mid*2)&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=omega*tmp%Mod)&#123; int x=a[i+j],y=omega*a[i+j+mid]%Mod; a[i+j]=(x+y)%Mod,a[i+j+mid]=(x-y+Mod)%Mod; &#125; &#125; &#125; &#125; void main(int nnn)&#123; n=nnn+1; N=n; ll op=1,mul=1; for (int i=0;i&lt;n;i++)&#123; if (i) mul=mul*i%Mod; ll inv=getinv(mul); a[i]=inv*op%Mod; b[i]=qpow(i,n-1)*inv%Mod; op=Mod-op; &#125; len=(n&lt;&lt;1)-1; int bit=0; while ((1&lt;&lt;bit)&lt;len) bit++; n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,1); NTT(b,1); for (int i=0;i&lt;n;i++) a[i]=a[i]*b[i]%Mod; NTT(a,-1); ll inv=getinv(n); for (int i=0;i&lt;N;i++) c[i]=a[i]*inv%Mod; &#125;&#125; tmp1,tmp2;int n,m;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); tmp1.main(n+1); tmp2.main(m+1); fac[0]=1; for (int i=1;i&lt;=min(n,m)+1;i++) fac[i]=fac[i-1]*i%Mod; ll ans=0; for (int k=0;k&lt;=min(n,m);k++) ans=(ans+fac[k]*fac[k]%Mod*tmp1.c[k+1]%Mod*tmp2.c[k+1])%Mod; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; A 不难发现积水的区域形成了⼀个树状结构，树上的每个节点对应着⼀个连通块。每个区间都有⼀个高度范围，具体来说，范围是[该区间内的最大海拔，父区间的最大海拔]。 不难发现海绵一定放在叶子结点最优，所以海绵吸⾛的是⼀条从叶子到根的路径上的水。 问题相当于每次操作可以删去某个叶子到根的所有数字，要求删的数的和尽量大。删的⼀定是长链剖分上的⼀条链。若从高到低求树状结构，需要维护删去格子后的连通性，不好做。考虑从低到高加入格子，用并查集维护连通块，这样可以很方便地得知当前格子将哪些连通块并成了⼀个大连通块。 复杂度 $O(nm\\log nm)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/********************************************************************* Problem:H2O Author:hydd Date:2020/7/28*********************************************************************/#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;typedef long long ll;int n,m,K,fa[1100000],sz[1100000],mxdep[1100000];int cnt; ll sum[1100000],a[1100000];const int dx[4]=&#123;1,-1,0,0&#125;;const int dy[4]=&#123;0,0,1,-1&#125;;vector&lt;int&gt; son[1100000];inline int hs(int x,int y)&#123; return (x-1)*m+y;&#125;int findset(int x)&#123; if (x!=fa[x]) fa[x]=findset(fa[x]); return fa[x];&#125;void Union(int &amp;x,int y,int d)&#123; y=findset(y); if (x==y) return; sum[y]+=1ll*sz[y]*(d-mxdep[y]); mxdep[y]=d; if (sum[y]&gt;sum[x])&#123; int tmp=x; x=y; y=tmp;&#125; if (sum[x]) a[++cnt]=sum[y]; fa[y]=x; sz[x]+=sz[y];&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K); int u,mx=0; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; scanf(&quot;%d&quot;,&amp;u); son[u].push_back(hs(i,j)); mx=max(mx,u); &#125; for (int i=1;i&lt;=mx;i++) for (int u:son[i])&#123; int x=(u-1)/m+1,y=(u-1)%m+1; mxdep[u]=i; fa[u]=u; int nx,ny; for (int k=0;k&lt;4;k++)&#123; nx=x+dx[k]; ny=y+dy[k]; if (nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m||!mxdep[hs(nx,ny)]) continue; Union(u,hs(nx,ny),i); &#125; sz[u]++; &#125; sort(a+1,a+cnt+1,greater&lt;int&gt;()); for (int i=cnt;i&gt;=1;i--) a[i]+=a[i+1]; ll ans=0; for (int i=1;i&lt;=K&amp;&amp;i&lt;=cnt;i++) ans^=a[i]; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; day2C 写了很长时间的遗传，发现只有 $80pts$（而且 $7,8$ 跑了 $1000s$）。 然后发现暴力就可过？就是可以依次枚举，过程中记录每个点还能用哪些颜色。可以从度数大的开始枚举，这样得到的信息就比较多，每个位置可用颜色就比较少。然后就过了。 正解是先随机赋颜色。然后不停调整点的颜色使同色边尽可能小，有多种方案随机选。（如果长时间调整不出可以多换几个点的颜色，个人认为还是类似于遗传中的变异？）但由于数据水，不需要调整就过了。 A 先讲讲一种奇怪的做法。 首先，我们考虑 $l$ 的答案，先将它往左延伸直到不能延伸，设延伸到了 $x$，然后再看后面能有多少个位置也可以加入，设加到了 $r$。 延伸的过程就是只要和当前的 $p$ 有一维相等，就延伸。否则若 $p$ 还有未确定的维，就选一个维，将它赋值成现在这个点的那一维。没有的话就不能延伸了。 那么 $[l,r]$ 为右端点的段最长只能到最左边的 $x$。然后继续考虑 $r+1$ 。 可以发现 $x$ 不会小于上一次的 $l$，所以每个段最多会经过两次（当前用 $r$ 经过一次，下一次用 $x$ 经过一次）。 时间复杂度 $O(n k! k)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/********************************************************************* Problem:stars Author:hydd Date:2020/7/29*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;typedef long long ll;int n,K,a[110000][6],num[110000];bool check(int u)&#123; for (int i=0;i&lt;K;i++) if (a[u][i]==num[i]) return true; return false;&#125;int getl(int u)&#123; if (!u) return u; if (check(u)) return getl(u-1); int ans=u; for (int i=0;i&lt;K;i++) if (num[i]==-1)&#123; num[i]=a[u][i]; ans=min(ans,getl(u-1)); num[i]=-1; &#125; return ans;&#125;int getr(int u)&#123; if (u==n+1) return u; if (check(u)) return getr(u+1); int ans=u; for (int i=0;i&lt;K;i++) if (num[i]==-1)&#123; num[i]=a[u][i]; ans=max(ans,getr(u+1)); num[i]=-1; &#125; return ans;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;K); for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;K;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); memset(num,-1,sizeof(num)); ll ans=0; for (int l=1,r;l&lt;=n;l=r+1)&#123; int x=getl(l)+1; r=getr(x)-1; for (int i=l;i&lt;=r;i++) ans+=(1ll*(1+i-x+1)*(i-x+1)&gt;&gt;1); &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; 正解就是一个 $dp$，比较复杂，就不详细讲了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/********************************************************************* Problem:stars Author:hydd Date:2020/7/29*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int n,m;int a[110000][5],vis[110000],dp[110000][410],cnt;vector&lt;int&gt; Now,p[410],vec_S[410],vec_SrT[410];void dfs(int k)&#123; p[cnt++]=Now; for (int i=1;i&lt;=k;i++) if (!vis[i])&#123; vis[i]=true; Now.push_back(i); dfs(k); vis[i]=false; Now.pop_back(); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); dfs(m); for (int i=1;i&lt;cnt;i++)&#123; vector&lt;int&gt; S,SrT=p[i]; for (int j=0;j&lt;(int)p[i].size();j++)&#123; vec_S[i].push_back(find(p,p+cnt,S)-p); vec_SrT[i].push_back(find(p,p+cnt,SrT)-p); if (j&lt;(int)p[i].size()-1) swap(SrT[j],SrT[j+1]); S.push_back(SrT[j]); &#125; &#125; ll ans=0; for (int i=0;i&lt;cnt;i++) dp[n+1][i]=n+1; for (int i=n;i&gt;=1;i--)&#123; int r=i; dp[i][0]=i; for (int j=1;j&lt;cnt;j++)&#123; int flg=false; for (int k=0;k&lt;(int)p[j].size()&amp;&amp;!flg;k++) if (a[i][p[j][0]]==a[dp[i+1][vec_S[j][k]]][p[j][0]])&#123; dp[i][j]=dp[i+1][vec_SrT[j][k]]; flg=true; &#125; if (!flg) dp[i][j]=dp[i+1][vec_S[j].back()]; r=max(r,dp[i][j]); &#125; ans+=(1ll*(r-i)*(r-i+1)&gt;&gt;1); &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; day3A 直接笛卡尔树，然后将前缀和取模加入哈希表。 每次枚举笛卡尔树上较短的一边，枚举答案，查询需要的值是不是在较大的一边出现即可。 时间复杂度 $O(n\\log^2 n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/********************************************************************* Problem:Good Subsegments Author:hydd Date:2020/7/30*********************************************************************/#include&lt;cstdio&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;typedef long long ll;const ll Mod=1000000000000000003ll;int n,ans,a[210000],pos[20][210000],Log2[210000];ll b[210000],sum[210000];const int hashMod=800009;struct hashMap&#123; struct node&#123; ll v; int p; node()&#123;&#125; node(ll vv,int pp)&#123; v=vv; p=pp;&#125; &#125; vet[210000]; int edgenum,Next[210000],Head[hashMod]; void ins(ll v,int p)&#123; int u=v%hashMod; vet[++edgenum]=node(v,p); Next[edgenum]=Head[u]; Head[u]=edgenum; &#125; int find(ll x)&#123; int u=x%hashMod; for (int e=Head[u];e;e=Next[e]) if (vet[e].v==x) return vet[e].p; return 0; &#125;&#125; S;inline ll add(ll x,ll y)&#123; if (x+y&gt;=Mod) return x+y-Mod; return x+y;&#125;inline ll dec(ll x,ll y)&#123; if (x&lt;y) return x-y+Mod; return x-y;&#125;inline ll mul(ll x,ll y)&#123; ll ret=x*y-((ll)((long double)x/Mod*y+0.5))*Mod; return (ret%Mod+Mod)%Mod;&#125;void RMQ_init()&#123; for (int i=1;i&lt;=n;i++) pos[0][i]=i; for (int j=1;(1&lt;&lt;j)&lt;=n;j++) for (int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) if (a[pos[j-1][i]]&gt;a[pos[j-1][i+(1&lt;&lt;(j-1))]]) pos[j][i]=pos[j-1][i]; else pos[j][i]=pos[j-1][i+(1&lt;&lt;(j-1))];&#125;int RMQ_query(int l,int r)&#123; int k=Log2[r-l+1]; if (a[pos[k][l]]&gt;a[pos[k][r-(1&lt;&lt;k)+1]]) return pos[k][l]; else return pos[k][r-(1&lt;&lt;k)+1];&#125;ll qpow(ll x,int a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=mul(res,x); x=mul(x,x); a&gt;&gt;=1; &#125; return res;&#125;void solve(int l,int r)&#123; if (l==r) ans++; if (l&gt;=r) return; int x=RMQ_query(l,r); if (x-l&lt;r-x)&#123; for (int i=x;i&gt;=l;i--)&#123; ll p=b[x],tmp; int loc; for (int j=0;j&lt;=19;j++)&#123; tmp=add(p,sum[i-1]); loc=S.find(tmp)-1; if (x&lt;=loc&amp;&amp;loc&lt;=r) ans++; p=add(p,p); &#125; &#125; &#125; else&#123; for (int i=x;i&lt;=r;i++)&#123; ll p=b[x],tmp; int loc; for (int j=0;j&lt;=19;j++)&#123; tmp=dec(sum[i],p); loc=S.find(tmp); if (l&lt;=loc&amp;&amp;loc&lt;=x) ans++; p=add(p,p); &#125; &#125; &#125; solve(l,x-1); solve(x+1,r);&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); Log2[1]=0; for (int i=2;i&lt;=200000;i++) Log2[i]=Log2[i&gt;&gt;1]+1; S.ins(0,1); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); b[i]=qpow(2,a[i]); sum[i]=add(sum[i-1],b[i]); S.ins(sum[i],i+1);// printf(&quot;%d\\n&quot;,S.find(sum[i])); &#125; RMQ_init(); solve(1,n); printf(&quot;%d\\n&quot;,ans); return 0;&#125; C 最优状态只能是 $(1,\\frac{n+1}2+1),(2,\\frac{n+1}2+2),\\cdots,(\\frac{n-1}2,n)$ 它们之间连边。 答案随便算即可。 1234567891011121314151617181920212223242526272829/********************************************************************* Problem:Funny Cost Author:hydd Date:2020/7/30*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;typedef long long ll;const int Mod=998244353;int n,a[210000];ll fac[210000],inv[210000];inline ll C(int n,int m)&#123; if (n&lt;m) return 0; return fac[n]*inv[m]%Mod*inv[n-m]%Mod;&#125;int main()&#123; fac[0]=1; for (int i=1;i&lt;=200000;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=200000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=200000;i++) inv[i]=inv[i-1]*inv[i]%Mod; scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); ll ans=0; for (int i=1;i&lt;=n;i++) ans=(ans+1ll*C(i-1,(n-1)/2)*a[i])%Mod; printf(&quot;%lld\\n&quot;,1ll*fac[(n+1)/2]*fac[(n+1)/2]%Mod*ans%Mod); return 0;&#125; day4C 我们选择一个素数 $p$，若 $i,j$ 不满足 $x_ix_j+y_iy_j\\equiv k\\pmod p$ ，那么必没有 $x_ix_j+y_iy_j=k$。 先求出满足 $0\\leq a,b,c,d&lt;p$ 的四元组 $(a,b,c,d)$，那么若有 $x_ix_j+y_iy_j\\equiv k\\pmod p$，必存在 $a,b,c,d$，满足 $(x_i\\bmod p,y_i\\bmod p,x_j\\bmod p,y_j\\bmod p)=(a,b,c,d)$ 。 那么，我们将所有 $(x_i\\bmod p,y_i\\bmod p)$ 加入数组。然后枚举所有 $(a,b,c,d)$，对于 $(x_i\\bmod p,y_i\\bmod p)=(a,b),(x_j\\bmod p,y_i\\bmod p)=(c,d)$ 再暴力判断。 尝试可以发现 $p=97$ 较优。注意，不需要枚举 $d$，因为 $d\\equiv -\\frac{ac}b \\pmod b$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/********************************************************************* Problem:Exercise Author:hydd Date:2020/7/31*********************************************************************/#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;typedef long long ll;const int Mod=97;int n,A[210000],B[210000];int edgenum,vet[210000],Next[210000],Head[Mod*Mod];ll k;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ll readll()&#123; ll x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;int gcd(int x,int y)&#123; if (!y) return x; return gcd(y,x%y);&#125;inline int hs(int x,int y)&#123; return x%Mod*Mod+y%Mod;&#125;void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;int qpow(int x,int a)&#123; int res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;void calc(int a,int b,int c,int d)&#123; if ((a*c+b*d)%Mod!=k%Mod) return; int p=a*Mod+b,q=c*Mod+d,x,y; for (int u=Head[p];u;u=Next[u]) for (int v=Head[q];v;v=Next[v])&#123; x=vet[u]; y=vet[v]; if (1ll*A[x]*A[y]+1ll*B[x]*B[y]==k)&#123; printf(&quot;%d %d\\n&quot;,x,y); exit(0); &#125; &#125;&#125;void work()&#123; for (int a=0;a&lt;Mod;++a)&#123; for (int b=1;b&lt;Mod;++b) for (int c=0;c&lt;Mod;++c)&#123; int d=(1ll*(k%Mod-a*c)*qpow(b,Mod-2)%Mod+Mod)%Mod; calc(a,b,c,d); &#125; int b=0; for (int c=0;c&lt;Mod;++c) for (int d=0;d&lt;Mod;++d) calc(a,b,c,d); &#125;&#125;int main()&#123;// File(&quot;data2&quot;); n=read(); k=readll(); int g; for (int i=1;i&lt;=n;++i)&#123; A[i]=read(); B[i]=read(); g=gcd(A[i],B[i]); if (k%g) continue; addedge(hs(A[i],B[i]),i); &#125; work(); return 0;&#125; B 首先我们设 $dp_i$ 表示前 $i$ 个数分段排好序的最小代价，$dp_i=x+\\min_{j&lt;i}dp_j+calc(j+1,i)$。（其中 $calc(l,r)$ 表示 $a_l,a_{l+1},\\cdots,a_r$ 的逆序对数。 首先，根据 $dp$ 的定义，可以显然的发现决策单调性。证明的话可以直接考虑所有 $dp_j(j&lt;i)$ 的 $dp_i$ 的贡献，显然随着 $i$ 增大，$\\Delta dp_1\\geq \\Delta dp_2\\geq \\cdots \\geq \\Delta dp_{i-1}$。那么显然是决策单调的。 但是，由于是 $1D$ 的 $dp$，后面的 $dp$ 值依赖前面的 $dp$ 值。但是我们可以类似于分治 $FFT$ 那样，外面套一层 $CDQ$ 分治，再递归的过程中，求出了 $[l,mid]$ 的 $dp$ 值，先将 $[mid+1,r]$ 通过 $[l,mid]$ 更新，然后继续递归 $[mid+1,r]$ 求出 $dp$ 值。 $[mid+1,r]$ 通过 $[l,mid]$ 更新的时候，前面的 $dp$ 值就已经算出来了，可以直接分治。 维护逆序对数可以类似于莫队一样的移动，可以证明移动的步数是 $O(n\\log n)$ 级别。每次移动暴力树状数组插入删除，时间复杂度 $O(\\log n)$。 总时间复杂度 $O(n \\log^3 n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/********************************************************************* Problem:Dispatch Money Author:hydd Date:2020/7/31*********************************************************************/#include&lt;cstdio&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)#define ADD_Left() L--,num+=R-L-query(p[L]),add(p[L],1);#define ADD_Right() R++,num+=query(p[R]),add(p[R],1);#define DEL_Left() add(p[L],-1),num-=R-L-query(p[L]),L++;#define DEL_Right() add(p[R],-1),num-=query(p[R]),R--;using namespace std;typedef long long ll;const ll INF=1ll&lt;&lt;60;int n,k,p[310000],tree[310000];int L,R; ll num,f[310000];void add(int x,int y)&#123; for (;x;x-=x&amp;-x) tree[x]+=y;&#125;int query(int x)&#123; int res=0; for (;x&lt;=n;x+=x&amp;-x) res+=tree[x]; return res;&#125;void sol(int l,int r,int x,int y)&#123; if (l&gt;r) return; int mid=(l+r)&gt;&gt;1; while (L&gt;x+1) ADD_Left(); while (R&lt;mid) ADD_Right(); while (L&lt;x+1) DEL_Left(); while (R&gt;mid) DEL_Right(); ll now=f[mid]; int m=x; for (int i=x;i&lt;=y;i++)&#123; if (f[i]+num+k&lt;now)&#123; now=f[i]+num+k; m=i;&#125; DEL_Left(); &#125; f[mid]=now; sol(l,mid-1,x,m); sol(mid+1,r,m,y);&#125;void solve(int l,int r)&#123; if (l==r) return; int mid=(l+r)&gt;&gt;1; solve(l,mid); sol(mid+1,r,l,mid); solve(mid+1,r);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;p[i]),f[i]=INF; L=1; R=0; solve(0,n); printf(&quot;%lld\\n&quot;,f[n]); return 0;&#125; A 题目要求我们找到一个边集，使得所有顶点的度数 $\\leq 2$，并且所有度数为 $1$ 的顶点都有标记，使得它们的权值和应该尽可能大。 让我们将每个顶点 $v$ 分成两个点 $(v,0)$ 和 $(v,1)$，并在 $(v,0)$ 和 $(v,1)$ 之间添加一条边权为 $0$ 的边。 $(u,v)$ 是白色边，在 $(u,0)$ 和 $(v,0)$ 之间添加一条边权为 $0$ 的边。 $(u,v)$ 是黑色边，在 $(u,1)$ 和 $(v,1)$ 之间添加一条边权为 $0$ 的边。 对于被标记的顶点 $v$，创建一个顶点 $(v,2)$，并在 $(v,2)$ 和 $(v,0)$ 之间以及 $(v,2)$ 和 $(v,1)$ 之间添加边，权重为 $w_v$。 直接最大权最大匹配即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include&lt;bits/stdc++.h&gt;#define DIST(e) (lab[e.u]+lab[e.v]-g[e.u][e.v].w*2)using namespace std;typedef long long ll;const int N=1023,INF=1e6;struct Edge&#123; int u,v,w;&#125; g[N][N];int n,m,k,n_x,lab[N],match[N],slack[N],st[N],pa[N],flower_from[N][N],S[N],vis[N];vector&lt;int&gt; flower[N];deque&lt;int&gt; q;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void update_slack(int u,int x)&#123; if (!slack[x]||DIST(g[u][x])&lt;DIST(g[slack[x]][x])) slack[x]=u;&#125;void set_slack(int x)&#123; slack[x]=0; for (int u=1;u&lt;=n;++u) if (g[u][x].w&gt;0&amp;&amp;st[u]!=x&amp;&amp;S[st[u]]==0) update_slack(u,x);&#125;void q_push(int x)&#123; if (x&lt;=n) return q.push_back(x); for (int i=0;i&lt;(int)flower[x].size();i++) q_push(flower[x][i]);&#125;void set_st(int x,int b)&#123; st[x]=b; if (x&lt;=n) return; for (int i=0;i&lt;(int)flower[x].size();++i) set_st(flower[x][i],b);&#125;int get_pr(int b,int xr)&#123; int pr=find(flower[b].begin(),flower[b].end(),xr)-flower[b].begin(); if (pr%2==1)&#123; reverse(flower[b].begin()+1,flower[b].end()); return (int)flower[b].size()-pr; &#125; else return pr;&#125;void set_match(int u,int v)&#123; match[u]=g[u][v].v; if (u&lt;=n) return; Edge e=g[u][v]; int xr=flower_from[u][e.u],pr=get_pr(u,xr); for (int i=0;i&lt;pr;++i) set_match(flower[u][i],flower[u][i^1]); set_match(xr,v); rotate(flower[u].begin(),flower[u].begin()+pr,flower[u].end());&#125;void augment(int u,int v)&#123; int xnv=st[match[u]]; set_match(u,v); if (!xnv) return; set_match(xnv,st[pa[xnv]]); augment(st[pa[xnv]],xnv);&#125;int get_lca(int u,int v)&#123; static int t=0; for (++t;u||v;swap(u,v))&#123; if (u==0) continue; if (vis[u]==t) return u; vis[u]=t; u=st[match[u]]; if (u) u=st[pa[u]]; &#125; return 0;&#125;void add_blossom(int u,int lca,int v)&#123; int b=n+1; while (b&lt;=n_x&amp;&amp;st[b]) ++b; if (b&gt;n_x) ++n_x; lab[b]=0,S[b]=0; match[b]=match[lca]; flower[b].clear(); flower[b].push_back(lca); for (int x=u,y;x!=lca;x=st[pa[y]]) flower[b].push_back(x),flower[b].push_back(y=st[match[x]]),q_push(y); reverse(flower[b].begin()+1,flower[b].end()); for (int x=v,y;x!=lca;x=st[pa[y]]) flower[b].push_back(x),flower[b].push_back(y=st[match[x]]),q_push(y); set_st(b,b); for (int x=1;x&lt;=n_x;++x) g[b][x].w=g[x][b].w=0; for (int x=1;x&lt;=n;++x) flower_from[b][x]=0; for (int i=0;i&lt;(int)flower[b].size();++i)&#123; int xs=flower[b][i]; for (int x=1;x&lt;=n_x;++x) if (g[b][x].w==0||DIST(g[xs][x])&lt;DIST(g[b][x])) g[b][x]=g[xs][x],g[x][b]=g[x][xs]; for (int x=1;x&lt;=n;++x) if (flower_from[xs][x]) flower_from[b][x]=xs; &#125; set_slack(b);&#125;void expand_blossom(int b)&#123;//S[b]==1 for (int i=0;i&lt;(int)flower[b].size();++i) set_st(flower[b][i],flower[b][i]); int xr=flower_from[b][g[b][pa[b]].u],pr=get_pr(b,xr); for (int i=0;i&lt;pr;i+=2)&#123; int xs=flower[b][i],xns=flower[b][i+1]; pa[xs]=g[xns][xs].u; S[xs]=1,S[xns]=0; slack[xs]=0,set_slack(xns); q_push(xns); &#125; S[xr]=1,pa[xr]=pa[b]; for (int i=pr+1;i&lt;(int)flower[b].size();++i)&#123; int xs=flower[b][i]; S[xs]=-1,set_slack(xs); &#125; st[b]=0;&#125;bool on_found_Edge(const Edge &amp;e)&#123; int u=st[e.u],v=st[e.v]; if (S[v]==-1)&#123; pa[v]=e.u,S[v]=1; int nu=st[match[v]]; slack[v]=slack[nu]=0; S[nu]=0,q_push(nu); &#125; else if (S[v]==0)&#123; int lca=get_lca(u,v); if (!lca) return augment(u,v),augment(v,u),1; else add_blossom(u,lca,v); &#125; return 0;&#125;bool matching()&#123; fill(S,S+n_x+1,-1),fill(slack,slack+n_x+1,0); q.clear(); for (int x=1;x&lt;=n_x;++x) if (st[x]==x&amp;&amp;!match[x]) pa[x]=0,S[x]=0,q_push(x); if (q.empty()) return 0; for (;;)&#123; while (q.size())&#123; int u=q.front(); q.pop_front(); if (S[st[u]]==1) continue; for (int v=1;v&lt;=n;++v) if (g[u][v].w&gt;0&amp;&amp;st[u]!=st[v])&#123; if (DIST(g[u][v])==0)&#123; if (on_found_Edge(g[u][v])) return 1; &#125; else update_slack(u,st[v]); &#125; &#125; int d=1e9; for (int b=n+1;b&lt;=n_x;++b) if (st[b]==b&amp;&amp;S[b]==1) d=min(d,lab[b]/2); for (int x=1;x&lt;=n_x;++x) if (st[x]==x&amp;&amp;slack[x])&#123; if (S[x]==-1) d=min(d,DIST(g[slack[x]][x])); else if (S[x]==0) d=min(d,DIST(g[slack[x]][x])/2); &#125; for (int u=1;u&lt;=n;++u)&#123; if (S[st[u]]==0)&#123; if (lab[u]&lt;=d) return 0; lab[u]-=d; &#125; else if (S[st[u]]==1) lab[u]+=d; &#125; for (int b=n+1;b&lt;=n_x;++b) if (st[b]==b)&#123; if (S[st[b]]==0) lab[b]+=d*2; else if (S[st[b]]==1) lab[b]-=d*2; &#125; q.clear(); for (int x=1;x&lt;=n_x;++x) if (st[x]==x&amp;&amp;slack[x]&amp;&amp;st[slack[x]]!=x&amp;&amp;DIST(g[slack[x]][x])==0) if (on_found_Edge(g[slack[x]][x])) return 1; for (int b=n+1;b&lt;=n_x;++b) if (st[b]==b&amp;&amp;S[b]==1&amp;&amp;lab[b]==0) expand_blossom(b); &#125; return 0;&#125;pair&lt;ll,int&gt; weight_blossom()&#123; fill(match,match+n+1,0); n_x=n; int n_matches=0; ll tot_weight=0; for (int u=0;u&lt;=n;++u) st[u]=u,flower[u].clear(); int w_max=0; for (int u=1;u&lt;=n;++u) for (int v=1;v&lt;=n;++v)&#123; flower_from[u][v]=(u==v?u:0); w_max=max(w_max,g[u][v].w); &#125; for (int u=1;u&lt;=n;++u) lab[u]=w_max; while (matching()) ++n_matches; for (int u=1;u&lt;=n;++u) if (match[u]&amp;&amp;match[u]&lt;u) tot_weight+=g[u][match[u]].w; return make_pair(tot_weight,n_matches);&#125;int main()&#123; n=read(); m=read(); for (int u=1;u&lt;=n+n+n;++u) for (int v=1;v&lt;=n+n+n;++v) g[u][v]=Edge&#123;u,v,0&#125;; for (int i=1;i&lt;=n;++i)&#123; g[i][i+n].w=INF*2; g[i+n][i].w=INF*2; &#125; for (int i=0,u,v,w;i&lt;m;++i)&#123; u=read(); v=read(); w=read(); g[u+w*n][v+w*n].w=INF*2; g[v+w*n][u+w*n].w=INF*2; &#125; k=read(); for (int i=1,x,v;i&lt;=k;++i)&#123; x=read(); v=read(); g[x][x+n+n].w=max(INF+v,g[x][x+n+n].w); g[x+n+n][x].w=max(INF+v,g[x+n+n][x].w); g[x+n][x+n+n].w=max(INF+v,g[x][x+n+n].w); g[x+n+n][x+n].w=max(INF+v,g[x+n+n][x].w); &#125; n=n+n+n; cout&lt;&lt;weight_blossom().first%INF&lt;&lt;&#x27;\\n&#x27;; return 0;&#125; day10C 一次操作可能对区间内的数没有实质性的改变，我们可以维护区间的数是否相同，如果相同则记录那个数，不同则记录为0。 那么若 相同的数|修改的值，那么说明本次修改对区间没有贡献，可以直接返回。 但是这个算法对于 2424242424242 这样的序列，修改的值为 $4,8,16\\cdots$ 要递归到叶子节点才能返回，而且对序列没有任何改变。 所以我们可以不维护区间相同的数，记录区间的 $lcm$，对于某次修改如果 $lcm$|修改的值，那么本次修改对区间无贡献。可以直接返回。 注意 $lcm&gt;10^{18}$ 要特判。题解详细分析了复杂度，说明了复杂度是 $O((nw+m)(w+\\log n))$ 的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/********************************************************************* Problem:lxl题2 Author:hydd Date:2020/8/6*********************************************************************/#include&lt;cstdio&gt;#define ls now&lt;&lt;1#define rs now&lt;&lt;1|1using namespace std;typedef unsigned long long ull;typedef unsigned int uint;const uint lim=-1u;const ull INF=2e18;int n,q;ull a[1610000],tag[1610000];uint sum[1610000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ull readull()&#123; ull x=0; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) ch=Getchar(); while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x;&#125;ull gcd(ull a,ull b)&#123; if (!b) return a; return gcd(b,a%b);&#125;ull lcm(ull x,ull y)&#123; if (x==INF||y==INF) return INF; ull g=gcd(x,y); x/=g; if (x&gt;INF/y+1) return INF; if (x*y&gt;=INF) return INF; return x*y;&#125;void pushup(int now)&#123; sum[now]=sum[ls]+sum[rs]; tag[now]=lcm(tag[ls],tag[rs]);&#125;void build(int now,int l,int r)&#123; if (l==r)&#123; tag[now]=a[l]; sum[now]=tag[now]&amp;lim; return; &#125; int mid=(l+r)&gt;&gt;1; build(ls,l,mid); build(rs,mid+1,r); pushup(now);&#125;void change(int now,int l,int r,int x,int y,ull v)&#123; if (l==r)&#123; tag[now]=gcd(tag[now],v); sum[now]=tag[now]&amp;lim; return; &#125; if (x&lt;=l&amp;&amp;r&lt;=y)&#123; if (v%tag[now]) tag[now]=gcd(tag[now],v); else return; &#125; int mid=(l+r)&gt;&gt;1; if (x&lt;=mid) change(now&lt;&lt;1,l,mid,x,y,v); if (y&gt;mid) change(now&lt;&lt;1|1,mid+1,r,x,y,v); pushup(now);&#125;uint query(int now,int l,int r,int x,int y)&#123; if (x&lt;=l&amp;&amp;r&lt;=y) return sum[now]; int mid=(l+r)&gt;&gt;1; uint res=0; if (x&lt;=mid) res+=query(now&lt;&lt;1,l,mid,x,y); if (y&gt;mid) res+=query(now&lt;&lt;1|1,mid+1,r,x,y); return res;&#125;int main()&#123; n=read(); q=read(); for (int i=1;i&lt;=n;i++) a[i]=readull(); build(1,1,n); int op,l,r; ull x; while (q--)&#123; op=read(); l=read(); r=read(); if (op==1)&#123; x=readull(); change(1,1,n,l,r,x); &#125; else printf(&quot;%u\\n&quot;,query(1,1,n,l,r)); &#125; return 0;&#125;","categories":[{"name":"NOI模拟赛","slug":"NOI模拟赛","permalink":"http://hydd.cf/categories/NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"20200726 讲课","slug":"sol_12","date":"2020-07-25T16:00:00.000Z","updated":"2020-09-30T13:09:47.339Z","comments":true,"path":"2020/07/26/sol_12/","link":"","permalink":"http://hydd.cf/2020/07/26/sol_12/","excerpt":"","text":"CF710F题意 有一个字符串集合 $S$，有 $m$ 个操作，每种操作是以下三种中的一种。 1 str 表示在 $S$ 中加入字符串 str。 2 str 表示在 $S$ 中删除字符串 str。 3 str 表示询问在 $S$ 中每个字符串在 str 中出现次数之和。 强制在线。 $m,\\sum |str|\\leq 3\\times 10^5$. 题解 首先我们可以发现，$S$ 中的每个字符串的贡献是互不影响的，也就是满足可减性。所以如果分别求出了 $1,2$ 操作各自的字符串集合，那么答案就是 $1$ 集合的答案 $-$ $2$ 集合的答案。 如何暴力求答案？将字符串集合建成 $AC$ 自动机，那么答案即为所有在 str 在树上走的路径上节点，它到根的 $fail$ 路径上的点的数量之和。（相当于现在当前右端点为 $i$ 的所有串一起算） 现在要加入一个字符串，怎么快速的维护 $fail$ 呢？ 我们会发现并没有很好的维护方法，因为 $fail$ 不是按照增量法构造的。 所以只能暴力重构。现在需要是否有一种方案能以较少的重构次数来维护这个问题，那么我们想到了二进制分组。每次加入集合，先放入 $2^0$ 这个组。如果现在有两个 $2^k$ 的组，就将它们合并后暴力重构，得到一个 $2^{k+1}$ 的组。一直合并直到没有两个 $2^k$ 的组即可。 可以发现，每个字符串被合并一次后，所在的集合大小就会 $\\times 2$，所以每个字符串最多会合并 $O(\\log n)$ 次。 查询的时候，直接查询所有组的答案，求和即可。时间复杂度 $O(n\\log n)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/********************************************************************* Problem:CF710F Author:hydd Date:2020/7/26*********************************************************************/#include&lt;cstdio&gt;#include&lt;cstring&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;int m,op;char s[310000];struct node&#123; int tot,cnt[310000],son[310000][26],ch[310000][26]; int top,rt[21],sz[21],que[310000],fail[310000],num[310000]; int merge(int x,int y)&#123; if (!x||!y) return x|y; cnt[x]+=cnt[y]; for (int i=0;i&lt;26;i++) son[x][i]=merge(son[x][i],son[y][i]); return x; &#125; void build(int x)&#123; int head=1,tail=0; fail[x]=x; for (int i=0;i&lt;26;i++)&#123; ch[x][i]=son[x][i]; if (ch[x][i])&#123; fail[ch[x][i]]=x; que[++tail]=ch[x][i]; &#125; else ch[x][i]=x; &#125; while (head&lt;=tail)&#123; int now=que[head++];// if (now==3) puts(&quot;&quot;); for (int i=0;i&lt;26;i++)&#123; ch[now][i]=son[now][i]; if (ch[now][i])&#123; fail[ch[now][i]]=ch[fail[now]][i]; que[++tail]=ch[now][i]; &#125; else ch[now][i]=ch[fail[now]][i]; &#125; num[now]=cnt[now]+num[fail[now]]; &#125; &#125; void ins(char *s)&#123; int n=strlen(s+1); rt[++top]=++tot; sz[top]=1; int x=tot; for (int i=1;i&lt;=n;i++)&#123; if (!son[x][s[i]-&#x27;a&#x27;]) son[x][s[i]-&#x27;a&#x27;]=++tot; x=son[x][s[i]-&#x27;a&#x27;]; &#125; cnt[x]++; while (top&gt;1&amp;&amp;sz[top]==sz[top-1])&#123; rt[top-1]=merge(rt[top-1],rt[top]); sz[top-1]+=sz[top]; top--; &#125; build(rt[top]); &#125; int query(char *s)&#123; int n=strlen(s+1); int res=0; for (int i=1;i&lt;=top;i++)&#123; int x=rt[i]; for (int j=1;j&lt;=n;j++)&#123; x=ch[x][s[j]-&#x27;a&#x27;]; res+=num[x]; &#125; &#125; return res; &#125;&#125; T1,T2;int main()&#123; scanf(&quot;%d&quot;,&amp;m); while (m--)&#123; scanf(&quot;%d%s&quot;,&amp;op,s+1); if (op==1) T1.ins(s); if (op==2) T2.ins(s); if (op==3) printf(&quot;%d\\n&quot;,T1.query(s)-T2.query(s)),fflush(stdout); &#125; return 0;&#125;/*41 abc2 abc1 aba3 abababc*/ CF700E题意 给定一个长度为 $n$ 的字符串 $S$，求一个最大的 $k$ 满足存在一个长为 $k$ 的字符串序列 $a$，使得序列中的每一个字符串都是 $S$ 的子串，且对于任意的 $1&lt;i\\leq k$ 都有 $a_{i−1}$ 在 $a_i$ 中至少出现两次（允许重叠）。 $n\\leq 200000$。 题解 先把 $SAM$ 建出来。根据条件，那么 $a_{i-1}$ 的 $right$ 集合一定完全包含 $a_i$ 的 $right$ 集合，同时求出 $pos[i]$ 表示当前节点在原串右端点的位置。 那么我们需要先维护出 $right$ 集合，可以使用线段树合并的方式（父亲的 $right$ 集合为子节点的 $right$ 集合的并）。 然后我们可以考虑 $dp$。设 $g_s$ 表示满足条件的情况下， $s$ 最大能做 $a$ 的第几个数。 然后我们可以发现，同个节点表示的串，因为它们的 $right$ 集合相同，所以只考虑最长的串即可。（根据条件显然不可能同个节点的多个串都在 $a$ 中）。 于是我们可以设 $f_x$ 为 $x$ 节点表示的最长串，它最大能做 $a$ 的第几个数。 那么，转移方程为：$f[u]=1+\\max_{v\\texttt{在}u\\texttt{中至少出现两次}} f[v]$。 我们看一下从上往下转移点之间的关系，由于 $right$ 集合的性质，如果当前点从某个祖先 $v$ 转移过来，那么 $v$ 显然已经在 $pos[u]$ 出现过一次。那么我们就只需要查询是否出现第二次。则此时的这一个有效区间为 $[pos[u]−len[u]+len[v],pos[u]−1]$，如果有值则说明出现了第二次。 设父亲节点的状态从 $vv$ 转移过来，那么 $u$ 只能从 $vv$ 或 $fa$ 转移过来。若有从 $vv$ 到 $fa$ 之间的一个点 $t$ 转移过来，那么有 $[pos[u]−len[u]+len[t],pos[u]−1]$ 有值，而 $[pos[fa]-len[fa]+len[t],pos[fa]-1]$ 没有值，那么显然从 $fa$ 转移不会更劣。 若父亲状态的串在当前节点的串中出现两次，则由父亲状态转移过来，否则直接继承父亲的状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/********************************************************************* Problem:CF700E Author:hydd Date:2020/7/27*********************************************************************/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int S=1;int z,n,cnt,a[410000],c[410000],len[410000];int f[410000],g[410000];int link[410000],trans[410000][26],num[410000];int treesize,ls[11000000],rs[11000000],rt[410000];char s[410000];void change(int &amp;now,int l,int r,int x)&#123; if (!now) now=++treesize; if (l==r) return; int mid=(l+r)&gt;&gt;1; if (x&lt;=mid) change(ls[now],l,mid,x); else change(rs[now],mid+1,r,x);&#125;int merge(int x,int y)&#123; if (!x||!y) return x|y; int z=++treesize; ls[z]=merge(ls[x],ls[y]); rs[z]=merge(rs[x],rs[y]); return z;&#125;bool query(int now,int l,int r,int x,int y)&#123; if (!now) return false; if (l==x&amp;&amp;r==y) return true; int mid=(l+r)&gt;&gt;1; if (y&lt;=mid) return query(ls[now],l,mid,x,y); else if (x&gt;mid) return query(rs[now],mid+1,r,x,y); else return query(ls[now],l,mid,x,mid)||query(rs[now],mid+1,r,mid+1,y);&#125;void add(int loc)&#123; int c=s[loc]-&#x27;a&#x27;,v=z; z=++cnt; len[z]=loc; num[z]=loc; for (;v&amp;&amp;!trans[v][c];v=link[v]) trans[v][c]=z; if (!v) link[z]=S; else&#123; int x=trans[v][c]; if (len[v]+1==len[x]) link[z]=x; else &#123; int y=++cnt; len[y]=len[v]+1; num[y]=num[z]; for (int i=0;i&lt;26;i++) trans[y][i]=trans[x][i]; link[y]=link[x]; link[x]=y; link[z]=y; for (;trans[v][c]==x;v=link[v]) trans[v][c]=y; &#125; &#125;&#125;int solve()&#123; z=1; cnt=1; for (int i=1;i&lt;=n;i++) add(i),change(rt[z],1,n,i); for (int i=1;i&lt;=cnt;i++) c[len[i]]++; for (int i=1;i&lt;=cnt;i++) c[i]+=c[i-1]; for (int i=1;i&lt;=cnt;i++) a[c[len[i]]--]=i; for (int i=cnt;i&gt;=2;i--) rt[link[a[i]]]=merge(rt[link[a[i]]],rt[a[i]]); int ans=1; for (int i=2;i&lt;=cnt;i++)&#123; int x=a[i],y=link[x]; if (y==1)&#123; f[x]=1; g[x]=x; continue; &#125; int t=query(rt[g[y]],1,n,num[x]-len[x]+len[g[y]],num[x]-1); f[x]=f[y]+t; g[x]=t?x:g[y]; ans=max(ans,f[x]); &#125; return ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); printf(&quot;%d\\n&quot;,solve()); return 0;&#125;","categories":[{"name":"字符串","slug":"字符串","permalink":"http://hydd.cf/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"20200718 讲课","slug":"sol_13","date":"2020-07-17T16:00:00.000Z","updated":"2020-09-30T13:25:26.945Z","comments":true,"path":"2020/07/18/sol_13/","link":"","permalink":"http://hydd.cf/2020/07/18/sol_13/","excerpt":"","text":"bzoj2563 在既有边权且又有点权比较难做，我们可以将边权分配到点权上。 我们把边权的一半分别放到相邻两个点的点权上，这样若两个点不属于同一集合，相减后这条边的贡献为 $0$，而属于同一集合的贡献为原边权。最后两个人显然是从大到小取的。 实现时可以把所有权值都乘 $2$。输出的时候再除以 $2$ 即可。 123456789101112131415161718192021222324252627282930/********************************************************************* Problem:bzoj2563 Author:hydd Date:2020/7/18*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;int n,m,u,v,cost;int a[110000];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); a[i]&lt;&lt;=1; &#125; for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;cost); a[u]+=cost; a[v]+=cost; &#125; sort(a+1,a+n+1,greater&lt;int&gt;()); int ans=0; for (int i=1;i&lt;=n;i++) if (i&amp;1) ans+=a[i]; else ans-=a[i]; printf(&quot;%d\\n&quot;,ans&gt;&gt;1); return 0;&#125; CF1221E 求出所有 $.$ 段的长度后分类讨论。 1：$len&lt;b$，先后手都不能选。 2：$b\\leq len&lt;a$，这种线段只有后手能选，所以后手必胜（因为先手能选的位置后手也能选，若先手没有能选的位置，那么后手选这个，先手就输了）。 3：$a\\leq len&lt;2b$，这种线段先后手都能选且只能选一次。 4：$len&gt;2b$，这种线段如果有两个以上，那么后手一定可以切一次，留下长度为 $[b,a)$ 的段。只出现了一次，先手就可能先将它破坏掉，使它剩下情况1或情况3的两段。 具体实现： 先看有没有情况2，然后看情况4的数量，判断掉非法情况。 如果情况4没有就可以直接判断种类3的奇偶性。 否则枚举先手把情况4分成哪两段，然后再判断一下种类3的奇偶性即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/********************************************************************* Problem:CF1221E Author:hydd Date:2020/7/18*********************************************************************/#include&lt;cstdio&gt;#include&lt;cstring&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;int T,a,b,n,cnt,v[1100000];char s[1100000];bool check()&#123; int tot=0,tot2=0,tmp; for (int i=1;i&lt;=cnt;i++)&#123; if (b&lt;=v[i]&amp;&amp;v[i]&lt;a) return false; if (a&lt;=v[i]&amp;&amp;v[i]&lt;2*b) tot++; if (v[i]&gt;=2*b) tmp=v[i],tot2++; &#125; if (tot2==0) return tot&amp;1; if (tot2&gt;1) return false; for (int i=1;i&lt;=tmp-a+1;i++)&#123;//1&lt;=i..i+a-1&lt;=tmp int l=i-1,r=tmp-(i+a-1); if (l&gt;=2*b||r&gt;=2*b||(b&lt;=l&amp;&amp;l&lt;a)||(b&lt;=r&amp;&amp;r&lt;a)) continue; int d=(a&lt;=l&amp;&amp;l&lt;2*b)+(a&lt;=r&amp;&amp;r&lt;2*b); if (!((tot+d)&amp;1)) return true; &#125; return false;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); scanf(&quot;%s&quot;,s); n=strlen(s); cnt=0; for (int i=0,j;i&lt;n;i=j+1)&#123; j=i; while (j&lt;n&amp;&amp;s[j]==&#x27;.&#x27;) j++; if (i!=j) v[++cnt]=j-i; &#125; if (check()) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; return 0;&#125; 异世界的文章分割者 对 $t$ 建 $SAM$，求出每个节点 $right$ 集合中的最小值和最大值，并分别记为 $mn,mx$。 这个怎么求呢？我们知道该节点的 $right$ 集合=该节点所有儿子节点的 $right$ 集合的并集，所以我们可以从叶子节点往上更新。 设该节点代表的子串的长度区间为 $[l,r]$，并令 $w[i]=w(t[1,i],t[i+1,|t|])$。 容易发现该节点对 $w[mn..mx-r]$ 的贡献是 $r-l+1$。对 $w[mx-r+ 1..mx-l]$的贡献是首项为 $r-l$，公差为 $-1$ 的等差数列。因此可以通过二维差分处理出所有的 $w$。 故计算一次 $val(t)$ 的复杂度为 $O(|t|)$。 注意到左端点确定后,该段的权值随右端点增大而单调不降。因此可以二分答案,每次找尽可能靠后的右端点扩展。 用倍增优化找右端点的过程。 具体来说,每次右端点尝试移动 $2^0, 2^1,..$ 步。假设移动到 $2^k$ 时停止,再尝试移动 $2^{k-1}, ..,2^0$步。每次移动后都重新求一遍 $val(t)$。 该做法的正确性显然。 假设划分出的一段长度为 $L$，则在划分的过程中会尝试移动 $O(\\log L)$ 次，每次求 $val(t)$ 的复杂度为 $O(L)$，因此划分一次的时间复杂度为 $O(|s|\\log|s|)$。 总的时间复杂度为 $O(|s|log|s|\\log MAXV)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/********************************************************************* Problem:异世界的文章分割者 Author:hydd Date:2020/7/18 - 2020/7/19*********************************************************************/#pragma GCC optimize(2)#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);//#define clr(arr) memset(arr,0,sizeof(arr))using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;int n,m,k,z,cnt; ll sum,ans,t[510000],f[510000];int trans[510000][30],link[510000],len[510000],mn[510000],mx[510000];int mns[510000],mxs[510000],c[510000],a[510000];char s[510000],st[510000];void change(int c)&#123; int v=z; z=++cnt; len[z]=len[v]+1; mn[cnt]=INF; for (;v&gt;=0&amp;&amp;!trans[v][c];v=link[v]) trans[v][c]=z; if (v==-1) link[z]=0; else&#123; int x=trans[v][c]; if (len[x]==len[v]+1) link[z]=x; else&#123; int y=++cnt; mn[cnt]=INF; len[y]=len[v]+1; for (int i=0;i&lt;26;i++) trans[y][i]=trans[x][i]; link[y]=link[x]; link[x]=y; link[z]=y; for (;v&gt;=0&amp;&amp;trans[v][c]==x;v=link[v]) trans[v][c]=y; &#125; &#125;&#125;ll work(int n)&#123; m=0; z=0; cnt=0; sum=0; ans=0;// clr(trans); clr(link); clr(len);// clr(mn); clr(mx); clr(mns); clr(mxs);// clr(c); clr(t); clr(f); clr(a); link[0]=-1; for (int i=1;i&lt;=n;i++)&#123; change(s[i]-&#x27;a&#x27;); mx[z]=i; mn[z]=i; &#125; for (int i=1;i&lt;=cnt;i++) sum+=(len[i]-len[link[i]]); for (int i=0;i&lt;=cnt;i++) c[len[i]]++; for (int i=0;i&lt;=len[z];i++) c[i]+=c[i-1]; for (int i=0;i&lt;=cnt;i++) a[c[len[i]]--]=i; for (int i=cnt+1;i&gt;=1;i--)&#123; mn[link[a[i]]]=min(mn[link[a[i]]],mn[a[i]]); mx[link[a[i]]]=max(mx[link[a[i]]],mx[a[i]]); mxs[a[i]]=len[a[i]]; mns[a[i]]=len[link[a[i]]]+1; &#125; int l,r,x,y; for (int i=1;i&lt;=cnt;i++)&#123; l=mns[i]; r=mxs[i]; x=max(mn[i],mx[i]-r+1); y=mx[i]-l; if (x==y)&#123; f[x]++; f[x+1]--;&#125; else if (x&lt;y)&#123; t[x]+=(y-x+1); t[x+1]-=(y-x+2); t[y+2]++;&#125; if (mn[i]&lt;=mx[i]-r)&#123; f[mn[i]]+=(r-l+1); f[mx[i]-r+1]-=(r-l+1);&#125; &#125; ll s=0; for (int i=1;i&lt;=n;i++)&#123; s+=t[i]; f[i]+=s; &#125; for (int i=1;i&lt;=n;i++) f[i]+=f[i-1]; for (int i=n-1;i&gt;=1;i--) ans+=1ll*f[i]*f[i]; for (int i=0;i&lt;=n+10;i++) f[i]=0,t[i]=0; for (int i=0;i&lt;=len[z]+10;i++) c[i]=0; for (int i=0;i&lt;=cnt+10;i++)&#123; mn[i]=0,mx[i]=0,mns[i]=0,mxs[i]=0,a[i]=0,link[i]=0,len[i]=0; for (int j=0;j&lt;26;j++) trans[i][j]=0; &#125; return ans;&#125;int main()&#123; File(&quot;article&quot;); scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%d&quot;,&amp;k); scanf(&quot;%s&quot;,st+1); ll l=0,r=1e18,mid; while (l&lt;r)&#123; mid=(l+r)&gt;&gt;1; int tot=0; for (int i=1;i&lt;=n;)&#123; int t=-1; for (int j=0;i+(1&lt;&lt;j)-1&lt;=n;j++)&#123; for (int k=1;k&lt;=(1&lt;&lt;j);k++) s[k]=st[i+k-1]; if (work(1&lt;&lt;j)&gt;mid) break; t=j; &#125; int now=0; for (int j=t;j&gt;=0;j--)&#123; if (i+(now|(1&lt;&lt;j))-1&gt;n) continue; for (int k=1;k&lt;=(now|(1&lt;&lt;j));k++) s[k]=st[i+k-1]; if (work(now|(1&lt;&lt;j))&lt;=mid) now|=(1&lt;&lt;j); &#125; i+=now; tot++; if (tot&gt;k) break; &#125; if (tot&lt;=k) r=mid; else l=mid+1; &#125; printf(&quot;%lld\\n&quot;,l); return 0;&#125;/*10 3ababababab15 2abcabcddcbacbad*/","categories":[],"tags":[]},{"title":"20200716 讲课","slug":"sol_14","date":"2020-07-15T16:00:00.000Z","updated":"2020-09-30T13:25:31.007Z","comments":true,"path":"2020/07/16/sol_14/","link":"","permalink":"http://hydd.cf/2020/07/16/sol_14/","excerpt":"","text":"uoj424 按照老师的题解写的。 每次取最大，那么我们考虑对序列建笛卡尔树。两个序列同构，当且仅当它们的笛卡尔树形状相同。不同构的序列，和最长左链（某个节点到根的路径中，作为左儿子的次数 $+1$）不超过 $m$ 的笛卡尔树是一一对应的。反过来，用归纳法可以证明，一棵满足上述条件的笛卡尔树，必然能构造出对应的序列。 那么问题转化成求 $n$ 个节点且最长左链不超过 $m$ 的笛卡尔树数量。 通过多叉树转二叉树的方法（左儿子右兄弟），将 $n$ 个节点的二叉树与 $n+1$ 个节点的多叉树（要补一个根，否则可能不连通）一一对应，且二叉树的最长左链不超过 $m$，等价于其对应的多叉树的深度不超过 $m$（根节点深度为 $0$）。问题转化为求 $n+1$ 个节点深度不超过 $m$ 的多叉树数量。 将 $n+1$ 个节点多叉树的入栈出栈序看成括号序 $(X)$，其中 $X$ 是由 $n$ 对括号组成的合法括号序。将左括号看成 $+1$，右括号看成 $−1$，该多叉树深度不超过 $m$ 当且仅当括号序的每个前缀均不超过 $m$。问题转化为求 $n$ 对括号组成且前缀不超过 $m$ 的合法括号序数量。 用类似证明卡特兰数的方法，将其放到二维平面上，变为求从 $(0,0)$ 走到 $(2n,0)$，每次横坐标 $+1$，纵坐标 $+1$ 或 $−1$，且不经过 $y=m+1$ 和 $y=−1$ 的路径数量。这个可以用容斥来算。具体来说，设其先经过若干次 $y=m+1$，再经过若干次 $y=−1$，再经过若干次 $y=m+1$，如此类推。则把起点沿 $y=m+1$ 对称，再沿 $y=−1$ 对称，再沿 $y=m+1$ 对称，如此类推。再计算最终得到的起点到 $(2n,0)$ 的路径数量，就是对应的方案数。容斥系数为 $(-1)^\\texttt{交错次数}$ 。 时间复杂度 $O(n)$。 123456789101112131415161718192021222324252627282930313233343536/********************************************************************* Problem:uoj424 Author:hydd Date:2020/7/16*********************************************************************/#include&lt;cstdio&gt;#include&lt;utility&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; pii;const int Mod=998244353;int n,m; ll fac[210000],inv[210000];pii flip(pii x,ll c)&#123; return pii(x.second-c,x.first+c);&#125;int C(int a,ll b)&#123; if (a&lt;b) return 0; if (b&lt;0) return 0; return 1ll*fac[a]*inv[b]%Mod*inv[a-b]%Mod;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if (m&gt;n)&#123; puts(&quot;0&quot;); return 0;&#125; fac[0]=1; for (int i=1;i&lt;=200010;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=200010;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=200010;i++) inv[i]=inv[i-1]*inv[i]%Mod; pii a(0,0),b(0,0); int ans=C(2*n,n); for (int i=1,c=Mod-1;i&lt;=n;i++,c=Mod-c)&#123; if (i&amp;1) a=flip(a,-1),b=flip(b,m+1); else a=flip(a,m+1),b=flip(b,-1); ans=(ans+1ll*c*C(n*2,n-a.first))%Mod; ans=(ans+1ll*c*C(n*2,n-b.first))%Mod; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; CC DEVLOCK 不同的位对数位和的贡献都是等价的，区别在于它们模 $p$ 的值。然而实际上不等价的只有 $p$ 类。 预处理出 $num_i$ 表示模 $p=i$ 的 $10^x$ 种数。然后对每一种去做个倍增 $FFT$，得到 $f_j$ 表示 $num_i$ 个 $0..9$，和为 $j$ 的方案数，倍增后的结果可以共用。 若第 $i$ 类有 $j$ 个，那么贡献就是 $ij \\bmod p$。然后把 $p$ 类用二维 $FFT$ 乘起来起来。$p$ 这一维很小，暴力卷积就行了。做 $p$ 次 $DFT$，再做一次 $IDFT$ 即可。 总时间复杂度为 $O(pm\\log m\\log n+p^2m\\log m+p^3m)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/********************************************************************* Problem:DEVLOCK Author:hydd Date:2020/7/17*********************************************************************/#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int Mod=998244353;const int g=3;inline int add(int x,int y)&#123; return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123; return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123; return 1ll*x*y%Mod;&#125;int n,p,m,N,rev[1100000];int cnt[110]; poly B[110];poly F[110],G[110],H[110];struct matrix&#123; int v[110][110]; matrix()&#123; memset(v,0,sizeof(v));&#125;&#125;;matrix operator*(const matrix &amp;a,const matrix &amp;b)&#123; matrix res; for (int i=0;i&lt;N;i++) for (int k=0;k&lt;N;k++) if (a.v[i][k]) for (int j=0;j&lt;N;j++) res.v[i][j]=add(res.v[i][j],mul(a.v[i][k],b.v[k][j])); return res;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(g,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;int getbit(int x)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;x) bit++; return bit; &#125;poly operator*(poly a,poly b)&#123; int bit=getbit((int)a.size()+b.size()-1); int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],b[i]); NTT(a,len,-1); return a;&#125;matrix qpow(matrix x,int a)&#123; matrix res; for (int i=0;i&lt;N;i++) res.v[i][i]=1; while (a)&#123; if (a&amp;1) res=res*x; x=x*x; a&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;m); if (p==1) cnt[0]=n; else&#123; matrix a; for (int i=0;i&lt;p;i++)&#123; a.v[i][i*10%p]++; a.v[i][i+p]++; a.v[i+p][i+p]++; &#125; N=2*p; a=qpow(a,n); for (int i=0;i&lt;p;i++) cnt[i]=a.v[1][i+p]; &#125; B[0].resize(m+1); for (int i=0;i&lt;=min(9,m);i++) B[0][i]=1; for (int i=1;(1&lt;&lt;i)&lt;=n;i++)&#123; B[i]=B[i-1]*B[i-1]; B[i].resize(m+1); &#125; int len=1&lt;&lt;getbit(2*m+1); for (int j=0;j&lt;p;j++)&#123; F[j].clear(); F[j].resize(len); &#125; F[0][0]=1; for (int i=0;i&lt;p;i++) if (cnt[i])&#123; poly A(m+1); A[0]=1; for (int j=0;(1&lt;&lt;j)&lt;=cnt[i];j++) if ((cnt[i]&gt;&gt;j)&amp;1)&#123; A=A*B[j]; A.resize(m+1); &#125; for (int j=0;j&lt;p;j++)&#123; G[j].clear(); G[j].resize(len); &#125; for (int j=0;j&lt;=m;j++) G[i*j%p][j]=A[j]; for (int j=0;j&lt;p;j++)&#123; NTT(F[j],len,1); NTT(G[j],len,1); &#125; for (int j=0;j&lt;p;j++)&#123; H[j].clear(); H[j].resize(len); &#125; for (int j=0;j&lt;p;j++) for (int k=0;k&lt;p;k++) for (int l=0;l&lt;len;l++) H[(j+k)%p][l]=add(H[(j+k)%p][l],mul(F[j][l],G[k][l])); for (int j=0;j&lt;p;j++)&#123; NTT(H[j],len,-1); H[j].resize(m+1); F[j]=H[j]; &#125; &#125; for (int i=1;i&lt;=m;i++) F[0][i]=add(F[0][i-1],F[0][i]); for (int i=0;i&lt;m;i++) printf(&quot;%d &quot;,F[0][i]); printf(&quot;%d\\n&quot;,F[0][m]); return 0;&#125; CC CLOWAY 我们可以发现不走和走自环是等价的，所以我们可以先给所有点加上一个自环，最后再去掉都走自环的情况即可。 设 $G_{l,r,k}$ 表示对编号在 $[l,r]$ 之间的图进行操作，每轮每张图都可以走自环，在 $k$ 轮后恰好回到起始状态的方案数。 设 $F_{l,r,k}$ 表示对编号在 $[l,r]$ 之间的图进行操作，每轮必须有图不走自环，在 $k$ 轮后恰好回到起始状态的方案数。 设 $A_i$ 为加上自环后的第 $i$ 张图的邻接矩阵，$tr(A)$ 表示矩阵的迹，即对角线元素之和。那么第 $i$ 张图走 $k$ 步回到初始状态的方案数为 $tr(A_i^k)$，总方案数为 $\\prod\\limits_{i=l}^r tr(A_i^k)$，即 $G_{l,r,k}=\\prod\\limits_{i=l}^r tr(A_i^k)$。 那么枚举没有全都走自环的轮数 $i$ 有 $G_{l,r,k}=\\sum\\limits_{i=0}^k\\binom kiF_{l,r,i}$，二项式反演可得 $F_{l,r,k}=\\sum\\limits_{i=0}^k(-1)^{k-i}\\binom kiG_{l,r,i}$。 将其化为卷积形式，有：$\\frac{f_{l,r,k}}{k!}=\\sum\\limits_{i+j=k}\\frac{g_{l,r,i}}{i!}\\frac{(-1)^j}{j!}$。 根据矩阵的迹的性质：$tr(A+B)=tr(A)+tr(B),tr(kA)=ktr(A)$（显然）。 由 $Cayley-Hamilton$ 定理，设 $A$ 的特征多项式为 $c_0x^0+c_1x^1+c_2x^2+\\cdots+c_{|A|}x^{|A|}=\\sum\\limits_{i=0}^{|A|}c_ix^i$，那么 $\\sum\\limits_{i=0}^{|A|}c_iA^i=0$（$0$ 矩阵），两边同时乘 $A$ 的任意次幂值仍不变，即 $\\sum\\limits_{i=0}^{|A|}c_iA^{i+t}=0* A^t=0$（$0$ 矩阵）。 两边同时取 $tr()$，有 $tr(\\sum\\limits_{i=0}^{|A|}c_iA^{i+t})=tr(0)=0$，而 $tr(\\sum\\limits_{i=0}^{|A|}c_iA^{i+t})=\\sum\\limits_{i=0}^{|A|}tr(c_iA^{i+t})=\\sum\\limits_{i=0}^{|A|}c_itr(A^{i+t})$，则 $\\sum\\limits_{i=0}^{|A|}c_itr(A^{i+t})=0$，有了这个式子，只需求出特征多项式和矩阵的前 $|A|$ 次的迹，就可以线性递推了。 特征多项式可以直接插值，$f(\\lambda)=|\\lambda E-A|$，代入 $\\lambda=0\\cdots|A|$ 后插值即可。 时间复杂度 $O(T(N^4+NK)+T^2K\\log K+Q)$。模数为 $10^9+7$ 所以可以用拆系数 $FFT$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/********************************************************************* Problem:CLOWAY Author:hydd Date:2020/7/20*********************************************************************/#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;typedef long long ll;typedef long double ldb;const int Mod=1e9+7;const ldb Pi=acos(-1.0);struct node&#123; int l,r,k;&#125; q[1100000];int T,n,m,Q;int mx[55][55];inline int add(int x,int y)&#123; return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123; return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123; return 1ll*x*y%Mod;&#125;struct complex&#123; ldb x,y; complex(ldb xx=0,ldb yy=0)&#123; x=xx; y=yy;&#125; void clr()&#123; x=0; y=0;&#125;&#125;;struct Matrix&#123; int v[55][55]; Matrix()&#123; memset(v,0,sizeof(v));&#125; void clr()&#123; memset(v,0,sizeof(v));&#125; Matrix operator*(const Matrix &amp;x) const&#123; Matrix y; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) for (int k=1;k&lt;=n;k++) y.v[i][j]=add(y.v[i][j],mul(v[i][k],x.v[k][j])); return y; &#125;&#125; A,B,E,tmp_i;int tr(Matrix &amp;A)&#123; int res=0; for (int i=1;i&lt;=n;i++) res=add(res,A.v[i][i]); return res;&#125;int v[55][55];ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;int det(Matrix &amp;a)&#123; int f=0,ans=1; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) v[i][j]=a.v[i][j]; for (int i=1;i&lt;=n;i++)&#123; if (!v[i][i]) for (int j=i+1;j&lt;=n;j++) if (v[j][i])&#123; f^=1; swap(v[i],v[j]); break; &#125; if (!v[i][i]) return 0; int inv=qpow(v[i][i],Mod-2); for (int j=i+1;j&lt;=n;j++)&#123; int tmp=mul(v[j][i],inv); for (int k=i;k&lt;=n;k++) v[j][k]=add(v[j][k],dec(0,mul(tmp,v[i][k]))); &#125; ans=mul(ans,v[i][i]); &#125; if (f) ans=dec(0,ans); return ans;&#125;Matrix I(int n)&#123; tmp_i.clr(); for (int i=1;i&lt;=n;i++) tmp_i.v[i][i]=1; return tmp_i;&#125;int bit,len,rev[66000];ll fac[21000],inv[21000],aaa[66000],bbb[66000];complex aa[66000],bb[66000],cc[66000],dd[66000], ee[66000],ff[66000],gg[66000],hh[66000];complex operator+(complex a,complex b)&#123; return complex(a.x+b.x,a.y+b.y);&#125;complex operator-(complex a,complex b)&#123; return complex(a.x-b.x,a.y-b.y);&#125;complex operator*(complex a,complex b)&#123; return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125; void FFT(complex *A,int type)&#123; for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(A[i],A[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; complex Wn(cos(Pi/mid),type*sin(Pi/mid)); for (int R=mid&lt;&lt;1,j=0;j&lt;len;j+=R)&#123; complex w(1,0); for (int k=0;k&lt;mid;k++,w=w*Wn)&#123; complex x=A[j+k],y=w*A[j+mid+k]; A[j+k]=x+y; A[j+mid+k]=x-y; &#125; &#125; &#125;&#125;void MTT(ll *A,ll *B,ll *res,int m)&#123; len=1; bit=0; while (len&lt;=m+m) len&lt;&lt;=1,bit++; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1));// memset(aa,0,sizeof(aa)); memset(bb,0,sizeof(bb));// memset(cc,0,sizeof(cc)); memset(dd,0,sizeof(dd));// memset(ee,0,sizeof(ee)); memset(ff,0,sizeof(ff));// memset(gg,0,sizeof(gg)); memset(hh,0,sizeof(hh)); for(int i=0;i&lt;=m;i++) aa[i].x=A[i]&gt;&gt;15,aa[i].y=0,bb[i].x=A[i]&amp;32767,bb[i].y=0; for(int i=0;i&lt;=m;i++) cc[i].x=B[i]&gt;&gt;15,cc[i].y=0,dd[i].x=B[i]&amp;32767,dd[i].y=0; for(int i=m+1;i&lt;len;i++) aa[i].clr(),bb[i].clr(),cc[i].clr(),dd[i].clr(); FFT(aa,1); FFT(bb,1); FFT(cc,1); FFT(dd,1); for(int i=0;i&lt;len;i++)&#123; ee[i]=aa[i]*cc[i]; ff[i]=aa[i]*dd[i]; gg[i]=bb[i]*cc[i]; hh[i]=bb[i]*dd[i]; &#125; FFT(ee,-1); FFT(ff,-1); FFT(gg,-1); FFT(hh,-1); for (int i=0;i&lt;=m;i++) res[i]=(((ll)(ee[i].x/len+0.5)%Mod&lt;&lt;30)%Mod+ ((ll)(ff[i].x/len+0.5)%Mod&lt;&lt;15)%Mod+ ((ll)(gg[i].x/len+0.5)%Mod&lt;&lt;15)%Mod+ (ll)(hh[i].x/len+0.5)%Mod)%Mod;&#125;void mult(ll *A,ll *B,int m)&#123; for (int i=0;i&lt;=m;i++) bbb[i]=B[i]; for (int i=0;i&lt;=m;i++) aaa[i]=A[i]; MTT(aaa,bbb,B,m);&#125;void getfac()&#123; fac[0]=1; for (int i=1;i&lt;=10000;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=10000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=10000;i++) inv[i]=inv[i-1]*inv[i]%Mod;&#125;ll tmp[21000];void poly_mul(ll *f,ll t)&#123;// *(x+t) for (int i=n+1;i&gt;0;i--)&#123; tmp[i]=f[i]; f[i]=f[i-1]; &#125; tmp[0]=f[0]; f[0]=0; for (int i=0;i&lt;=n+1;i++) f[i]=(f[i]+t*tmp[i])%Mod;&#125;void poly_div(ll *f,ll *g,ll t)&#123;// /(x-t) for (int i=0;i&lt;=n+1;i++) tmp[i]=f[i]; for (int i=n+1;i&gt;0;i--)&#123; g[i-1]=tmp[i]; tmp[i-1]=(tmp[i-1]+t*tmp[i])%Mod; &#125; return;&#125;ll a[21000],b[21000],c[21000],F[21000];ll f[55][55][21000],g[55][55][21000];void Lagrange(int *r,int n)&#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); b[1]=1; for (int i=1;i&lt;=n;i++) poly_mul(b,dec(0,i)); for (int i=0;i&lt;=n;i++)&#123; ll s=1; for (int j=0;j&lt;=n;j++) if (i!=j) s=s*dec(i,j)%Mod; s=qpow(s,Mod-2); s=s*r[i]%Mod; poly_div(b,c,i); for (int j=0;j&lt;=n;j++) a[j]=(a[j]+s*c[j])%Mod; &#125; for (int i=0;i&lt;=n;i++) F[i]=a[i];&#125;int r[21000];void work(Matrix a)&#123; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) a.v[i][j]=dec(0,a.v[i][j]); for (int i=0;i&lt;=n;i++)&#123;//iE-A r[i]=det(a); for (int j=1;j&lt;=n;j++) a.v[j][j]=add(a.v[j][j],1); &#125; Lagrange(r,n);&#125;int main()&#123; getfac(); scanf(&quot;%d&quot;,&amp;T); int u,v; for (int t=1;t&lt;=T;t++)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); A=I(n); E=I(n); for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); A.v[u][v]=1; A.v[v][u]=1; &#125; work(A); memset(r,0,sizeof(r)); for (int i=0;i&lt;n;i++) r[i]=tr(E),E=E*A; for (int i=n;i&lt;=10000;i++) for (int j=0;j&lt;n;j++) r[i]=add(r[i],dec(0,mul(F[j],r[i-n+j]))); for (int i=0;i&lt;=10000;i++) g[t][t][i]=r[i]; &#125; scanf(&quot;%d&quot;,&amp;Q); for (int i=1;i&lt;=Q;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k); mx[q[i].l][q[i].r]=max(mx[q[i].l][q[i].r],q[i].k); &#125; for (int i=1;i&lt;=T;i++) for (int j=i+1;j&lt;=T;j++) for (int k=0;k&lt;=10000;k++) g[i][j][k]=mul(g[i][j-1][k],g[j][j][k]); for (int i=1;i&lt;=T;i++) for (int j=i;j&lt;=T;j++)&#123; for (int k=0;k&lt;=mx[i][j];k++)&#123; g[i][j][k]=mul(g[i][j][k],inv[k]); f[i][j][k]=k&amp;1?dec(0,inv[k]):inv[k]; &#125; mult(g[i][j],f[i][j],mx[i][j]); f[i][j][0]=0; for (int k=1;k&lt;=mx[i][j];k++) f[i][j][k]=add(f[i][j][k-1],mul(f[i][j][k],fac[k])); &#125; for (int i=1;i&lt;=Q;i++) printf(&quot;%lld\\n&quot;,f[q[i].l][q[i].r][q[i].k]); return 0;&#125;/*13 31 22 31 311 1 3*/ CC POLYEVAL 按照老师的题解写的。 首先 $786433=2^{18}*3+1$，可以取 $n=2^{18}$。 $DFT$ 的过程本身就是特殊的多点求值，求的是单位根的幂次的值。在 $NTT$ 中，$n$ 次单位根为 $g^\\frac{p-1}n=g^3$。 其中 $g$ 是 $p$ 的一个原根。如果我们直接对多项式做 $DFT$，就可以得到所有离散对数是 $3$ 的幂次的点值。 注意到 $\\sum a_ix^i=\\sum a_ir^i(\\frac xr)^i$， 我们构造一个新多项式，系数为 $a_ir^i$，求出来 $x_0$ 处的点值就是原多项式中 $x_0r$ 处的点值。 故总共只要做三次 $DFT$ 即可。时间复杂度为 $O(n\\log n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/********************************************************************* Problem:POLYEVAL Author:hydd Date:2020/7/17*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std;typedef long long ll;const int g=10;const int Mod=786433;const int MAXN=810000;int n,m,q,x,len,rev[MAXN],ans[MAXN];int a[MAXN],b[MAXN],c[MAXN];inline ll qpow(ll x,int a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline int getinv(int x)&#123; return qpow(x,Mod-2);&#125;void NTT(int *a,int inv)&#123; for (int i=0;i&lt;n;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;n;mid&lt;&lt;=1)&#123; int tmp=qpow(g,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;n;i+=mid*2)&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=omega*tmp%Mod)&#123; int x=a[i+j],y=omega*a[i+j+mid]%Mod; a[i+j]=(x+y)%Mod,a[i+j+mid]=(x-y+Mod)%Mod; &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); n++; int gi=1; for (int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); b[i]=1ll*a[i]*gi%Mod; c[i]=1ll*a[i]*gi%Mod*gi%Mod; gi=1ll*gi*g%Mod; &#125; ans[0]=a[0]; int bit=18; n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,1); NTT(b,1); NTT(c,1); int t1=1,t2=g,t3=1ll*t2*g%Mod; int l=1ll*t3*g%Mod; for (int i=0;i&lt;n;i++)&#123; ans[t1]=a[i]; ans[t2]=b[i]; ans[t3]=c[i]; t1=1ll*t1*l%Mod; t2=1ll*t2*l%Mod; t3=1ll*t3*l%Mod; &#125; scanf(&quot;%d&quot;,&amp;q); while (q--)&#123; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,ans[x]); &#125; return 0;&#125; uoj269 \\begin{aligned} a n s &=\\sum_{k=0}^{n} f(k)\\binom{n}{k}x^{k}(1-x)^{n-k} \\\\ &=\\sum_{k=0}^{n} \\sum_{i=0}^{\\infty} f_{i} k^{\\underline i}\\binom{n}{k} x^{k}(1-x)^{n-k} \\\\ &=\\sum_{i=0}^{\\infty} f_{i} \\sum_{k=0}^{n} k^{\\underline i}\\binom{n}{k} x^{k}(1-x)^{n-k} \\\\ &=\\sum_{i=0}^{\\infty} f_{i} \\sum_{k=0}^{n} k^{\\underline i}\\binom{n-i}{k-i} \\frac{n^{\\underline i}}{k^{\\underline i}} x^{k}(1-x)^{n-k} \\\\ &=\\sum_{i=0}^{\\infty} n^{\\underline i} f_{i} \\sum_{k=0}^{n}\\binom{n-i}{k-i} x^{k}(1-x)^{n-k} \\\\ &=\\sum_{i=0}^{\\infty} n^{\\underline i} f_{i} \\sum_{k=0}^{n-i}\\binom{n-i}{k} x^{k+i}(1-x)^{n-k-i} \\\\ &=\\sum_{i=0}^{\\infty} x^{i} n^{\\underline i} f_{i} \\sum_{k=0}^{n-i}\\binom{n-i}{k} x^{k}(1-x)^{n-k-i} \\\\ &=\\sum_{i=0}^{m} n^{\\underline i} f_{i} x^{i} \\end{aligned} \\\\ \\begin{aligned} f(i)&=\\sum_{j=0}^ma_ji^{\\underline j}=\\sum_{j=0}^ma_j\\frac{i!}{(i-j)!} \\\\\\frac{f(i)}{i!}&=\\sum_{j=0}^ma_j*\\frac{1}{(i-j)!} \\end{aligned} 所以 $f(i)$ 的EGF等于 $a$ 的OGF卷积上 $e^x$，所以 $a$ 的OGF等于 $f(i)$ 的EGF乘上 $e^{−x}$。 时间复杂度 $O(m\\log m)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/********************************************************************* Problem:uoj269 Author:hydd Date:2020/7/18 - 2020/7/19*********************************************************************/#include&lt;cstdio&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout);#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int Mod=998244353;const int g=3;int n,m,x0,rev[1100000];int fac[1100000],inv[1100000];inline int add(int x,int y)&#123; return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123; return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123; return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(g,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;int getbit(int x)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;poly operator*(poly a,poly b)&#123; int bit=getbit((int)a.size()+b.size()-1); int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],b[i]); NTT(a,len,-1); return a;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;x0); fac[0]=1; for (int i=1;i&lt;=m;i++) fac[i]=mul(fac[i-1],i); inv[1]=1; for (int i=2;i&lt;=m;i++) inv[i]=mul((Mod-Mod/i),inv[Mod%i]); inv[0]=1; for (int i=1;i&lt;=m;i++) inv[i]=mul(inv[i-1],inv[i]); poly f(m+1), g(m+1); //f=f_e(x0) g=e^&#123;-x0&#125; int x; for (int i=0;i&lt;=m;i++)&#123; scanf(&quot;%d&quot;,&amp;x); f[i]=mul(x,inv[i]); &#125; for (int i=0;i&lt;=m;i++) g[i]=(i&amp;1)?dec(0,inv[i]):inv[i]; poly h=f*g; h.resize(m+1);//h=f*g int s=1,ans=0; for (int i=0;i&lt;=m;i++)&#123; ans=(ans+1ll*mul(h[i],s)*qpow(x0,i))%Mod; s=mul(s,n-i); &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[],"tags":[]},{"title":"20200715 五大强校联考题解","slug":"sol_15","date":"2020-07-14T16:00:00.000Z","updated":"2020-10-01T04:58:59.922Z","comments":true,"path":"2020/07/15/sol_15/","link":"","permalink":"http://hydd.cf/2020/07/15/sol_15/","excerpt":"","text":"得分（score) 有一个部分分是 $\\frac{a_i}{t_i}$ 互不相同，我们考虑 $\\frac{a_i}{t_i}$ 的顺序与最优策略的关系。 我们看在什么情况下，交换相邻的两个数会使答案更优。 \\tfrac {a_i}{t_i}","categories":[{"name":"NOI模拟赛","slug":"NOI模拟赛","permalink":"http://hydd.cf/categories/NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"ZJOI2020 题解","slug":"sol_16","date":"2020-07-14T16:00:00.000Z","updated":"2020-09-30T13:29:00.284Z","comments":true,"path":"2020/07/15/sol_16/","link":"","permalink":"http://hydd.cf/2020/07/15/sol_16/","excerpt":"","text":"Day1T1 现在只会 $40pts$。 首先记录原串所有前缀的双 $hash$ 值。 然后，求出所有相同 本质相同的 ，符合条件的 子串，一起考虑它们对询问的答案。 对于这些串，如果它们所在的位置分别为 $[l_1,r_1],[l_2,r_2],…,[l_k,r_k]$。 我们把询问当做一个矩阵，贡献就是矩形加。$(1,l_1)-(r_1,n),(l_1+1,l_2)-(r_2,n),…,(l_{k-1}+1,l_k)-(r_k,n)$ 这些矩形都 $+1$ 即可。 这个可以差分前缀和，时间复杂度有关本质不同的子串个数（感觉为 $O(n)$）。 故总时间复杂度为 $O(n^2)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std;const int Mod1=1e9+7;const int Mod2=1e9+9;typedef long long ll;typedef pair&lt;int,int&gt; pii;int n,q; ll a[5100][5100]; ll hash1[210000],hash2[210000];ll pow1[210000],pow2[210000];char s[210000];map&lt;pii,int&gt; mp;vector&lt;int&gt; vec[210000];inline ll hs1(int l,int r)&#123; return (hash1[r]-hash1[l-1]*pow1[r-l+1]%Mod1+Mod1)%Mod1;&#125;inline ll hs2(int l,int r)&#123; return (hash2[r]-hash2[l-1]*pow2[r-l+1]%Mod2+Mod2)%Mod2;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;q); scanf(&quot;%s&quot;,s+1); pow1[0]=1; pow2[0]=1; for (int i=1;i&lt;=n;i++) pow1[i]=pow1[i-1]*3%Mod1; for (int i=1;i&lt;=n;i++) pow2[i]=pow2[i-1]*3%Mod2; for (int i=1;i&lt;=n;i++) hash1[i]=(hash1[i-1]*3+(s[i]-&#x27;a&#x27;+1))%Mod1; for (int i=1;i&lt;=n;i++) hash2[i]=(hash2[i-1]*3+(s[i]-&#x27;a&#x27;+1))%Mod2; for (int mid=1;mid*2&lt;=n;mid++)&#123; mp.clear(); int cnt=0; for (int i=1;i+mid*2-1&lt;=n;i++)&#123; int x1,x2,y1,y2; x1=hs1(i,i+mid-1); y1=hs1(i+mid,i+mid*2-1); x2=hs2(i,i+mid-1); y2=hs2(i+mid,i+mid*2-1); if (x1==y1&amp;&amp;x2==y2)&#123; if (!mp[pii(x1,x2)])&#123; mp[pii(x1,x2)]=++cnt; vec[cnt].push_back(0);&#125; vec[mp[pii(x1,x2)]].push_back(i); &#125; &#125; for (int i=1;i&lt;=cnt;i++)&#123; for (int j=1;j&lt;(int)vec[i].size();j++)&#123; a[vec[i][j-1]+1][vec[i][j]+mid*2-1]++; a[vec[i][j]+1][vec[i][j]+mid*2-1]--; &#125; vec[i].clear(); &#125; &#125; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]; int x,y; while (q--)&#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%lld\\n&quot;,a[x][y]); &#125; return 0;&#125; Day1T2 思路类似于去年的那道线段树，就是分成 $5$ 类点来分别算贡献。（参考了pinkrabbit的 $blog$：https://www.cnblogs.com/PinkRabbit/p/ZJOI2019D1T2.html） 设当前区间为 $[l,r]$ ,父区间为 $[fa_l,fa_r]$。 令 $tot_i$ 表示第 $i$ 类点的个数，那么： 1234567tot1=seg_cnt-l*(n-r+1)-(getcnt(l-1)+getcnt(n-r));if (l==fa_l) tot2=l*(fa_r-r);else tot2=(l-fa_l)*(n-r+1);if (l==fa_l) tot3=getsum(n-fa_r+1,n-(r+1)+1);else tot3=getsum(fa_l,l-1);tot4=l*(n-r+1)-tot2;tot5=getcnt(l-1)+getcnt(n-r)-tot3; 其中，$getcnt(x)$ 是 $x(x+1)/2$ ，$getsum(l,r)$ 是 $l+(l+1)+\\cdots+r$。$seg_{cnt}=getcnt(n)$。 用同样的 $f,g$ 的定义，一次操作后，有：$\\ =\\ &lt;\\frac{tot_10+tot_21+tot_3g[u]+tot_4f[u]+tot_5f[u]}{seg_{cnt}},\\frac{tot_10+tot_21+tot_3g[u]+tot_4*1+tot_5g[u]}{seg_{cnt}}&gt;$ 设 $f[u]=af[u]+bg[u]+c,g[u]=xg[u]+y$ ，一个 $3*3$ 的矩阵即可。时间复杂度 $O(n \\log K)$。为了卡常可以把矩乘展开。（没加快读，目前loj Rank1） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int Mod=998244353;int n,k,ans; ll seg_cnt,inv;ll tot1,tot2,tot3,tot4,tot5;ll a,b,c,x,y;inline ll getcnt(int n)&#123; return (1ll*n*(n+1)/2)%Mod;&#125;inline ll getsum(int x,int y)&#123; return (1ll*(x+y)*(y-x+1)/2)%Mod;&#125;ll getinv(int x)&#123; if (x==1) return 1; return 1ll*(Mod-Mod/x)*getinv(Mod%x)%Mod;&#125;struct mat&#123; ll m11,m12,m13,m21,m22,m23,m31,m32,m33; mat()&#123; m11=m12=m13=m21=m22=m23=m31=m32=m33=0;&#125; mat(ll v11,ll v12,ll v13,ll v21,ll v22,ll v23,ll v31,ll v32,ll v33)&#123; m11=v11; m21=v21; m31=v31; m12=v12; m22=v22; m32=v32; m13=v13; m23=v23; m33=v33; &#125; void operator*=(const mat &amp;x)&#123; ll t1,t2; t1=(m11*x.m11+m12*x.m21+m13*x.m31)%Mod; t2=(m11*x.m12+m12*x.m22+m13*x.m32)%Mod; m13=(m11*x.m13+m12*x.m23+m13*x.m33)%Mod; m11=t1; m12=t2; t1=(m21*x.m11+m22*x.m21+m23*x.m31)%Mod; t2=(m21*x.m12+m22*x.m22+m23*x.m32)%Mod; m23=(m21*x.m13+m22*x.m23+m23*x.m33)%Mod; m21=t1; m22=t2; t1=(m31*x.m11+m32*x.m21+m33*x.m31)%Mod; t2=(m31*x.m12+m32*x.m22+m33*x.m32)%Mod; m33=(m31*x.m13+m32*x.m23+m33*x.m33)%Mod; m31=t1; m32=t2; &#125;&#125;;int qpow()&#123; int a=k; mat res(1,0,0,0,1,0,0,0,1); mat x(::a,::b,::c,0,::x,::y,0,0,1); while (a)&#123; if (a&amp;1) res*=x; x*=x; a&gt;&gt;=1; &#125; return res.m13;&#125;int getans()&#123; tot1%=Mod; tot2%=Mod; tot3%=Mod; tot4%=Mod; tot5%=Mod; a=tot4+tot5; b=tot3; c=tot2; x=tot3+tot5; y=tot2+tot4; a=a*inv%Mod; b=b*inv%Mod; c=c*inv%Mod; //f[i][u]=a*f[i-1][u]+b*g[i-1][u]+c x=x*inv%Mod; y=y*inv%Mod; //g[i][u]=x*g[i-1][u]+y return qpow();&#125;void calc(int l,int r,int fa_l,int fa_r)&#123; tot1=seg_cnt-1ll*l*(n-r+1)-(getcnt(l-1)+getcnt(n-r)); if (l==fa_l) tot2=1ll*l*(fa_r-r); else tot2=1ll*(l-fa_l)*(n-r+1); if (l==fa_l) tot3=getsum(n-fa_r+1,n-(r+1)+1); else tot3=getsum(fa_l,l-1); tot4=1ll*l*(n-r+1)-tot2; tot5=getcnt(l-1)+getcnt(n-r)-tot3; ans=(ans+getans())%Mod;&#125;void solve(int l,int r)&#123; if (l==r) return; int mid; scanf(&quot;%d&quot;,&amp;mid); solve(l,mid); solve(mid+1,r); calc(l,mid,l,r); calc(mid+1,r,l,r);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); seg_cnt=getcnt(n); inv=getinv(seg_cnt); tot1=seg_cnt-1; tot2=1; tot3=0; tot4=0; tot5=0; ans=getans(); solve(1,n); printf(&quot;%d\\n&quot;,ans); return 0;&#125; Day1T3 首先有一个结论：如果只有第一种操作，那么答案为 $\\frac{\\sum\\mid a_i-a_{i-1}\\mid}{2}$（NOIP2018D1T1）。在序列最前面和最后面都添2个0。 然后，我们设 $b_i$ 为第 $i$ 个位置做了几次 $2/3$ 操作，$c_i$ 为第 $i$ 个位置做了几次 $1$ 操作。同样在序列最前面和最后面都添2个0。显然，$a_i=b_i+c_i$。 那么，我们可以发现：若 $b_{i-2}+c_{i-1}\\geqslant a_i$，那么 $b_{i-2}\\geqslant b_i,c_{i-1}\\geqslant c_i$。反之亦然。 证明可以考虑：假设 $b_{i-2}&gt; b_i,c_{i-1}&lt;c_i$，那么将 $b_i—,c_i++$ 答案不会变劣，其它情况类似。 那么我们可以考虑贪心： 从左到右考虑每个位置 $i$。考虑 $i$ 的时候确定 $i-1$。 首先，我们先使 $b_i=b_{i-2},c_i=c_{i-1}$。 我们记 $res[i]$ 表示当前的贪心得到的 $b_i+c_i$ 与 $a_i$ 的差值。（即 $a_i-(b_i+c_i)$）。 此时，我们要确定 $i-1$。 若 $res[i]&gt;0,res[i-1]&gt;0$，那么，我们可以将 $c_i++,c_{i-1}++$。那么 $res[i]$ 和 $res[i-1]$ 都 $—$。 若 $res[i]&lt;0,res[i-1]&lt;0$，那么，我们可以将 $c_i—,c_{i-1}—$。那么 $res[i]$ 和 $res[i-1]$ 都 $++$。 否则，我们可以将 $c_{i-1}+=res[i-1]$。同时 $res[i-1]$ 清零。 需要注意，如果 $c_i&lt;0$ 或 $c_{i+1}&lt;0$，要强制变为 $0$。 最后得到的 $b,c$ 即为最优解。证明可以考虑每一步的最优性，对答案的影响。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int T,n,a[110000],b[110000],c[110000];ll ans;inline int getres(int x)&#123; return a[x]-(b[x]+c[x]);&#125;inline int myabs(int x)&#123; return x&gt;0?x:-x;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%d&quot;,&amp;n); n+=4; for (int i=3;i&lt;=n-2;i++) scanf(&quot;%d&quot;,&amp;a[i]); b[1]=0; c[1]=0; b[2]=0; c[2]=0; int res1,res2,tmp; for (int i=3;i&lt;=n;i++)&#123; b[i]=b[i-2]; c[i]=c[i-1]; res1=getres(i-1); res2=getres(i); if (1ll*res1*res2&gt;0)&#123; if (res1&gt;0) tmp=min(res1,res2); else tmp=max(res1,res2); c[i-1]+=tmp; c[i]+=tmp; res1=getres(i-1); res2=getres(i); &#125; b[i-1]+=res1; res1=getres(i-1); if (b[i-1]&lt;0)&#123; tmp=-b[i-1]; b[i-1]+=tmp; c[i-1]-=tmp; c[i]-=tmp; res2=getres(i); &#125; if (c[i-1]&lt;0)&#123; tmp=-c[i-1]; c[i-1]+=tmp; c[i]+=tmp; b[i-1]-=tmp; res2=getres(i); &#125; &#125; b[1]=0; b[2]=0; c[1]=0; c[2]=0; b[n-1]=0; b[n]=0; c[n-1]=0; c[n]=0; ans=0; for (int i=3;i&lt;=n;i++) ans+=myabs(b[i]-b[i-2]); for (int i=2;i&lt;=n;i++) ans+=myabs(c[i]-c[i-1]); printf(&quot;%lld\\n&quot;,ans/2); &#125; return 0;&#125; Day2T1 现在只会 $30pts$。 先考虑树的做法，以 $1$ 号点为根考虑。 首先每棵子树都是独立的，就是 $Alice$ 往任何一棵子树走，和另外的子树没有关系。 设 $g[i]$ 表示 $i$ 的子树内，离 $i$ 距离最近的在 $S$ 中的点的距离，$f[i]$ 表示初始时 $Alice$ 在 $i$，$Bob$ 至少需要先额外行动多少个回合才能获胜（不可能获胜则为 $INF$）。 那么 $g[u]=\\min_{v\\in son[u]}g[v]+len(u,v)$，$f[u]=\\sum_{v\\in son[u]}\\max\\{\\min\\{g[v]+1,f[v]\\}-len(u,v)\\}$。（$+1$ 是因为 $Alice$ 先手，它要先到必须比 $Alice$ 快一步）。 所有在 $S$ 中的点，$g$ 为 $0$，$f$ 也为 $0$（这个 $f=0$ 可能不严谨，但是只要不对它父亲的 $f$ 有贡献就可以了）。 所有在 $T$ 中的点，$f$ 为 $INF$ （$Bob$ 不可能赢）。 这样我们可以发现，能得 $25pts$，分别是 $1,2,10,11,12$。其中 $10,11,12$ 把一个 $S$ 中的点拆开分成两个点，它就是一棵树了。在实现的时候不用显式拆开，因为这样的图对 $dp$ 过程其实是没有影响的。 剩下的 $5pts$，是 $15$，$|T|=1$。我们可以发现，实际上就是 $Bob$ 到 $T$ 中不经过 $1$ 号点的距离比 $Alice$ 严格小就可以了，只需要输出 $\\max\\{0,\\min\\{dist(s_i,t,\\texttt{不经过1号点})\\}-dist(1,t)+1\\}$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;ll,int&gt; pii;const ll INF=1ll&lt;&lt;60;int T,n,m,s,t;ll f[510],g[510]; bool is_s[510],is_t[510];int edgenum,vet[1100],val[1100],Next[1100],Head[510];void addedge(int u,int v,int cost)&#123; vet[++edgenum]=v; val[edgenum]=cost; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void dfs(int u,int fa)&#123; int v; if (is_s[u])&#123; g[u]=0; return;&#125; g[u]=INF; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (v!=fa)&#123; dfs(v,u); g[u]=min(g[u],g[v]+val[e]); &#125; &#125;&#125;void dfs2(int u,int fa)&#123; int v; if (is_s[u])&#123; f[u]=0; return;&#125; if (is_t[u])&#123; f[u]=INF; return;&#125; ll sum=0; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (v!=fa)&#123; dfs2(v,u); if (sum!=INF)&#123; if (f[vet[e]]==INF&amp;&amp;g[vet[e]]==INF) sum=INF; else sum+=max(min(g[vet[e]]+1,f[vet[e]])-val[e],0ll); &#125; &#125; &#125; f[u]=sum;&#125;ll dis[510]; bool vis[510];priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; que;void dijkstra(int s)&#123; for (int i=1;i&lt;=n;i++) dis[i]=INF,vis[i]=false; que.push(pii(0,s)); dis[s]=0; vis[1]=true; int u; while (!que.empty())&#123; u=que.top().second; que.pop(); if (vis[u]) continue; vis[u]=true; for (int e=Head[u];e;e=Next[e]) if (dis[vet[e]]&gt;dis[u]+val[e])&#123; dis[vet[e]]=dis[u]+val[e]; que.push(pii(dis[vet[e]],vet[e])); &#125; &#125;&#125; int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); edgenum=0; for (int i=1;i&lt;=n;i++) Head[i]=0; int u,v,c; for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); c++; addedge(u,v,c); addedge(v,u,c); &#125; for (int i=1;i&lt;=n;i++) is_s[i]=false; for (int i=1;i&lt;=n;i++) is_t[i]=false; for (int i=1;i&lt;=s;i++) scanf(&quot;%d&quot;,&amp;u),is_s[u]=true; for (int i=1;i&lt;=t;i++) scanf(&quot;%d&quot;,&amp;u),is_t[u]=true; if (t==1)&#123; int x; for (int i=1;i&lt;=n;i++) if (is_t[i]) x=i; dijkstra(x); ll ans=INF; for (int i=1;i&lt;=n;i++) if (is_s[i]) ans=min(ans,dis[i]); printf(&quot;%lld\\n&quot;,min(1000000ll,max(ans-dis[1]+1,0ll))); &#125; else&#123; dfs(1,0); dfs2(1,0); printf(&quot;%lld\\n&quot;,min(1000000ll,f[1])); &#125; &#125; return 0;&#125; Day2T2 前置知识： $min-max$ 容斥（期望形式）：$E(\\min(S))=\\sum_{T \\subseteq S}(-1)^{|T|+1}E(\\max(T))$，$\\min(S)=\\sum_{T \\subseteq S}(-1)^{|T|+1}\\max(T)$。本题中的 $E(\\min(S))$ 表示 $S$ 中至少有一段长度为 $k$ 的连续数字都出现的期望时间，$E(\\max(T))$ 表示 $T$ 中每一段长度为 $k$ 的连续数字都出现的期望时间（ $S,T$ 为段的集合）。 $70pts$（细节多，而且做复杂了，其实 $0/1$ 可以直接记在 $dp$ 值里） 设 $dp[i][j][0/1]$ 表示前 $i$ 个数，选了 $j$ 个数，集合大小奇偶性 $0/1$ 的方案数（其中第 $i$ 个数必须选），然后暴力 $dp$ ，枚举上一个选了的数，时间复杂度 $O(kn^2)$。 经过思考，由于值域是 $1\\cdots 2m$ ，可以设 $dp[i][j][0/1]$ 表示当前值为 $i$ 的方案数，然后对于每个 $i$ 都计算（不管有没有在 $a$ 中出现过），在转移的时候再判断，没有出现的位置就不要转移过来。 初始时，$dp[i][K][1]=1$。 1234567891011for (int j=1;j&lt;=m;j++)for (int k=0;k&lt;=1;k++)&#123; for (int t=1;t&lt;i;t++) if (max(j-K,t-(i-j))&gt;=0) dp[i][j][k]=(dp[i][j][k]+dp[t][max(j-K,t-(i-j))][k^1])%Mod;/* for (int t=1;t&lt;i-1;t++) if (max(j-1-K,t-(i-j))&gt;=0) dp[i-1][j-1][k]=(dp[i-1][j-1][k]+dp[t][max(j-1-K,t-(i-j))][k^1])%Mod; */&#125; 考虑 $dp[i][j][k]$ 和 $dp[i-1][j][k]$，相差的是一段前缀（上界不同）和 $dp[i-1][j-1][k\\oplus 1]$，然后一个前缀和即可，但是实际上细节也不少（前缀和要把在 $a$ 中出现过的更新进去，并且还要考虑 $j-1==K\\ and \\ k==0$的情况），也调了不少时间，代码（$70pts$）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int Mod=998244353;int m,K,a[210000],len[210000];int dp[2][5100][2],sum[10005][5005][2];int ans,Ans[210000];bool vis[410000];int getinv(int x)&#123; if (x==1) return 1; return 1ll*(Mod-Mod/x)*getinv(Mod%x)%Mod;&#125;inline int getnum(int x,int y,int z)&#123; if (x&lt;0) return 0; return (sum[x][y+1][z]-sum[x][y][z]+Mod)%Mod;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;K); for (int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+m+1); for (int i=m;i&gt;=1;i--)&#123; if (a[i+1]==a[i]+1) len[i]=len[i+1]; len[i]++; &#125; for (int i=1;i&lt;=m;i++) if (len[i]&gt;=K) vis[a[i]]=true; for (int j=1;j&lt;=m;j++) Ans[j]=(Ans[j-1]+1ll*m*getinv(j))%Mod; if (vis[1]) sum[1][K][1]=1; int now=0; for (int i=2;i&lt;=2*m;i++,now^=1)&#123; for (int j=1;j&lt;=m;j++) for (int k=0;k&lt;=1;k++) dp[now][j][k]=(dp[now^1][j-1][k]+getnum(i-K-1,j-(K+1),k^1))%Mod; dp[now^1][K][1]=(dp[now^1][K][1]+1)%Mod; if (vis[i-1])&#123; for (int j=0;j&lt;=m;j++) for (int k=0;k&lt;=1;k++) if (k&amp;1) ans=(ans+1ll*dp[now^1][j][k]*Ans[j])%Mod; else ans=(ans-1ll*dp[now^1][j][k]*Ans[j]%Mod+Mod)%Mod; &#125; for (int j=1;j&lt;=m;j++) for (int k=0;k&lt;=1;k++)&#123; if (vis[i-1]) dp[now][j][k]=(dp[now][j][k]+dp[now^1][j-1][k^1])%Mod; if (vis[i]) sum[i][j][k]=(sum[i-1][j][k]+dp[now][j][k])%Mod; else sum[i][j][k]=sum[i-1][j][k]; &#125; if (vis[i]) sum[i][K][1]=(sum[i][K][1]+1)%Mod; &#125; if (vis[2*m])&#123; dp[now][K][1]=(dp[now][K][1]+1)%Mod; for (int j=0;j&lt;=m;j++) for (int k=0;k&lt;=1;k++) if (k&amp;1) ans=(ans+1ll*dp[now][j][k]*Ans[j])%Mod; else ans=(ans-1ll*dp[now][j][k]*Ans[j]%Mod+Mod)%Mod; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; $100pts$ 我们可以发现一些性质：如果说我选了两个 $len=k$ 的段，它们有交集（1.）或者紧挨着一起（2.），并且第二段的开头和第一段的开头不相邻，那么它们的贡献实际上是没有的。如下图： 为啥呢，由于 $i..i+k-1$ 是连续的，$i+t..i+t+k-1$ 也是连续的，那么 $i..i+t+k-1$ 也是连续的（$t\\leq k$）。我们考虑这样： 如果我们固定最上面的和最下面的必选，那么相当于固定了 $min-max$ 容斥中的 $\\max(S)$，那么中间的 $i+1..i+t-1$ 开头的这些段选或不选对这个 $\\max$ 是没有影响的，影响的只是前面的容斥系数。 $i+1..i+t-1$ 开头的这些段选或不选的容斥系数之和，通过二项式定理，应该为 $\\binom{t-1}0(-1)^3+\\binom{t-1}1(-1)^4+\\binom{t-1}2(-1)^5+\\cdots+\\binom{t-1}{t-1}(-1)^{t+2}$，也就等于 $(-1)^3(1-1)^{t-1}=0$。（每一项系数是 $(-1)^{|T|+1}$） 要注意 $t=1$ 的时候是不能被抵消的。也就是只有可能是单独的 $len=k$ 的或开头连续的 $len=k+1$ 的（也就是两个 $len=k$ 开头连续的拼起来）。且所有段不能相交，两个 $len=k$ 的段之间不能连续。 现在考虑连续的 $len=k+1$ 的段和 $len=k$ 的段/ $len=k$ 的段和 $len=k+1$ 的段有没有贡献，这样的话相当于求长度为 $2k+1$ 的会不会全被抵消： 显然，我们发现它的贡献并不能被消掉，因为 $i+k$ 这个数它是必须被选的，也就是右端点在 $i+k..i+2k-1$ 之间的段必须选择一个。 如果这些段都可以选或不选，通过二项式定理，那么贡献应该为 $0$。 但是必须选一个的话，那么 $\\binom k0(-1)^3$ 这一项消失了，那么贡献应该为 $1$。也就是我们可以强制钦定 $k+1/k$ 或 $k/k+1$ 中 $k+1/k$ 有贡献。 再考虑两个连续的 $len=k+1$ 的段有没有贡献。同样的： 情况1：右端点在 $i+k+1..i+2k-1$ 之间的段必须选择一个。情况2：右端点在 $i+k$ 和 $i+2k$ 都选了。 两种情况满足其一才能算入答案。若均不满足，也就是 $i+k+1..i+2k-1$ 都没选， $i+k$ 和 $i+2k$ 只选了一个或都没选。 如果这些段都可以选或不选，通过二项式定理，那么贡献应该为 $0$。全不满足的情况： $i+k..i+2k$ 都没选，其它都选了，贡献 $(-1)^3=-1$。 $i+k..i+2k-1$ 都没选，其它都选了，贡献 $(-1)^4=1$。 $i+k+1..i+2k$ 都没选，其它都选了，贡献 $(-1)^4=1$。 故总贡献即为 $-1$，也就是 $(-1)^5$。（而 $k+1$ 本来就是长度为 $k$ 的 $4$ 个段，贡献即为 $-1$） 所以现在可以转化为，只选 $len=k/k+1$ 的段，其中 $len_1=k,len_2=k/k+1$ 的两个段不能的开头不能相邻，所有的段不能相交，问方案数。 我们可以在原序列中选出一些不相交的长为 $k+1$ 的段，然后考虑段中最后一个位置选/不选。可以发现，这样选出来不会出现 $len_1=k,len_2=k/k+1$ 的开头相邻的两个段。记长度为 $n$ 的连续段，这个算出来的生成函数为 $g_n(x)$。 但是有个问题，如果我选择了 $n-k+1..n$ 这个长度为 $k$ 的段，它不能通过 $n-k+1..n+1$ 这个段然后不选 $n+1$ 来得到，因为 $n+1$ 越界了。但是我们会发现，如果选了这个段之后，就必定不能选 $n-2k+1..n-k$ 这个长度为 $k$ 的段了，这个的生成函数恰好为 $-x^kg_{n-k}(x)$。 记 $f_n(x)$ 表示长度为 $n$ 的连续段的答案生成函数。有 f_n(x)=g_n(x)-x^kg_{n-k}(x)\\\\ g_n(x)=\\sum_{i=0}^{\\lfloor \\frac n{k+1}\\rfloor} \\binom{n-ik}{i} (x^{k+1}-x^k)^i 暴力计算时间复杂度为 $\\sum\\limits_{i=0}^{\\lfloor \\frac n{k+1}\\rfloor}i=O(\\frac{n^2}{k^2})$。然后它就水过了，水过了。。。。 当然，算 $g_n$ 的这个可以优化，我们考虑通过分治来计算。先令 $val_i=\\binom{n-ik}{i}$，则有 $ans(l,r)=\\sum\\limits_{i=l}^r val_i (x^{k+1}-x^k)^i=ans(l,mid)+ans(mid+1,r)\\times(x^{k+1}-x^k)^{mid-l+1}$，其中 $(x^{k+1}-x^k)^y=(x-1)^yx^{ky}$，而计算 $(x-1)^y$ 的时间复杂度为 $O(y)$，故这个分治的总时间复杂度为 $T(l)=2T(\\frac l2)+O(lk \\log lk)$，而这里的 $l$ 为原先的 $\\lfloor \\frac n{k+1}\\rfloor$，把 $k$ 提出来可得时间复杂度为 $O(k\\times \\frac nk\\log^2 \\frac nk+k\\times\\frac nk\\log \\frac nk\\log k)$。设 $n,k$ 同阶，故总时间复杂度为 $O(n \\log^2 n)$。 最后把这些生成函数乘起来，可以用分治 $NTT$，我这里用了一个类似于合并果子的东西，每次取次数最小的两个多项式乘起来。故总时间复杂度为 $O(m\\log^2 m)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vec;typedef pair&lt;int,int&gt; pii;const int Mod=998244353;const int G=3; const int invG=(Mod+1)/3;int m,k,a[210000],Ans[210000];int fac[210000],inv[210000],invfac[210000];vec poly[210000],v; int cnt;priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; que;inline int add(int x,int y)&#123; return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123; return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123; return 1ll*x*y%Mod;&#125;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;int rev[1100000];int GPow[2][19][1100000];void initG()&#123; for (int p=1;p&lt;=18;p++)&#123; int buf1=qpow(G,(Mod-1)/(1&lt;&lt;p)); int buf0=qpow(invG,(Mod-1)/(1&lt;&lt;p)); GPow[1][p][0]=GPow[0][p][0]=1; for (int i=1;i&lt;(1&lt;&lt;p);i++)&#123; GPow[1][p][i]=mul(GPow[1][p][i-1],buf1); GPow[0][p][i]=mul(GPow[0][p][i-1],buf0); &#125; &#125;&#125;void NTT(vec &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int l=2,cnt=1;l&lt;=len;l&lt;&lt;=1,cnt++)&#123; int m=l&gt;&gt;1; for (int i=0;i&lt;len;i+=l)&#123; int *buf=GPow[inv][cnt]; for (int j=0;j&lt;m;j++,buf++) &#123; int x=a[i+j],y=1ll*(*buf)*a[i+j+m]%Mod; a[i+j]=add(x,y),a[i+j+m]=dec(x,y); &#125; &#125; &#125; if (inv!=1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(vec &amp;a,vec &amp;b)&#123; int n=(int)a.size()+(int)b.size()-1; int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); a.resize(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],b[i]); NTT(a,len,0);&#125;vec tmp3;int val[210000];inline int C(int x,int y)&#123; if (x&lt;y) return 0; return mul(fac[x],mul(invfac[y],invfac[x-y]));&#125;vec solve(int l,int r)&#123; if (l==r)&#123; vec tmp; tmp.resize(1); tmp[0]=val[l]; return tmp; &#125; int mid=(l+r)&gt;&gt;1; vec tmp1=solve(l,mid),tmp2=solve(mid+1,r); int len=mid-l+1,t=k*len; tmp3.clear(); tmp3.resize(t+len+1); for (int i=0;i&lt;=len;i++) if ((len-i)&amp;1) tmp3[i+t]=dec(0,C(len,i)); else tmp3[i+t]=C(len,i); mult(tmp3,tmp2); tmp3.resize(max(tmp3.size(),tmp1.size())); for (int i=0;i&lt;(int)tmp1.size();i++) tmp3[i]=add(tmp3[i],tmp1[i]); return tmp3;&#125;vec v1,v2;void getans(int n)&#123; if (n&lt;k) return; int i,s; for (i=0,s=0;s+i&lt;=n;i++,s+=k) val[i+1]=C(n-s,i); v1=solve(1,i); for (i=0,s=k;s+i&lt;=n;i++,s+=k) val[i+1]=C(n-s,i); v2=solve(1,i); v1.resize(max(v1.size(),v2.size()+k)); for (int i=0;i&lt;(int)v2.size();i++) v1[i+k]=dec(v1[i+k],v2[i]); while ((int)v1.size()&gt;1&amp;&amp;!v1.back()) v1.pop_back(); poly[++cnt]=v1;&#125;int main()&#123; m=read(); k=read(); initG(); fac[0]=1; for (int i=1;i&lt;=m+1;i++) fac[i]=mul(fac[i-1],i); inv[1]=1; for (int i=2;i&lt;=m+1;i++) inv[i]=mul((Mod-Mod/i),inv[Mod%i]); for (int i=1;i&lt;=m;i++) Ans[i]=add(Ans[i-1],mul(m,inv[i])); invfac[0]=1; for (int i=1;i&lt;=m+1;i++) invfac[i]=mul(invfac[i-1],inv[i]); for (int i=1;i&lt;=m;i++) a[i]=read(); sort(a+1,a+m+1); for (int i=1,j=0;i&lt;=m;i=j+1)&#123; j=i; while (j&lt;m&amp;&amp;a[j+1]==a[j]+1) j++; getans(j-i+1); &#125; for (int i=1;i&lt;=cnt;i++) que.push(pii((int)poly[i].size(),i)); while (que.size()&gt;1)&#123; int x=que.top().second; que.pop(); int y=que.top().second; que.pop(); mult(poly[x],poly[y]); que.push(pii((int)poly[x].size(),x)); &#125; int x=que.top().second,ans=0; for (int i=1;i&lt;(int)poly[x].size()&amp;&amp;i&lt;=m;i++) ans=add(ans,mul(Ans[i],dec(0,poly[x][i]))); printf(&quot;%d\\n&quot;,ans); return 0;&#125; Day2T3 现在只会 $10pts$。 就是直接枚举 $b_1$，然后算出 $x$ 代入后面的方程，看 $b_i$ 符不符合条件，符合就输出结束。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;using namespace std;typedef long long ll;int T,m,err;ll p,a[2100],c[2100];inline ll add(ll x,ll y)&#123;return x+y&gt;=p?x+y-p:x+y;&#125;inline ll dec(ll x,ll y)&#123;return x-y&lt;0?x-y+p:x-y;&#125;ll mul(ll x,ll a)&#123; ll res=0; while (a)&#123; if (a&amp;1) res=add(res,x); x=add(x,x); a&gt;&gt;=1; &#125; return res;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=mul(res,x); x=mul(x,x); a&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%d%lld%d&quot;,&amp;m,&amp;p,&amp;err); err=(err+1)/2; for (int i=1;i&lt;=m;i++) scanf(&quot;%lld%lld&quot;,&amp;a[i],&amp;c[i]); ll inva=qpow(a[1],p-2),x,y; for (ll t=c[1]-err;t&lt;=c[1]+err;t++)&#123; x=t; if (x&lt;0) x+=p; if (x&gt;=p) x-=p; x=mul(x,inva); bool flag=true; for (int i=2;i&lt;=m;i++)&#123; y=dec(mul(a[i],x),c[i]); if (y&gt;=p) y-=p; if (y&gt;err&amp;&amp;y&lt;p-err)&#123; flag=false; break; &#125; &#125; if (flag)&#123; printf(&quot;%lld\\n&quot;,x); break; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"ZJOI2020","slug":"ZJOI2020","permalink":"http://hydd.cf/categories/ZJOI2020/"}],"tags":[]},{"title":"20200713 五大强校联考题解","slug":"sol_17","date":"2020-07-12T16:00:00.000Z","updated":"2020-10-01T04:59:12.023Z","comments":true,"path":"2020/07/13/sol_17/","link":"","permalink":"http://hydd.cf/2020/07/13/sol_17/","excerpt":"","text":"这把我们就遇到了高手了（master） 首先，显然横纵坐标是可以分开的，我们将两维坐标拆开分别考虑。 一维的问题就变成了环，我们把环上的坐标看做一个集合 $S$。 可以发现一个性质：每个技能恰好把集合 $S$ 分成了两个子集 $A,B$， $A\\cap B=\\varnothing,A\\cup B=S$ 。不妨称为里面或者外面。 我们发现对于任意一个点 $x$ ，假如所有技能包含了它，那么技能的释放是唯一的（因为集合不交）。 那么做法就很简单了，首先离散化，对于离散化后剩下的点，看包含他的技能是里面还是外面，记成一个 $0/1$ 串 $T$，求出这个点代表的原序列中的点的个数，用 $map[hash(T)]$ 记录点个数和，最后求 $map$ 中的最大值。 时间复杂度 $O(n\\log n)$。可以使用 $unordered_map$ 来代替 $map$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/********************************************************************* Problem:master Author:hydd Date:2020/7/13*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int Mod1=1e9+7;const int Mod2=1e9+9;int n,w,h,ans1,ans2;int cntx,x[1100000],cnty,y[1100000];int pow1[1100000],pow2[1100000];pii hash_num;unordered_map&lt;ll,int&gt; mpa,mpb;vector&lt;int&gt; veca[1100000],vecb[1100000];struct node&#123; int l,r;&#125; a[1100000],b[1100000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add1(int x,int y)&#123; return x+y&gt;=Mod1?x+y-Mod1:x+y;&#125;inline int add2(int x,int y)&#123; return x+y&gt;=Mod2?x+y-Mod2:x+y;&#125;inline int dec1(int x,int y)&#123; return x-y&lt;0?x-y+Mod1:x-y;&#125;inline int dec2(int x,int y)&#123; return x-y&lt;0?x-y+Mod2:x-y;&#125;void work(int x)&#123; if (x&gt;0) hash_num=pii(add1(hash_num.first,pow1[x-1]),add2(hash_num.second,pow2[x-1])); else hash_num=pii(dec1(hash_num.first,pow1[-x-1]),dec2(hash_num.second,pow2[-x-1]));&#125;int main()&#123; freopen(&quot;master.in&quot;,&quot;r&quot;,stdin); freopen(&quot;master.out&quot;,&quot;w&quot;,stdout); pow1[0]=1; pow2[0]=1; for (int i=1;i&lt;=1000000;i++) pow1[i]=pow1[i-1]*3ll%Mod1; for (int i=1;i&lt;=1000000;i++) pow2[i]=pow2[i-1]*5ll%Mod2; n=read(); w=read(); h=read(); x[++cntx]=0; y[++cnty]=0; for (int k=1;k&lt;=n;k++)&#123; a[k].l=read(); b[k].l=read(); a[k].r=read(); b[k].r=read(); x[++cntx]=a[k].l; y[++cnty]=b[k].l; x[++cntx]=a[k].r; y[++cnty]=b[k].r; &#125; sort(x+1,x+cntx+1); sort(y+1,y+cnty+1); cntx=unique(x+1,x+cntx+1)-x-1; cnty=unique(y+1,y+cnty+1)-y-1; x[cntx+1]=w; y[cnty+1]=h; for (int k=1;k&lt;=n;k++)&#123; a[k].l=lower_bound(x+1,x+cntx+1,a[k].l)-x; a[k].r=lower_bound(x+1,x+cntx+1,a[k].r)-x; veca[a[k].l].push_back(k); veca[a[k].r].push_back(-k); b[k].l=lower_bound(y+1,y+cnty+1,b[k].l)-y; b[k].r=lower_bound(y+1,y+cnty+1,b[k].r)-y; vecb[b[k].l].push_back(k); vecb[b[k].r].push_back(-k); &#125; int tmp; hash_num=pii(0,0); for (int i=1;i&lt;=cntx;i++)&#123; for (int j=0;j&lt;(int)veca[i].size();j++) work(veca[i][j]); tmp=1ll*hash_num.first*Mod2+hash_num.second; mpa[tmp]+=(x[i+1]-x[i]); ans1=max(ans1,mpa[tmp]); &#125; hash_num=pii(0,0); for (int i=1;i&lt;=cnty;i++)&#123; for (int j=0;j&lt;(int)vecb[i].size();j++) work(vecb[i][j]); tmp=1ll*hash_num.first*Mod2+hash_num.second; mpb[tmp]+=(y[i+1]-y[i]); ans2=max(ans2,mpb[tmp]); &#125; printf(&quot;%lld\\n&quot;,1ll*ans1*ans2); return 0;&#125; ok起飞（okfly） 原题：$hdu6350$。 很容易证明，其实对图的限制就是仙人掌，部分分只是用来骗人的。 那么考虑从 $s$ 到 $t$ 的最大流。 若 $s,t$ 是一个环上的两点，那么最大流就会等于两条路径上的最短边的之和 我们将所有的环上最短边加到环上其他边上去，最大流不会改变。 所以我们让其余边加上最短边后去掉最短边，这样这个图就变成了一棵树 按边长从大到小排序，依次加入每一条边，然后将两个分量合并成一个点 取出的边长就是两个联通分量间的最大流，因为每次取出的边都比之前取出的更小。 求异或值就把每一位分开考虑，记联通分量的每个二进制位分别有多少个 $0/1$ 即可。 复杂度 $O(m\\log w)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/********************************************************************* Problem:okfly Author:hydd Date:2020/7/13*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ull;int T,n,m,len[210000],fa[210000],c[210000][32][2];int edgenum,vet[410000],val[410000],Next[410000],Head[210000];int tot;struct edge&#123; int u,v,c; edge()&#123;&#125; edge(int x,int y,int w)&#123; u=x; v=y; c=w;&#125; bool operator&lt;(const edge &amp;a) const&#123; return c&gt;a.c;&#125;&#125; tree[810000];int tmp[210000];void addedge(int u,int v,int cost)&#123; vet[++edgenum]=v; val[edgenum]=cost; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void cir(int u,int v,int l)&#123; int x,cnt; x=v; cnt=0; while (x!=u) tmp[++cnt]=len[x],x=fa[x]; tmp[++cnt]=l; int mn=1,c=tmp[1]; for (int i=2;i&lt;=cnt;i++) if (tmp[i]&lt;c) mn=i,c=tmp[i]; x=v; cnt=0; while (x!=u)&#123; cnt++; if (mn!=cnt) tree[++tot]=edge(fa[x],x,len[x]+c); x=fa[x]; &#125; cnt++; if (mn!=cnt) tree[++tot]=edge(v,u,l+c);&#125;int dfn[210000],low[210000],dtime;void tarjan(int u,int f)&#123; dfn[u]=low[u]=++dtime; fa[u]=f; int v; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (v==f) continue; if (!dfn[v])&#123; len[v]=val[e]; tarjan(v,u); low[u]=min(low[u],low[v]); &#125; else low[u]=min(low[u],dfn[v]); &#125; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (low[v]&gt;dfn[u]) tree[++tot]=edge(u,v,val[e]); else if (dfn[v]&gt;dfn[u]&amp;&amp;fa[v]!=u) cir(u,v,val[e]); &#125;&#125;int findset(int u)&#123; if (u!=fa[u]) fa[u]=findset(fa[u]); return fa[u];&#125;int main()&#123; freopen(&quot;okfly.in&quot;,&quot;r&quot;,stdin); freopen(&quot;okfly.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); edgenum=1; for (int i=1;i&lt;=n;i++) Head[i]=0; int u,v,cost; for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;cost); addedge(u,v,cost); addedge(v,u,cost); &#125; dtime=0; tot=0; for (int i=1;i&lt;=n;i++) fa[i]=0,dfn[i]=0; tarjan(1,0); for (int i=1;i&lt;=n;i++)&#123; fa[i]=i; for (int j=0;j&lt;=30;j++)&#123; c[i][j][0]=((i&gt;&gt;j)&amp;1)^1; c[i][j][1]=(i&gt;&gt;j)&amp;1; &#125; &#125; sort(tree+1,tree+tot+1); ull ans=0; for (int i=1;i&lt;=tot;i++)&#123; u=findset(tree[i].u); v=findset(tree[i].v); cost=tree[i].c; for (int j=0;j&lt;=30;j++) if ((cost&gt;&gt;j)&amp;1)&#123; ans+=(((ull)c[u][j][1]*c[v][j][1])&lt;&lt;j); ans+=(((ull)c[u][j][0]*c[v][j][0])&lt;&lt;j); &#125; else&#123; ans+=(((ull)c[u][j][0]*c[v][j][1])&lt;&lt;j); ans+=(((ull)c[u][j][1]*c[v][j][0])&lt;&lt;j); &#125; fa[v]=u; for (int j=0;j&lt;=30;j++)&#123; c[u][j][0]+=c[v][j][0]; c[u][j][1]+=c[v][j][1]; &#125; &#125; printf(&quot;%llu\\n&quot;,ans); &#125; return 0;&#125; 这钵和餐厅配合的不是很好（restaurant） 这题要求的是 $\\displaystyle \\sum_{\\{p_i\\}}\\prod_{i=2}^n\\tfrac{1}{\\sum\\limits_{j=1}^i b_j}$ 。 看看有没有什么组合意义。我们考虑这样的式子：$\\displaystyle \\sum_{\\{p_i\\}}\\prod_{i=1}^n\\tfrac{b_i}{\\sum\\limits_{j=1}^i b_j}$。 考虑 $i$ 从 $n$ 到 $1$ 枚举，可以看做选数然后删掉的过程，某个数被选到的概率即为它的权值占总共的比例。上面的式子相当于依次删去 $b_n,b_{b-1},\\cdots,b_1$ 的概率。 如果我们固定 $b_1$，前面有个求和，就可以看成，对于每个 $b_1$（$a_{p_1}$），它是最后一个被删去的概率为多少（因为后面枚举了所有 $b_1$ 是最后一个被删去的情况）。 于是这个式子就相当于：$\\displaystyle \\sum_i P(a_i\\texttt{ was last deleted})$。 现在我们考虑如何计算这个式子。设最后一个被删去的数为 $x$。 发现一个数是最后一个被删去的概率不太好算，但是它是第一个被删去的概率比较好算。 我们钦定 $x$ 被删之后有哪些数没被删，至少集合 $S$ 中的数比 $x$ 后删去。 很显然因为剩下的数随便，总概率为 $1$ ，无需考虑，只需要考虑 $S$ 中的数对 $x$ 的贡献。 记 $sum(S)$ 为集合 $S$ 中的数之和。那么 $x$ 比集合 $S$ 中的数先删去的概率为 $\\frac{x}{x+sum(S)}$。 我们证明一下： 首先我们做这样一个转化：如果一个数被删去，他不直接被移除。若某一步要删掉已经删去了的数，就重新再删一次。这样删去每个数的概率已经与原来相同。记 $A=\\sum a_i$。 那么答案概率为 $P=\\displaystyle \\sum_{i=0}^\\infty (1-\\tfrac {sum(S)+x}A)^i\\frac xA$。 有 $P-(1-\\tfrac {sum(S)+x}A)P=\\frac xA$，$P=\\frac{\\frac{x}{A}}{1-(1-\\tfrac {sum(S)+x}A)}=\\frac{\\frac{x}{A}}{\\frac{sum(S)+x}A}=\\frac{x}{sum(S)+x}$。 容斥一下可以发现，答案为 $\\displaystyle \\sum_S(-1)^{|S|} \\tfrac{x}{x+sum(S_i)}$。 对于每个 $x$，容斥系数每一个元素不为 $x$ 的数的生成函数相乘的多项式系数，其中 $a_i$ 的生成函数为 $(1-t^{a_i})$。（$t$ 为自变量） 注意到 $\\sum a_i$ 至多只有 $200000$，我们可以背包算出每个 $sum(S_i)$ 出现了多少次，顺便把容斥系数带上即可。时间复杂度 $O(n\\sum a_i)$。 考虑如何解决原问题，就是在我们枚举第一个元素是 $x$ 后，它的答案对原问题的答案的贡献系数为$\\frac {x}{\\prod\\limits_i b_i}$。 123456789101112131415161718192021222324252627282930313233343536373839/********************************************************************* Problem:restaurant Author:hydd Date:2020/7/13*********************************************************************/#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int Mod=998244353;int n,m,a[210];int f[310000],t[310000];ll inv[310000];int main()&#123; freopen(&quot;restaurant.in&quot;,&quot;r&quot;,stdin); freopen(&quot;restaurant.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); f[0]=1; m=0;//f(t)=1，m为最高次数 for (int i=1;i&lt;=n;i++)&#123;//f(t)*=(1-t^a[i]) for (int j=m;j&gt;=0;j--) f[j+a[i]]=(f[j+a[i]]-f[j]+Mod)%Mod; m+=a[i]; &#125; inv[1]=1; for (int i=2;i&lt;=m;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; ll mul=1; for (int i=1;i&lt;=n;i++) mul=mul*inv[a[i]]%Mod; int ans=0; for (int i=1;i&lt;=n;i++)&#123; for (int j=0;j&lt;=m;j++) t[j]=f[j]; for (int j=0;j&lt;=m-a[i];j++) t[j+a[i]]=(t[j+a[i]]+t[j])%Mod; int sum=0; for (int j=0;j&lt;=m-a[i];j++) sum=(sum+1ll*t[j]*inv[j+a[i]])%Mod; sum=1ll*sum*a[i]%Mod; ans=(ans+1ll*mul*a[i]%Mod*sum)%Mod; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"NOI模拟赛","slug":"NOI模拟赛","permalink":"http://hydd.cf/categories/NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"省选联考2020 题解","slug":"sol_18","date":"2020-07-11T16:00:00.000Z","updated":"2020-09-30T13:30:51.724Z","comments":true,"path":"2020/07/12/sol_18/","link":"","permalink":"http://hydd.cf/2020/07/12/sol_18/","excerpt":"","text":"Day1T1 记$pre_{0/1},suf_{0/1}$分别表示两种战士的能量前/后缀和 要求 $\\min\\{pre_0[i],suf_1[i]\\}$，而 $suf_1[i]=sum_1-pre_1[i]+val_1[i]$。 为了常数小我们考虑树状数组。 首先对温度离散化，因为答案一定是某个战士的温度（即在 $x$ 中出现过的）。 然后，我们从前往后考虑每个询问： 首先，在树状数组上二分，求出满足 $pre_0[i]\\leqslant suf_1[i]$ 最大的 $i$。此时，设 $pre_0[i]=v_0,pre_1[i]=v_1+val_1[i]$。 若 $v_0=v_1=0$，那么显然 $\\texttt{Peace}$。 若 $v_0&gt;v_1$，那么 $i$ 变大后答案最多为 $v_1$，而此时答案为 $v_0$，故最终位置即为 $i$。 否则，就把 $i$ 再往后，使得答案为 $v_1$，且 $i$ 尽可能大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int Q,op[2100000],a[2100000],x[2100000],y[2100000];int s0[2100000],s1[2100000];int sum0,sum1,tree0[2100000],tree1[2100000];int cnt,num[2100000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void add(int *tree,int x,int v)&#123; for (;x&lt;=cnt;x+=x&amp;-x) tree[x]+=v;&#125;void solve()&#123; int p=0,v,v0=0,v1=sum1,new_p; for (int i=20;i&gt;=0;i--)&#123; new_p=p|(1&lt;&lt;i); if (new_p&lt;=cnt&amp;&amp;v0+tree0[new_p]&lt;=v1-tree1[new_p]+s1[new_p])&#123; p=new_p; v0+=tree0[p]; v1-=tree1[p]; &#125; &#125; if (!v0&amp;&amp;!v1) puts(&quot;Peace&quot;); else if (v0&gt;v1) printf(&quot;%d %d\\n&quot;,num[p],(v0&lt;&lt;1)); else&#123; p=0; v=sum1-v1; for (int i=20;i&gt;=0;i--)&#123; new_p=p|(1&lt;&lt;i); if (new_p&lt;=cnt&amp;&amp;v&gt;=tree1[new_p])&#123; p=new_p; v-=tree1[p]; &#125; &#125; printf(&quot;%d %d\\n&quot;,num[p+1],(v1&lt;&lt;1)); &#125;&#125;int main()&#123; Q=read(); int t; for (int i=1;i&lt;=Q;i++)&#123; op[i]=read(); t=read(); if (op[i]==1)&#123; a[i]=t; x[i]=read(); y[i]=read(); num[++cnt]=x[i]; &#125; else&#123; a[i]=a[t]; x[i]=x[t]; y[i]=-y[t]; &#125; &#125; sort(num+1,num+cnt+1); cnt=unique(num+1,num+cnt+1)-num-1; for (int i=1;i&lt;=Q;i++) x[i]=lower_bound(num+1,num+cnt+1,x[i])-num; for (int i=1;i&lt;=Q;i++)&#123; if (!a[i]) add(tree0,x[i],y[i]),s0[x[i]]+=y[i],sum0+=y[i]; else add(tree1,x[i],y[i]),s1[x[i]]+=y[i],sum1+=y[i]; solve(); &#125; return 0;&#125; Day1T2 把普通多项式多项式转化成下降幂多项式的形式，$f(k)=\\sum_{i=0}^mb_ix^\\underline i$。 怎么转呢？利用 $\\displaystyle x^n=\\sum_{k=1}^nS(n,k)x^\\underline k$ 。其中第二类斯特林数 $S(n,k)=S(n−1,k−1)+S(n−1,k)∗k$。 \\sum_{k=0}^nf(k)\\times x^k \\times \\binom{n}{k}=\\sum_{k=0}^n\\sum_{i=0}^{\\min(m,k)}b_ik^\\underline ix^k\\binom{n}{k}\\\\=\\sum_{i=0}^mb_in^\\underline i\\sum_{k=i}^{n}x^k\\binom{n-i}{k-i}\\\\=\\sum_{i=0}^mb_in^\\underline ix^{i}(x+1)^{n-i}123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll n,x,mod,m,ans;ll a[1100],s[1100][1100];ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%mod; x=x*x%mod; a&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;x,&amp;mod,&amp;m); for (ll i=0;i&lt;=m;i++) scanf(&quot;%lld&quot;,&amp;a[i]); s[0][0]=1; for (ll i=1;i&lt;=m;i++) for (ll j=1;j&lt;=i;j++) s[i][j]=(s[i-1][j-1]+1ll*s[i-1][j]*j)%mod; for (ll j=0;j&lt;=m;j++)&#123; ll tmp=1,xp=1; for (ll i=0;i&lt;=j;i++)&#123; ans=(ans+1ll*a[j]*s[j][i]%mod*tmp%mod*xp%mod*qpow(x+1,n-i))%mod; tmp=1ll*tmp*(n-i)%mod; xp=1ll*xp*x%mod; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; Day1T330pts 强基交换定理：对于任意拟阵$M$，若$M$有两个不相同的基$A,B$，那么$\\forall x\\in A\\setminus B,\\exists y\\in B\\setminus A,s.t.A-\\{x\\}+\\{y\\},B-\\{y\\}+\\{x\\}$都是$M$的基。 我们只需考虑在 $A/B$ 中删去一个元素，加入新的元素的基和它们的大小关系，只需枚举 $A/B$ 中元素的价格，剩下的直接计算即可。 +10pts 原来的所有的 $\\leqslant,\\geqslant$ 的关系都变成 $=$ 的关系。 而点集 $U$ 的 $L_2$ 均值为其加权平均数 $\\displaystyle \\frac{\\sum_{v_i\\in U}w_iy_i}{\\sum_{v_i\\in U}w_i}$（导数易证，定义见高睿泉《浅谈保序回归问题》IOI2018国家集训队论文集）。并查集合并相等关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;typedef unsigned long long ull;typedef long long ll;const ll INF=1ll&lt;&lt;60;int n,m,a[1100],b[1100],fa[1100];int v[1100],x[1100],minv,maxv;bool trans[1100][1100],vis[1100];ull c[1100],num[64]; ll ans;int cnt; int pos[1100];vector&lt;int&gt; vec[1100];int findset(int x)&#123; if (x!=fa[x]) fa[x]=findset(fa[x]); return fa[x];&#125;void Union(int x,int y)&#123; x=findset(x); y=findset(y); if (x!=y) fa[y]=x;&#125;void ins(ull x)&#123; for (int i=63;i&gt;=0;i--) if ((x&gt;&gt;i)&amp;1)&#123; if (!num[i])&#123; cnt++; num[i]=x; break;&#125; x^=num[i]; &#125;&#125;void work()&#123; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; cnt=0; memset(num,0,sizeof(num)); int tmp=a[j]; a[j]=i; for (int k=1;k&lt;=m;k++) ins(c[a[k]]); a[j]=tmp; if (cnt==m) trans[a[j]][i]=1;//x[a[j]]&lt;x[i] &#125;&#125;void work2()&#123; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; cnt=0; memset(num,0,sizeof(num)); int tmp=b[j]; b[j]=i; for (int k=1;k&lt;=m;k++) ins(c[b[k]]); b[j]=tmp; if (cnt==m) trans[i][b[j]]=1;//x[i]&lt;x[b[j]] &#125;&#125;void dfs(int u)&#123; if (u&gt;cnt)&#123; ll sum=0; for (int i=1;i&lt;=n;i++) if (vis[i]) sum+=1ll*(x[i]-v[i])*(x[i]-v[i]); else&#123; int L=minv,R=maxv; for (int j=1;j&lt;=cnt;j++)&#123; if (trans[pos[j]][i]) L=max(L,x[pos[j]]); if (trans[i][pos[j]]) R=min(R,x[pos[j]]); &#125; if (L&gt;R)&#123; sum=INF; break;&#125; if (v[i]&lt;L) sum+=1ll*(L-v[i])*(L-v[i]); if (v[i]&gt;R) sum+=1ll*(v[i]-R)*(v[i]-R); &#125; ans=min(ans,sum); return; &#125; int L=minv,R=maxv; for (int i=1;i&lt;u;i++)&#123; if (trans[pos[i]][pos[u]]) L=max(L,x[pos[i]]); if (trans[pos[u]][pos[i]]) R=min(R,x[pos[i]]); &#125; for (int i=L;i&lt;=R;i++)&#123; x[pos[u]]=i; dfs(u+1);&#125;&#125;int main()&#123;// freopen(&quot;shop.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;shop.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); minv=1e6; maxv=0; for (int i=1;i&lt;=n;i++) scanf(&quot;%llu&quot;,&amp;c[i]); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;v[i]); minv=min(minv,v[i]); maxv=max(maxv,v[i]); &#125; for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); vis[a[i]]=true; &#125; for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d&quot;,&amp;b[i]); vis[b[i]]=true; &#125; work(); work2(); cnt=0; for (int i=1;i&lt;=n;i++) if (vis[i]) pos[++cnt]=i; if (cnt==m)&#123; for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (trans[i][j]) Union(i,j); for (int i=1;i&lt;=n;i++) vec[findset(i)].push_back(i); ll sum,sum1,sum2,now; int tot; for (int i=1;i&lt;=n;i++)&#123; sum=0; tot=0; for (int j=0;j&lt;(int)vec[i].size();j++) sum+=v[vec[i][j]],tot++; if (tot)&#123; now=(ll)(1.0*sum/tot); sum1=0; for (int j=0;j&lt;(int)vec[i].size();j++) sum1+=1ll*(now-v[vec[i][j]])*(now-v[vec[i][j]]); now++; sum2=0; for (int j=0;j&lt;(int)vec[i].size();j++) sum2+=1ll*(now-v[vec[i][j]])*(now-v[vec[i][j]]); ans+=min(sum1,sum2); &#125; &#125; &#125; else&#123; ans=INF; dfs(1); &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; 100pts 这个做法要用到 $30pts$ 建的图。（建图方法要优化一下） 我们把图建出来之后，原题就变成了一个保序回归问题。 由论文的知识，若要求每个物品的价格为 $k/k+1$，这个问题的解。一定存在原问题的一组最优解（每个物品的价格没有限制的最小回归代价）且可以通过向 $[k,k+1]$ 取整得到这个问题的最优解。 那么，我们求出每个物品价格为 $k/k+1$ 时的答案，就能知道必有一组最优解，现在取 $k$ 的物品最终价格都 $\\leq k$，取 $k+1$ 的物品最终价格都 $\\geq k+1$。 将两边分开递归计算答案，它们之间显然是相互不影响的。 取 $k=mid=\\frac{l+r}2$ 即可，用整体二分的思想，分成两部分，递归即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;typedef unsigned long long ull;const ull INF=1ll&lt;&lt;60;const int infdep=0x3f3f3f3f;int n,m,a[1100],b[1100],fa[1100];int v[1100],x[1100],minv,maxv;bool trans[1100][1100],vis[1100];ull c[1100],num[64]; ull ans[1100];int cnt; int pos[1100];vector&lt;int&gt; vec[1100],edge[1100];namespace dinic&#123; int s,t,dep[1100]; ull F[310000]; int vis[1100];//是否到达过该点 int edgenum=1,V[310000],Next[310000],Head[1100]; void addedge(int u,int v,ull f)&#123; V[++edgenum]=v; F[edgenum]=f; Next[edgenum]=Head[u]; Head[u]=edgenum; &#125; void link(int u,int v,ull f)&#123; addedge(u,v,f); addedge(v,u,0); &#125; bool bfs()&#123; for (int i=1;i&lt;=t;i++) vis[i]=false,dep[i]=infdep; dep[s]=0; vis[s]=true; queue&lt;int&gt; que; que.push(s); while (!que.empty())&#123; int u=que.front(); que.pop(); vis[u]=false; for (int e=Head[u];e;e=Next[e])&#123; int d=V[e]; if (dep[d]&gt;dep[u]+1&amp;&amp;F[e])&#123; dep[d]=dep[u]+1; if (!vis[d])&#123; que.push(d); vis[d]=true; &#125; &#125; &#125; &#125; return dep[t]&lt;infdep; &#125; ull dfs(int u,ull flow)&#123; if (u==t)&#123; vis[t]=true; //maxflow+=flow; return flow; &#125; ull used=0; vis[u]=true; for (int e=Head[u];e;e=Next[e])&#123; int d=V[e]; if ((!vis[d]||d==t)&amp;&amp;F[e]&amp;&amp;dep[d]==dep[u]+1)&#123; int minflow=dfs(d,min(flow-used,F[e])); if (minflow!=0) F[e]-=minflow,F[e^1]+=minflow,used+=minflow; if (used==flow) break; &#125; &#125; return used; &#125; void maxflow()&#123; while (bfs())&#123; vis[t]=1; while (vis[t])&#123; for (int i=1;i&lt;=t;i++) vis[i]=false; dfs(s,INF); &#125; &#125; &#125; void init(int m)&#123; s=m+1; t=m+2; edgenum=1; for (int i=1;i&lt;=t;i++) Head[i]=0; &#125;&#125;inline ull sqr(int x)&#123; if (x&lt;0) x=-x; return (ull)x*x;&#125;void ins(ull x)&#123; for (int i=63;i&gt;=0;i--) if ((x&gt;&gt;i)&amp;1)&#123; if (!num[i])&#123; cnt++; num[i]=x; break;&#125; x^=num[i]; &#125;&#125;bool couldins(ull x)&#123; for (int i=63;i&gt;=0;i--) if ((x&gt;&gt;i)&amp;1)&#123; if (!num[i]) return 1; x^=num[i]; &#125; return 0;&#125;void work()&#123; /*for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; if (a[j]==i) continue; cnt=0; memset(num,0,sizeof(num)); int tmp=a[j]; a[j]=i; for (int k=1;k&lt;=m;k++) ins(c[a[k]]); a[j]=tmp; if (cnt==m) edge[i].push_back(a[j]); //x[a[j]]&lt;x[i] &#125;*/ for (int j=1;j&lt;=m;j++)&#123; cnt=0; memset(num,0,sizeof(num)); for (int k=1;k&lt;=m;k++) if (k!=j) ins(c[a[k]]); for (int i=1;i&lt;=n;i++)&#123; if (a[j]==i) continue; if (cnt+couldins(c[i])==m) edge[i].push_back(a[j]); //x[a[j]]&lt;x[i] &#125; &#125; &#125;void work2()&#123; for (int j=1;j&lt;=m;j++)&#123; cnt=0; memset(num,0,sizeof(num)); for (int k=1;k&lt;=m;k++) if (k!=j) ins(c[b[k]]); for (int i=1;i&lt;=n;i++)&#123; if (b[j]==i) continue; if (cnt+couldins(c[i])==m) edge[b[j]].push_back(i); //x[i]&lt;x[b[j]] &#125; &#125;&#125;int p[1100],q[1100],id[1100];void solve(int l,int r,int L,int R)&#123; //x[a]&lt;=x[b],\\sum (x[i]-v[i])^2 if (l&gt;r) return; if (L==R)&#123; for (int i=l;i&lt;=r;i++) ans[p[i]]=L; return; &#125; int mid=(L+R)&gt;&gt;1; dinic::init(r-l+1); for (int i=l;i&lt;=r;i++) id[p[i]]=i-l+1; int u; for (int i=l;i&lt;=r;i++)&#123; u=p[i]; if (v[u]&gt;mid) dinic::link(i-l+1,dinic::t,sqr(v[u]-mid)-sqr(v[u]-mid-1)); else dinic::link(dinic::s,i-l+1,sqr(mid+1-v[u])-sqr(mid-v[u])); for (int j:edge[u]) if (id[j]) dinic::link(i-l+1,id[j],INF); &#125; for (int i=l;i&lt;=r;i++) id[p[i]]=0; dinic::maxflow(); int x=l,y=r; for (int i=l;i&lt;=r;i++) if (dinic::dep[i-l+1]!=infdep) q[x++]=p[i]; else q[y--]=p[i]; for (int i=l;i&lt;=r;i++) p[i]=q[i]; solve(l,x-1,L,mid); solve(y+1,r,mid+1,R);&#125;int main()&#123;// freopen(&quot;shop.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;shop.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); minv=1e6; maxv=0; for (int i=1;i&lt;=n;i++) scanf(&quot;%llu&quot;,&amp;c[i]); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;v[i]); minv=min(minv,v[i]); maxv=max(maxv,v[i]); &#125; for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); vis[a[i]]=true; &#125; for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d&quot;,&amp;b[i]); vis[b[i]]=true; &#125; work(); work2(); for (int i=1;i&lt;=n;i++) p[i]=i; solve(1,n,minv,maxv); ull sum=0; for (int i=1;i&lt;=n;i++) sum+=sqr(v[i]-ans[i]); printf(&quot;%llu\\n&quot;,sum); return 0;&#125; Day2T1 状压dp即可，将答案按系数分开计算。 为了节省空间，求出入边的数量需要由一种奇怪的方法求，详见代码。 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int n,m,k,SL[110],SR[110],f[8500000];int cnt[110][110],Log2[8500000],tot[8500000];int top,st[8500000],L[110][110],R[110][110];int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); int pre,now; for (int i=1;i&lt;=n;i++,pre=now)&#123; scanf(&quot;%d&quot;,&amp;now); now--; if (i&gt;1&amp;&amp;now!=pre)&#123; cnt[pre][now]++; SL[pre]++; SR[now]++;&#125; &#125; int upperlim=(1&lt;&lt;m)-1; f[0]=0; for (int i=1;i&lt;=upperlim;i++) f[i]=INF; for (int i=0;i&lt;m;i++) Log2[1&lt;&lt;i]=i; int x; for (int s=0;s&lt;=upperlim;s++)&#123; if (s)&#123; while (top&amp;&amp;(st[top]&amp;s)!=st[top]) top--; x=Log2[s&amp;-s]; st[++top]=s; for (int i=0;i&lt;m;i++)&#123; L[top][i]=L[top-1][i]+cnt[i][x]; R[top][i]=R[top-1][i]+cnt[x][i]; &#125; &#125; //L,R算出的为i到s的边数与s到i的边数 tot[s]=tot[s&gt;&gt;1]+(s&amp;1); x=tot[s]+1; for (int i=0;i&lt;m;i++) if (!(s&amp;(1&lt;&lt;i))) f[s|(1&lt;&lt;i)]=min(f[s|(1&lt;&lt;i)],f[s]+x*(L[top][i]*k+R[top][i]-(SL[i]-L[top][i])+(SR[i]-R[top][i])*k)); &#125; printf(&quot;%d\\n&quot;,f[upperlim]); return 0;&#125; Day2T2 只需要实现一个数据结构维护一个无序数集，支持全部+1、插入一个数、合并、查询异或和。把二进制位反过来建$\\texttt{01-Trie}$即可。 $\\texttt{01-Trie}$ 合并的复杂度等同于线段树合并的复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,val[530000],ch[21000000][2],tot[21000000],rt[530000],cnt;int edgenum=1,vet[530000],Next[530000],Head[530000];long long ans;void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void insert(int &amp;x,int v,int d)&#123; if (!x) x=++cnt; tot[x]^=1; if (d&gt;20) return; insert(ch[x][(v&gt;&gt;d)&amp;1],v,d+1);&#125;int merge(int x,int y)&#123; if (!x||!y) return x|y; tot[x]^=tot[y]; ch[x][0]=merge(ch[x][0],ch[y][0]); ch[x][1]=merge(ch[x][1],ch[y][1]); return x;&#125;void dfs(int u)&#123; insert(rt[u],val[u],0); int v; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; dfs(v); int x=rt[v]; for (int i=0;i&lt;=20;i++)&#123; val[u]^=tot[x]&lt;&lt;i; swap(ch[x][0],ch[x][1]); x=ch[x][0]; &#125; rt[u]=merge(rt[u],rt[v]); val[u]^=val[v]; &#125; ans+=val[u];&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); int f; for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;val[i]); for (int i=2;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;f); addedge(f,i); &#125; dfs(1); printf(&quot;%lld\\n&quot;,ans); return 0;&#125; Day2T3 求所有生成树边权和：令每条边边权为 $1+w_ix$ ，然后在模$x^2$下做普通矩阵树即可，时间复杂度$O(n^3)$。 莫比乌斯反演，可以发现答案为$\\sum_d\\varphi(d)\\times [\\mbox{所有边都是}d\\mbox{的倍数的生成树的边权和}]$，看上去需要做$\\max\\{w_i\\}$次求行列式，但考虑到参与构成此部分的图中边的总数不超过 $144m$，而一张少于$n-1$条边的图中一定不包含生成树，故求行列式的次数其实只有$O(\\frac{144m}{n-1})$次，总复杂度可以估计为$O(144n^4)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;utility&gt;#include&lt;cstring&gt;using namespace std;const int Mod=998244353;int n,m,ans,u[1100],v[1100],w[1100]; int tot[210000];int cnt,phi[210000],p[210000]; bool vis[210000];struct node&#123; int a,b; node(int x=0,int y=0)&#123; a=x; b=y;&#125; node operator+(const node &amp;x) const&#123; return node((a+x.a)%Mod,(b+x.b)%Mod);&#125; node operator-(const node &amp;x) const&#123; return node((a-x.a+Mod)%Mod,(b-x.b+Mod)%Mod);&#125; node operator*(const node &amp;x) const&#123; return node(1ll*a*x.a%Mod,(1ll*a*x.b+1ll*b*x.a)%Mod);&#125;&#125; A[32][32];int qpow(int x,int a)&#123; int res=1; while (a)&#123; if (a&amp;1) res=1ll*res*x%Mod; x=1ll*x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;node getinv(const node x)&#123; int inv=qpow(x.a,Mod-2); return node(inv,1ll*(Mod-x.b)%Mod*inv%Mod*inv%Mod);&#125;void init(int n)&#123; phi[1]=1; vis[1]=true; for (int i=2;i&lt;=n;i++)&#123; if (!vis[i]) p[++cnt]=i,phi[i]=i-1; for (int j=1;i*p[j]&lt;=n;j++)&#123; vis[i*p[j]]=true; if (i%p[j]==0)&#123; phi[i*p[j]]=phi[i]*p[j]; break; &#125; phi[i*p[j]]=phi[i]*(p[j]-1); &#125; &#125;&#125;int gauss(int n)&#123; node res=node(1,0); bool rev=false; for (int i=1;i&lt;=n;i++)&#123; if (!A[i][i].a)&#123; for (int j=i+1;j&lt;=n;j++)&#123; if (A[j][i].a)&#123; rev=!rev; swap(A[i],A[j]); break; &#125; &#125; &#125; node inv=getinv(A[i][i]); for (int j=i+1;j&lt;=n;j++)&#123; node tmp=A[j][i]*inv; for (int k=i;k&lt;=n;k++) A[j][k]=A[j][k]-tmp*A[i][k]; &#125; res=res*A[i][i]; &#125; if (rev) return (Mod-res.b)%Mod; else return res.b;&#125;int getans(int val)&#123; memset(A,0,sizeof(A)); for (int i=1;i&lt;=m;i++)&#123; if (w[i]%val) continue; A[u[i]][u[i]]=A[u[i]][u[i]]+node(1,w[i]); A[v[i]][v[i]]=A[v[i]][v[i]]+node(1,w[i]); A[u[i]][v[i]]=A[u[i]][v[i]]-node(1,w[i]); A[v[i]][u[i]]=A[v[i]][u[i]]-node(1,w[i]); &#125; return gauss(n-1);&#125;void gettot(int x)&#123; for (int i=1;i*i&lt;=x;i++)&#123; if (x%i==0)&#123; tot[i]++; if (i*i!=x) tot[x/i]++; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u[i],&amp;v[i],&amp;w[i]); gettot(w[i]); &#125; init(152501); for (int i=1;i&lt;=152501;i++)&#123; if (tot[i]&lt;n-1) continue; ans=(ans+1ll*phi[i]*getans(i))%Mod; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"省选联考2020","slug":"省选联考2020","permalink":"http://hydd.cf/categories/%E7%9C%81%E9%80%89%E8%81%94%E8%80%832020/"}],"tags":[]},{"title":"20200711 五大强校联考题解","slug":"sol_19","date":"2020-07-10T16:00:00.000Z","updated":"2020-10-01T04:59:22.179Z","comments":true,"path":"2020/07/11/sol_19/","link":"","permalink":"http://hydd.cf/2020/07/11/sol_19/","excerpt":"","text":"序列 我们可以发现，每个排列的最后一个元素一定是最终排列中的第一个或最后一个，由于两种情况是对称的，于是只要考虑其是第一个时的答案，处理其影响并将方案数乘 $2$ 即可（长度为 $1$ 不乘 $2$）。 我们考虑第一个排列的最后一个元素 $x$，我们钦定它是最终排列的第一个。 不断重复以下过程直到不能做（这是钦定 $x$ 的位置后造成的反应，不能做即下面的“如果”均不成立）： 我们现在知道一些数必须在最终序列的开头，如果 $x$ 在某一排列中并非出现在末尾，那么 $x$ 之后的所有元素都会依次被加入到最终序列的末尾（它们比 $x$ 后操作，如果它们不放在结尾，$x$ 前面就会有数，不符合 $x$ 在最终排列是第一个的条件）。 我们现在又知道一些数必须在最终序列的末尾，若 $y$ 在某一排列中并非出现在末尾，那么 $y$ 之后的所有元素都会依次被加入到最终序列的开头（它们比 $y$ 后操作，如果它们不放在开头，$y$ 后面就会有数，不符合 $y$ 在最终排列是最后一个的条件）。 最后记录一下哪些加入了开头，哪些加入了结尾。 然后我们会获得 $n$ 个长为 $m’$ 的排列（这是显然的，若长度不同的话，必定上面过程没重复完）。 再次钦定第一个排列当前的最后一个元素 $x$，这样我们就会得到方案数。 现在要求字典序最小的，我们倒过来考虑，从最后一次操作开始，每一次操作哪些加入了开头，哪些加入了结尾。如果当前放第一个位置，开头/结尾两个序列不变。如果放最后一个位置，那么开头和结尾交换，并且两个序列还要 $reverse$ 一下（考虑上面的过程即可）。相当于是第一种为：开头+后一次的结果+结尾，第二种为：$rev($结尾$)$+后一次的结果+$rev($开头$)$（放开头结尾是从左往右依次放的，而后一次先放好才放这一次，所以后一次的结果夹在最终字典序的中间）。这一次做完的结果是两种的字典序的较小值，这个直接把两个 $vector$ 取 $\\min$ 即可（$vector$ 取 $\\min$ 就是求两个 $vector$ 字典序的较小值）。 时间复杂度 $O(n\\sum m+\\sum m^2)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/********************************************************************* Problem:Array Author:hydd Date:2020/7/11*********************************************************************/#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define chk do&#123; if (!flag) return true;&#125; while(0)using namespace std;const int Mod=1e9+7;int T,n,m,al[1100],ar[1100];int a[1100][1100],b[1100][1100];int pos[1100],num[1100];int l,r,tail[1100],ans;vector&lt;int&gt; L[1100],R[1100];bool flag;void pushL(int x)&#123; if (pos[x])&#123; flag=false; return;&#125; num[l]=x; pos[x]=l; l++;&#125;void pushR(int x)&#123; if (pos[x])&#123; flag=false; return;&#125; num[r]=x; pos[x]=r; r--;&#125;bool work()&#123; flag=true; ans=1; l=1; r=m; int cnt=0; for (int i=1;i&lt;=m;i++) num[i]=pos[i]=0; while (tail[1])&#123; if (tail[1]!=1) ans=ans*2%Mod;//=1放开头放结尾是一样的 int last_l=l,last_r=r; pushL(a[1][tail[1]]); chk; while (true)&#123; for (int i=1;i&lt;=n;i++) while (tail[i])&#123; if ((l&gt;r||al[i]&lt;l)&amp;&amp;a[i][tail[i]]==num[al[i]])&#123;//已经在序列开头，直接去掉 al[i]++; tail[i]--; &#125; else if ((l&gt;r||ar[i]&gt;r)&amp;&amp;a[i][tail[i]]==num[ar[i]])&#123;//已经在序列结尾，直接去掉 ar[i]--; tail[i]--; &#125; else break;//既不在开头也不在结尾 &#125; bool upd=false;//每次只push一个数，保证正确性 for (int i=1;i&lt;=n;i++) if (tail[i])&#123; if (al[i]&lt;l)&#123; int tmp=b[i][num[al[i]]];//必须在开头的后面一定必须在结尾 if (tmp&gt;=tail[i])&#123; flag=false; break;&#125; pushR(a[i][tail[i]]); upd=true; break; &#125; if (ar[i]&gt;r)&#123; int tmp=b[i][num[ar[i]]];//必须在结尾的后面一定必须在开头 if (tmp&gt;=tail[i])&#123; flag=false; break;&#125; pushL(a[i][tail[i]]); upd=true; break; &#125; &#125; chk; if (!upd) break; &#125; cnt++; L[cnt].clear(); R[cnt].clear(); for (int i=last_l;i&lt;=l-1;i++) L[cnt].push_back(num[i]); for (int i=r+1;i&lt;=last_r;i++) R[cnt].push_back(num[i]); &#125; printf(&quot;%d\\n&quot;,ans); vector&lt;int&gt; A,B,C; C.clear(); for (int i=cnt;i&gt;=1;i--)&#123; A.clear(); B.clear(); for (int x:L[i]) A.push_back(x); for (int x:C) A.push_back(x); for (int x:R[i]) A.push_back(x); reverse(L[i].begin(),L[i].end()); reverse(R[i].begin(),R[i].end()); for (int x:R[i]) B.push_back(x); for (int x:C) B.push_back(x); for (int x:L[i]) B.push_back(x); C=min(A,B); &#125; for (int i=1;i&lt;m;i++) printf(&quot;%d &quot;,C[i-1]); printf(&quot;%d\\n&quot;,C[m-1]); return false;&#125;int main()&#123; freopen(&quot;array.in&quot;,&quot;r&quot;,stdin); freopen(&quot;array.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++)&#123; tail[i]=m; al[i]=1; ar[i]=m; for (int j=1;j&lt;=m;j++)&#123; scanf(&quot;%d&quot;,&amp;a[i][j]); b[i][a[i][j]]=j; &#125; &#125; if (work()) puts(&quot;0&quot;); &#125; return 0;&#125; 树 首先特判 $n=1$，直接退出（不知道有没有这个必要）。 设集合为 $A$，先将 $A$ 中所有数字排序（或记到桶中）。 然后我们可以发现，对于一个节点编号 $t$，如果 $A$ 中 $&lt;t$ 的数字个数 $=t-1$，那么 $2..t$ 这 $t-1$ 个节点的父节点就是这 $t-1$ 个数。 所以， $&gt; t$ 的数的父节点一定不为 $1..t-1$ 。由此可得 $t$ 一定在 $1..n$ 的路径上，如果 $A$ 中没有 $t$，显然无解。 现在，我们求出了满足 $&lt; t$ 的数字个数 $=t-1$ 的所有位置 $t_1,t_2\\cdots t_k$，显然有 $t_1=1$。那么由上面的结论，有 $[t_{i-1}+1,t_i]$ 的父节点也必须为 $A$ 中的那些在 $[t_{i-1},t_i)$ 内的数的限制。 那么最短的 $1..n$ 的路径即为 $t_1,t_2,\\cdots t_k,n$。（在 $n\\neq 1$ 时显然有 $t_k\\neq n$）。 然后我们要给它们加边权，而 $A$ 中的那些在 $[t_1,t_k)$ 中的那些值显然是不能用的，所以边权只能在 $[t_k,n]$ 内，并且先在其中去掉一个 $t_k$，当做 $f_n$。我们把现在可以用的边权从小到大存入 $b$ 数组。 现在我们需要让边权最大，肯定是取 $b$ 中的一个后缀当做边权，然后把当前的这些 $b$ 删去。我们就求出了 $1..n$ 路径上边数为 $k$ 时的路径长度的最大值。 一个垃圾做法（昨天的考场做法，考试结束时没调出来。细节多，常数大） 现在要增加路径上的边数，我们可以发现，在开区间 $\\forall x,(t_x,t_{x+1})$ 上加入一个点 $y\\in A\\cap(t_x,t_{x+1})$ 是最优的，这样我们将原来的 $t_x-t_{x+1}$ 的边改为 $t_x-y,y-t_{x+1}$，将原先的 $t_x-y$ 边权设为原先的 $w$，新的 $y-t_{x+1}$ 边权设为当前 $b$ 的末尾，并且将 $b$ 的末尾的这个数从 $b$ 中删除，将 $y$ 从 $A$ 中删除即可。显然当前的边权和是最大的。 我们不断地在每个开区间 $(t_x,t_{x+1})$ 上都加点直到不能加，我们可以发现，由于我们取的是 $b$ 中的一个后缀，所以它并不会使得 $u\\in(t_k,n]$ 的 $f_u&gt;u$，也就是我们依旧可以满足一棵树的条件。 现在的路径上的边数不一定是最多的，还可以增加。我们可以在 $(t_k,n)$ 上加入不同的点 $y\\in A\\cap(t_k,t_n)$。 这部分的问题比较多。 首先我们考虑加点的顺序，从小到大加不同的 $y\\in A\\cap(t_k,t_n)$ 中的点一定是最优的，这个比较显然，如果我先加一个更大的 $z\\in A\\cap(t_k,t_n)$。选 $z$ 会使得 $z$ 为 $f_n$，$z$ 就不能当做边权了，$y$ 能当边权。选 $y$ 会使得 $y$ 为 $f_n$，$y$ 就不能当边权了，$z$ 能当边权。显然边权越大越好。 其次我们考虑从小到大加 $y$ 的过程中，$y$ 被当做了前面 $(t_x,t_{x+1})$ 上的边权。我们要将当时选的边权更改，使得它把这个 $y$ 给还回来，再给当时的边一个别的边权（当前没当做 $w/f$ 的最大的），我们要动态维护取出作为 $w$ 的 $y$ 和没有取出作为 $w$ 的还存在的 $y$（显然作为 $f$ 的是不能回退的），这两个用两个 $set$ 维护，第一个 $set$ 删数了就从第二个 $set$ 加入进去即可。 模拟即可，但首先我们要求出 $A\\cap(t_k,t_n)$。这个也可以用 $set/sort$去重。 时间复杂度 $O(n \\log n)$。实现起来细节比较多，注意要开 $long\\ long$。 好像没必要用 $set$？直接桶排一下然后队列打标记就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/********************************************************************* Problem:Tree Author:hydd Date:2020/7/11*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#define int long longusing namespace std;multiset&lt;int&gt; s1,s2;set&lt;int&gt; s;int n,m,a[210000],b[210000];int st[210000],presum[210000],pos[210000],sum,Ans[210000];int cnt; int u,v;int solve(int l,int r)&#123; int tot=1; for (int i=l+1;i&lt;=r;i++) if (a[i]!=a[i-1]) tot++; return tot;&#125;bool move2to1()&#123; if (s2.empty()) return true; sum+=*s2.rbegin(); s1.insert(*s2.rbegin()); s2.erase(--s2.end()); return false;&#125;signed main()&#123; freopen(&quot;tree.in&quot;,&quot;r&quot;,stdin); freopen(&quot;tree.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld&quot;,&amp;n); m=2*n-2; if (n==1) return 0; for (int i=1;i&lt;=m;i++) scanf(&quot;%lld&quot;,&amp;a[i]); sort(a+1,a+m+1); int j=0; bool flag=true; for (int i=1;i&lt;=n;i++)&#123; while (j&lt;n&amp;&amp;a[j+1]&lt;i) j++; if (i==j+1)&#123; st[++cnt]=i; pos[cnt]=j; if (a[j+1]!=i) flag=false; &#125; &#125; for (int i=1;i&lt;=m;i++)&#123; presum[i]=presum[i-1]; if (i==1||a[i]!=a[i-1]) presum[i]++; &#125; int loc=1,len=0; while (loc&lt;=n&amp;&amp;a[loc]&lt;st[cnt]) loc++; for (int i=loc;i&lt;=m;i++)&#123; b[++len]=a[i]; s.insert(a[i]); &#125; if (!flag)&#123; for (int i=1;i&lt;n-1;i++) printf(&quot;-1 &quot;); printf(&quot;-1\\n&quot;); return 0; &#125; for (int i=1;i&lt;cnt;i++) Ans[i]=-1; int now=cnt; sum=0; for (int i=1;i&lt;=cnt;i++)&#123; sum+=b[len]; len--; &#125; Ans[now]=sum; for (int i=1;i&lt;cnt;i++)&#123; int tot=presum[pos[i+1]]-presum[pos[i]]-1;// printf(&quot;%d\\n&quot;,tot); for (int j=1;j&lt;=tot;j++)&#123; sum+=b[len]; len--; now++; Ans[now]=sum; &#125; &#125; int tmp=now; int x=st[cnt]; sum=0; for (int i=m;i&gt;=m-tmp+1;i--)&#123; sum+=a[i]; s1.insert(a[i]); &#125; for (int i=m-tmp;i&gt;=loc;i--) s2.insert(a[i]); while (!s2.empty())&#123; if (x==*s.rbegin()) break; x=*s.upper_bound(x); if (s2.find(x)!=s2.end())&#123; s2.erase(s2.find(x)); move2to1(); &#125; else&#123; if (s1.find(x)==s.end()) break; s1.erase(s1.find(x)); sum-=x; move2to1(); move2to1(); &#125; Ans[++now]=sum; &#125; for (int i=now+1;i&lt;n;i++) Ans[i]=-1; for (int i=1;i&lt;n-1;i++) printf(&quot;%lld &quot;,Ans[i]); printf(&quot;%lld\\n&quot;,Ans[n-1]); return 0;&#125;/*87 2 7 6 4 3 6 1 6 7 1 6 7 7*/ 另一个做法 我们首先在 $[1,t_k]$ 之间，把能加到路径上的点都加入。并更新答案。 加完了我们就要考虑 $(t_k,n)$ 之间的点了。从小到大加不同的 $y\\in A\\cap(t_k,t_n)$ 中的点一定是最优的，这个比较显然，如果我先加一个更大的 $z\\in A\\cap(t_k,t_n)$。选 $z$ 会使得 $z$ 为 $f_n$，$z$ 就不能当做边权了，$y$ 能当边权。 但我们从小到大加的过程中，可能会出现当前要加的点 $x$ 都当做了以前的路径上的 $w$，就没有多余的 $x$ 当做 $w$ 了。这没关系，我们直接将那个边权替换成当前最大的没用过的边权即可，这样会空出一个 $x$（当然如果本来就有多余的 $x$ 就不需要做这个操作）。 然后给这个 $x-n$ 分配一个新的边权即可，设原来 $n$ 与 $y$ 有边，现在断开 $y-n$，将 $y-n$ 的边权给 $y-x$ 即可。 时间复杂度 $O(n)$。 具体实现看代码，里面有注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/********************************************************************* Problem:Tree Author:hydd Date:2020/7/12*********************************************************************/#include&lt;cstdio&gt;using namespace std;typedef long long ll;int n,tot[110000];int pos,pos2;ll ans;bool vis[110000],flag;void get_w()&#123;//选出当前最大的还有的数作为当前的w while (!tot[pos]) pos--; ans+=pos; tot[pos]--; &#125;void find_next()&#123;//找到(t_cnt,n)中的最小的没在路径上出现过的点加入 for (;!vis[pos2]&amp;&amp;pos2&lt;n;pos2++); if (pos2==n)&#123; flag=true; return;&#125; if (tot[pos2]) tot[pos2]--;//还有多余直接用 else ans-=pos2,get_w();//被当做w占用完了，回退当时的w，让它换一个 pos2++;&#125;int main()&#123; freopen(&quot;tree.in&quot;,&quot;r&quot;,stdin); freopen(&quot;tree.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); if (n==1) return 0; int x; for (int i=1;i&lt;=2*n-2;i++)&#123; scanf(&quot;%d&quot;,&amp;x); vis[x]=true; tot[x]++; &#125; int cnt=0;//cnt为&#123;t_i&#125;中的点的个数 int cnt2=0;//cnt2为[1,t_cnt)的数中可以在路径上的数的个数 for (int i=1,sum=0;i&lt;n;i++)&#123; sum+=tot[i-1]; if (sum==i-1)&#123; cnt++; pos2=i;//现在的pos2为t_cnt if (!vis[i]) flag=true; &#125; &#125; for (int i=1;i&lt;=pos2;i++) if (vis[i]) cnt2++; pos=n-1; tot[pos2]--; pos2++;//pos2为n的f，所以减去1个 //现在的pos2为(t_cnt,n)中最小的可能没使用过的数 for (int i=1;i&lt;n;i++)&#123; if (i&gt;cnt2) find_next();//若还要加数，只能在(t_cnt,n)中了，那么这个数有可能被当做边权用完了 //否则就是在[1,t_cnt)之间的数，加入它后边权在[t_cnt,n)中，和他没影响 get_w();//添加现在新加入的边权 if (i&lt;cnt||flag) printf(&quot;-1 &quot;); else printf(&quot;%lld &quot;,ans); &#125; return 0;&#125;","categories":[{"name":"NOI模拟赛","slug":"NOI模拟赛","permalink":"http://hydd.cf/categories/NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"CF概率期望题选做","slug":"sol_20","date":"2020-07-08T16:00:00.000Z","updated":"2020-10-02T03:14:03.322Z","comments":true,"path":"2020/07/09/sol_20/","link":"","permalink":"http://hydd.cf/2020/07/09/sol_20/","excerpt":"","text":"CF540D（Bad Luck Island） 概率 $dp$，难度：$1900$ 题意 有 $r$ 个石头，$s$ 个剪刀，$p$ 个布，三个物种。 每次随机两个战斗，赢的存活，输的死亡（相同物种则都存活）。直到只有一种物种。 问只剩下石头、剪刀、布一种物种存活下来的概率是多少。要求与标准答案的绝对值不超过 $10^9$。 $r,s,p\\leq 100$。 题解 首先我们发现每一种最后活下来的概率是对称的。 我们只需要求某一种是最后活下来的概率即可。 设 $dp[r][s][p]$ 表示 $r$ 个石头，$s$ 个剪刀，$p$ 个布最后活下来的概率。 石头剪刀布三种是最后活下来的概率分别是 $dp[r][s][p],dp[s][p][r],dp[p][r][s]$。 转移就随便转移吧，复杂度 $O(n^3),n=\\max\\{r,s,p\\}$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long double ldb;int R,S,P,inv[310];ldb dp[110][110][110];int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;R,&amp;S,&amp;P); int lim=max(R,max(S,P)); ldb x,y; for (int r=0;r&lt;=lim;r++) for (int s=0;s&lt;=lim;s++) for (int p=0;p&lt;=lim;p++)&#123; if (!r&amp;&amp;!s&amp;&amp;!p) continue; if (!s&amp;&amp;!p)&#123; dp[r][s][p]=1; continue;&#125; if (!r&amp;&amp;!p)&#123; dp[r][s][p]=0; continue;&#125; if (!r&amp;&amp;!s)&#123; dp[r][s][p]=0; continue;&#125; y=1.0*r*s+1.0*r*p+1.0*s*p+ 0.5*r*(r-1)+0.5*s*(s-1)+0.5*p*(p-1); y=1/y; if (r&amp;&amp;s)&#123; x=1.0*r*s; dp[r][s][p]+=x*y*dp[r][s-1][p]; &#125; if (r&amp;&amp;p)&#123; x=1.0*r*p; dp[r][s][p]+=x*y*dp[r-1][s][p]; &#125; if (s&amp;&amp;p)&#123; x=1.0*s*p; dp[r][s][p]+=x*y*dp[r][s][p-1]; &#125; ldb tmp=0; if (r&gt;=2)&#123; x=0.5*r*(r-1); tmp+=x*y; &#125; if (s&gt;=2)&#123; x=0.5*s*(s-1); tmp+=x*y; &#125; if (p&gt;=2)&#123; x=0.5*p*(p-1); tmp+=x*y; &#125; dp[r][s][p]/=(1-tmp); &#125; printf(&quot;%.12lf %.12lf %.12lf\\n&quot;,(double)dp[R][S][P],(double)dp[S][P][R],(double)dp[P][R][S]); return 0;&#125; CF1265E 期望 $dp$，难度：$2100$ 题意 有 $n$ 面镜子，第 $i$ 面镜子说美丽的概率为 $\\frac {p_i}{100}$ ，说不美丽的概率为 $1-\\frac{p_i}{100}$。 从左往右问，每天问一面镜子，镜子说不美丽下一天要从第 $1$ 面镜子开始。 求问到第 $n$ 面镜子说美丽需要用多少天。答案对 $998244353$ 取模。 $1\\leq n\\leq 2\\times 10^5,p_i\\leq 100$。 题解 设 $dp[i]$ 为第一次到第 $i$ 面镜子所用的时间。 $dp[i]=(dp[i-1]+1)\\times\\frac{p_i}{100}+(dp[i-1]+1+dp[i])\\times(1-\\frac{p_i}{100})$。 前半部分是到第 $i$ 面镜子的时候，它说漂亮的贡献。后半部分是到第 $i$ 面镜子的时候，它说不漂亮的贡献。 化简可得 $dp[i]=(dp[i-1]+1)\\times \\frac{100}{p_i}$。复杂度 $O(n)$。 123456789101112131415#include&lt;cstdio&gt;using namespace std;const int Mod=998244353;int n,p[210000],dp[210000],inv[110];int main()&#123; inv[1]=1; for (int i=2;i&lt;=100;i++) inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod; scanf(&quot;%d&quot;,&amp;n); dp[0]=0; for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;p[i]); dp[i]=100ll*inv[p[i]]%Mod*(dp[i-1]+1)%Mod; &#125; printf(&quot;%d\\n&quot;,dp[n]); return 0;&#125; CF1096F（Inversion Expectation） 期望，树状数组，难度：$2300$ 题意 给你一个 $n$ 个数的排列，但有些位置上为 $−1$，表示这一位是不确定的。 每种可能的排列出现的概率相等。求期望逆序对数对 $998244353$ 取模的结果。 $n\\leq 2\\times 10^5$。 题解 首先，我们先求出非 $-1$ 的位置之间的逆序对数。这个可以直接树状数组解决。 然后，我们求出所有 $-1$ 的位置之间的逆序对数。假设有 $tot$ 个位置是 $-1$，那么概率是 $\\binom{tot}{2}\\times \\frac 12$（每一对数之间逆序的概率都为 $\\frac 12$，由期望的线性性相加即可）。 最后，我们要求出非 $-1$ 的位置和 $-1$ 的位置之间的逆序对数。我们在所有非 $-1$ 的位置计算贡献。假设当前位置的数为 $x$，答案为：前面 $-1$ 的位置个数 $\\times$ $&gt; x$ 且在原序列未出现过的数的个数 $+$ 后面 $-1$ 位置个数 $\\times$ $&lt;x$ 且在原序列未出现过的数的个数。 时间复杂度 $O(n \\log n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;using namespace std;const int Mod=998244353;int n,p[210000],tree[210000];int s[210000],pre[210000],suf[210000],inv[210000];void add(int x,int y)&#123; for (;x&lt;=n;x+=x&amp;-x) tree[x]+=y;&#125;int getsum(int x)&#123; int sum=0; for (;x;x-=x&amp;(-x)) sum+=tree[x]; return sum;&#125;inline int C2(int x)&#123; return (1ll*x*(x-1)/2)%Mod;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); int tot=0; inv[1]=1; for (int i=2;i&lt;=200000;i++) inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod; for (int i=1;i&lt;=n;i++) s[i]=1; for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;p[i]); if (p[i]!=-1) s[p[i]]--; else tot++; &#125; for (int i=1;i&lt;=n;i++)&#123; s[i]+=s[i-1]; pre[i]=pre[i-1]+(p[i]==-1); &#125; int now,ans=0; for (int i=n;i&gt;=1;i--) if (p[i]==-1) suf[i]=suf[i+1]+1; else&#123; suf[i]=suf[i+1]; ans=(ans+getsum(p[i]))%Mod; add(p[i],1); &#125; for (int i=1;i&lt;=n;i++) if (p[i]!=-1)&#123; now=tot-s[p[i]]; ans=(ans+1ll*pre[i]*now%Mod*inv[tot])%Mod; now=s[p[i]-1]; ans=(ans+1ll*suf[i]*now%Mod*inv[tot])%Mod; &#125; ans=(ans+1ll*C2(tot)*inv[2])%Mod; printf(&quot;%d\\n&quot;,ans); return 0;&#125; CF1139D（Steps to One） 期望，莫比乌斯反演，难度：$2300$ 题意 有一个序列，初始为空。 每次随机选一个 $1$ 到 $m$ 之间的数加在序列末尾。 当数列中所有数的 $\\gcd=1$ 时停止，求最终序列的期望长度。 答案对 $10^9+7$ 取模。 $1\\leq m\\leq 10^5$。 题解 \\begin{align*} E(X)&=\\sum_{i\\geq 1} P(X\\geq i)\\\\ &=1+\\sum_{i\\geq 1} P(X>i)\\\\ &=1+\\sum_{i\\geq 1} P(\\gcd\\{a_1,a_2,\\cdots,a_i\\}\\neq 1)\\\\ &=1+\\sum_{i\\geq 1} \\frac{\\sum_{1\\leq a_1,\\cdots,a_i\\leq m} [\\gcd\\{a_1,a_2,\\cdots,a_i\\}\\neq 1]}{m^i}\\\\ &=1+\\sum_{i\\geq 1} \\frac{m^i-\\sum_{1\\leq a_1,\\cdots,a_i\\leq m} [\\gcd\\{a_1,a_2,\\cdots,a_i\\}=1]}{m^i}\\\\ &=1+\\sum_{i\\geq 1} \\frac{m^i-\\sum_{j=1}^m \\mu(j)\\sum_{1\\leq a_1,\\cdots,a_i\\leq m} [j|\\gcd\\{a_1,a_2,\\cdots,a_i\\}]}{m^i}\\\\ &=1+\\sum_{i\\geq 1} \\frac{m^i-\\sum_{j=1}^m \\mu(j)\\lfloor\\frac mj\\rfloor^i}{m^i}\\\\ &=1+\\sum_{i\\geq 1} \\frac{m^i-m^i-\\sum_{j=2}^m \\mu(j)\\lfloor\\frac mj\\rfloor^i}{m^i}\\\\ &=1-\\sum_{i\\geq 1} \\sum_{j=2}^m\\frac{\\mu(j)\\lfloor\\frac mj\\rfloor^i}{m^i}\\\\ &=1-\\sum_{j=2}^m \\mu(j)\\sum_{i\\geq 1}(\\frac{\\lfloor\\frac mj\\rfloor}{m})^i\\\\ &=1-\\sum_{j=2}^m \\mu(j)(\\frac{\\lfloor\\frac mj\\rfloor}{m}\\sum_{i\\geq 0}(\\frac{\\lfloor\\frac mj\\rfloor}{m})^i)\\\\ &=1-\\sum_{j=2}^m \\mu(j)(\\frac{\\lfloor\\frac mj\\rfloor}{m}\\times \\frac 1{1-\\frac{\\lfloor\\frac mj\\rfloor}{m}})\\\\ &=1-\\sum_{j=2}^m \\mu(j)(\\frac{\\lfloor\\frac mj\\rfloor}{m}\\times \\frac{m}{m-\\lfloor\\frac mj\\rfloor})\\\\ &=1-\\sum_{j=2}^m \\mu(j)(\\frac{\\lfloor\\frac mj\\rfloor}{m-\\lfloor\\frac mj\\rfloor})\\\\ \\end{align*} 代码写的复杂度是 $O(n\\log n)$ 的，线性筛 $\\mu$ 可以做到 $O(n)$。 1234567891011121314151617#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int Mod=1e9+7;int m,inv[110000],mu[110000];int main()&#123; scanf(&quot;%d&quot;,&amp;m); mu[1]=1; for (int i=1;i&lt;=m;i++) for (int j=i+i;j&lt;=m;j+=i) mu[j]-=mu[i]; inv[1]=1; for (int i=2;i&lt;=m;i++) inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod; int ans=1; for (int i=2;i&lt;=m;i++) ans=(ans-1ll*mu[i]*(m/i)%Mod*inv[m-(m/i)])%Mod; printf(&quot;%d\\n&quot;,(ans+Mod)%Mod); return 0;&#125; CF26D（Tickets） 组合数（格路模型），难度：$2400$。 题意 你在卖票，每张票 $10$ 元。并且你现在有 $k$ 张 $10$ 元。 有 $n$ 个客人手持 $10$ 元，还有 $m$ 个客人手持 $20$ 元。 如果一个客人给你一张 $10$ 元，你不用找给他。如果一个客人给你一张 $20$ 元，你要找给它 $10$ 元。 $n+m$ 个客人会随机排队买票，求所有的客人的钱都能找开的概率。 $0\\leq n,m\\leq 10^5,k\\leq 10$。 题解 我们转化一下题面。 现在在 $(k,0)$ 的位置，每次可以向上走一步或向右走一步（即收到 $10$ 元向右，收到 $20$ 元向上）。 要求不能穿过 $y=x$ （可以碰到但是不能穿过，也就是 $20$ 元不能比 $10$ 元多）。 求走到 $(n+k,m)$ 的方案数。 不能穿过 $y=x$ 可以改为 不能碰到 $y=x+1$。 当碰到 $y=x+1$ 的时候，我们将之后的路径关于 $y=x+1$ 对称一下，那么终点为 $(m-1,n+k+1)$。 于是， \\begin{align*} ans&=1-\\frac{(k,0)..(m-1,n+k+1)}{(k,0)..(n+k,m)}\\\\&=1-\\frac{(0,0)..(m-k-1,n+k+1)}{(0,0)..(n,m)}\\\\&=1-\\frac{\\frac{(m+n)!}{(m-k-1)!(n+k+1)!}}{\\frac{(m+n)!}{m!n!}}\\\\&=1-\\frac{m!n!}{(m-k-1)!(n+k+1)!}\\\\&=1-\\frac{\\frac{m!}{(m-k-1)!}}{\\frac{(n+k+1)!}{n!}}\\\\&=1-\\frac{\\prod_{i=m-k}^m i}{\\prod_{i=n+1}^{n+k+1} i} \\end{align*}123456789101112131415#include&lt;cstdio&gt;using namespace std;int n,m,k;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); long double ans1=1,ans2=1; for (int i=m-k;i&lt;=m;i++) ans1*=i; for (int i=n+1;i&lt;=n+k+1;i++) ans2*=i; if (ans1&gt;ans2) puts(&quot;0.00000000&quot;); else&#123; double ans=(ans2-ans1)/ans2; printf(&quot;%.8lf\\n&quot;,ans); &#125; return 0;&#125; CF441E（Valera and Number） 期望 $dp$，难度：$2400$ 题意 给你一个数 $x$，$k$ 次操作，每次有 $p\\%$ 的概率 $x=x\\times 2$，有 $(100-p)\\%$ 的概率 $x=x+1$。 问最后 $x$ 二进制表示下末尾 $0$ 的个数的期望。 $1\\leq x\\leq 10^9,1\\leq k\\leq 200,0\\leq p\\leq 100$。 题解 这道题有点像 $ysy$ 讲的某道随机数生成器。 设 $f[i][j]$ 为 $i$ 次操作后 $x+j$ 末尾期望 $0$ 的个数。 $x=x+1$：$f[i+1][j-1]=f[i+1][j-1]+(100-p)\\%\\times f[i][j]$。 $x=x\\times 2$：$f[i+1][j\\times 2]=f[i+1][j\\times 2]+p\\%\\times (f[i][j]+1)$。 最终答案为 $f[k][0]$。时间复杂度 $O(k^2)$。 1234567891011121314151617#include&lt;cstdio&gt;#include&lt;cmath&gt;#define lowbit(a) a&amp;(-a)using namespace std;int x,k;double p,f[210][210];int main()&#123; scanf(&quot;%d%d%lf&quot;,&amp;x,&amp;k,&amp;p); p/=100; for (int i=0;i&lt;=k;i++) f[0][i]=log2(lowbit((x+i))); for (int i=0;i&lt;k;i++) for (int j=0;j&lt;=k;j++)&#123; if (j) f[i+1][j-1]+=(1-p)*f[i][j]; if (j*2&lt;=k) f[i+1][j*2]+=p*(f[i][j]+1); &#125; printf(&quot;%.8lf\\n&quot;,f[k][0]); return 0;&#125; CF498B（Name That Tune） 概率 $dp$。难度：$2400$ 题意 共有 $T$ 秒时间，从左往右听 $n$ 首歌。 第 $i$ 首歌每播放一秒都会有 $p_i$ 的概率被识别出来，跳到下一首。 若第 $i$ 首歌播放到 $t_i$ 秒时，你就会立刻识别出，也跳到下一首。 若时间有剩余，$n$ 首歌已全部识别出，则直接结束。 求能识别出的歌的数量的期望。$1\\leq n,T \\leq 5000$。 题解 设 $f[i][j]$ 为识别完前 $i$ 首歌要 $j$ 秒的概率。以下的 $p_i$ 为读入的 $p_i$ 除以 $100$。 $f[i][j]=\\sum\\limits_{k=1}^{t_i-1} f[i-1][j-k]\\times (1-p_i)^{k-1}p_i+f[i-1][j-t_i]\\times (1-(1-p_i)^{t_i-1})$。 前缀和优化即可。由于每首歌听完的贡献都为 $1$，所以答案为 $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^T f[i][j]$。 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int n,T,t[5100];double p[5100],f[5100][5100];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;T); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lf%d&quot;,&amp;p[i],&amp;t[i]); p[i]/=100; &#125; f[0][0]=1; double ans=0; for (int i=1;i&lt;=n;i++)&#123; double sum=0,tmp=pow(1-p[i],t[i]-1); for (int j=1;j&lt;=T;j++)&#123; sum*=(1-p[i]); sum+=f[i-1][j-1]*p[i]; if (j&gt;=t[i])&#123; sum-=f[i-1][j-t[i]]*tmp*p[i]; f[i][j]+=f[i-1][j-t[i]]*tmp; &#125; f[i][j]+=sum; ans+=f[i][j]; &#125; &#125; printf(&quot;%.12lf\\n&quot;,ans); return 0;&#125; CF1194F（Crossword Expert） 组合数，概率。难度：$2400$ 题意 $n$ 个题目，$T$ 秒时间 每个题目有 $50\\%$ 需要消耗时间 $t_i$ 秒，每题有 $50\\%$ 的概率消耗 $t_i+1$ 秒，问 $T$ 秒时做出题目数目的期望值 （在 $T$ 秒时刚好完成的题目也算完成）。 答案对 $10^9+7$ 取模。 $1\\leq n\\leq 2\\times 10^5,1\\leq T\\leq 2\\times 10^{14}$。 题解 依旧用 $E(X)=\\sum_{i\\geq 1} P(X\\geq i)$ 展开。 现在我们要计算 $P(X\\geq i)$。我们记 $sum_i=t_1+t_2+\\cdots+t_i$。 $P(X\\geq i)=\\frac{\\sum_{j=0}^{T-sum_i} C(i,j)}{2^i}$，也就是考虑有哪些题多花了 $1$ 秒。 然后我们可以发现，上界可以缩小为 $\\min\\{T-sum_i,n\\}$，因为 $j&gt;i$ 时 $C(i,j)=0$，而 $i\\leq n$。 那么，$E(x)=\\sum_{i=1}^n \\sum_{j=0}^{\\min\\{T-sum_i,n\\}} C(i,j)$。 当 $i$ 增大时，$\\min\\{T-sum_i,n\\}$ 只减不增。 我们可以考虑设置一个指针 $x$，初始在 $n$。 记 $sum=C(i,0)+C(i,1)+\\cdots+C(i,x)=\\sum_{j=0}^x C(i,j)$。 $i++$ 后，现在的 $sum=\\sum_{j=0}^x C(i,j)$，原先的 $sum’=\\sum_{j=0}^x C(i-1,j)$。 那么现在的 \\begin{align*} sum&=\\sum_{j=0}^x C(i,j)\\\\ &=\\sum_{j=0}^x (C(i-1,j-1)+C(i-1,j))\\\\ &=\\sum_{j=0}^{x-1} C(i-1,j)+\\sum_{j=0}^x C(i-1,j)\\\\ &=2\\times\\sum_{j=0}^x C(i-1,j)-C(i-1,x)\\\\ &=2\\times sum'-C(i-1,x)\\\\ \\end{align*} 所以现在的 $sum$ 可以通过原先的 $sum’$ 用 $O(1)$ 的时间求出。 剩下的，就是把当前行的指针移动到 $\\min\\{T-sum_i,n\\}$ 。 $x—$ 后，$sum=sum’-C(i,x+1)$。 时间复杂度 $O(n)$。 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int Mod=1e9+7;const int inv2=(Mod+1)/2;int n; ll T;ll fac[210000],inv[210000];ll C(int n,int m)&#123; if (n&lt;m) return 0; return 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;&#125;int main()&#123; scanf(&quot;%d%lld&quot;,&amp;n,&amp;T); fac[0]=1; for (int i=1;i&lt;=n;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=n;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=n;i++) inv[i]=inv[i-1]*inv[i]%Mod; int x=n,t,ans=0; int sum=1,mul=1; //sum=C(i,0)+C(i,1)+C(i,2)+...+C(i,x) for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;t); T-=t; if (T&lt;0) break; sum=(((sum&lt;&lt;1)-C(i-1,x))%Mod+Mod)%Mod; while (x&gt;T)&#123; sum=(sum-C(i,x)+Mod)%Mod; x--; &#125; mul=1ll*mul*inv2%Mod; ans=(ans+1ll*sum*mul)%Mod; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://hydd.cf/categories/Codeforces/"}],"tags":[{"name":"概率/期望","slug":"概率-期望","permalink":"http://hydd.cf/tags/%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"}]},{"title":"字符串Border 笔记","slug":"note_4","date":"2020-07-05T16:00:00.000Z","updated":"2020-11-08T12:50:24.635Z","comments":true,"path":"2020/07/06/note_4/","link":"","permalink":"http://hydd.cf/2020/07/06/note_4/","excerpt":"","text":"若 $1\\leq r\\leq |S|$，$S_{1..r}=S_{|S|-r+1..|S|}$，则称 $S_{1..r}$ 是 $S$ 的 $border$，长度为 $r$。 $border$ 的性质：字符串 $s$ 的所有 $border$ 长度排序后可分成不超过 $\\log_2 |S|$ 段，每段是一个等差数列。 引理 $1$：若存在一个 $border$ 长度为 $k$ ，那么 $|S|-k$ 为 $S$ 的一个周期。 引理 $2$：若 $p,q$ 为 $S$ 的周期，且 $p+q\\leq |S|$，那么 $\\gcd(p,q)$ 也为$S$ 的周期。 引理 $3$：$S$ 的所有 $\\geq\\frac{|S|}{2}$ 组成一个等差数列。 $proof.$ 引理 $1$ 是显然的，根据定义，对于 $i+|S|-k\\leq |S|$ 即 $i\\leq k$，有 $S[i]=S[i+(|S|-k)]$。 引理 $2$ 1 设 $p&lt;q,d=q-p$ 若 $|S|-q\\leq i\\leq |S|-d$，$S_i=S_{i-p}=S_{i-p+q}=S_{i+d}$。 若 $0\\leq i&lt;|S|-q$，$S_i=S_{i+p}=S_{i+q-p}=S_{i+d}$。 那么 $d=q-p$ 也为 $S$ 的周期。由欧几里得算法可知 $\\gcd(p,q)$ 也为 $S$ 的周期。 引理 $3$ 2 设最长的 $border$ 长度为 $k(k\\geq \\frac {|S|}2)$。 那么最小周期 $p$ 为 $|S|-k$，所以 $tp(tp\\leq n)$ 都为字符串的周期。 那么 $|S|-tp\\geq \\frac{|S|}2$ 都是字符串的 $border$，这样满足引理 $2$，也就是 $p$ 是最小周期的条件。 根据引理 $3$，有： 考虑更小的 $border$，对其进行按长度的二进制分组，即 $[1,2),[2,4),[4,8)\\cdots,[2^k,n)$ 各分为一类。 对于在某个类中的 $border$，考虑其最长的，那么剩下的所有 $border$ 一定是最长的那个 $border$ 的 $border$。（正确性证明类似于 $kmp$）。 故以最长的 $border$ 为母串（称之为$T$），而类内所有 $border$ 的长度必定 $&gt;\\frac{|T|}2$。根据引理 $3$ ，故一类的 $border$ 长度为一个等差数列。 故字符串 $S$ 的所有 $border$ 能划分成 $\\log_2 S$ 个等差数列。 参考文献：1: 钟子谦，《串串 解题报告》引理 5.1，2019 年信息学奥林匹克中国国家集训队队员作业","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hydd.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://hydd.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"ZJOI2020 总结","slug":"sum_3","date":"2020-07-05T16:00:00.000Z","updated":"2020-09-30T13:48:16.433Z","comments":true,"path":"2020/07/06/sum_3/","link":"","permalink":"http://hydd.cf/2020/07/06/sum_3/","excerpt":"","text":"Day1 开场看到个 string,segment,seq，感觉今年的题比往年不毒瘤一些了？？ 按照惯例，先看T2，发现又是个线段树。往下看，发现了一段代码（从uoj盗的图）： 这不是和去年的线段树这题给的代码一样吗（uoj467）。。。但是往年的题都没有去订正过/做过… 一看部分分，第一个是 $n\\leq 10,k\\leq 4$ 。$10$ 想到阶乘（？），然后发现这题和阶乘啥关系也没有，于是认为这个点是状压？然后就直接记录 $2n-1$ 个点的 $tag$ ，暴力转移，复杂度是 $O(2^{2n-1}n^2n*k)=O(2^{2n}n^3k)$，显然没分啊，于是先放了。 然后看了T1，把题看错了，把出现如果两个串相同，但是出现的位置不同，那么这两个串不是本质不同看成了如果两个串相同，但是出现的位置不同，那么这两个串是本质不同。。。然后直接写了个$O(n^2)$左右的hash，发现没过样例。然后手动模拟了一遍，感觉自己输出的是对的。重看了一遍题，才发现题看错了。。。 于是，就感觉询问不同的区间的答案是没有影响的（？），也就是感觉每个询问的答案要单独计算。 枚举询问区间 $l,r$，然后发现 $[l,r]$ 的区间答案是 $[l,r-1]$ 的区间答案 + 不重复的右端点在 $r$ 的平方串。于是写了个 $n^3\\log n$ ，常数极小，期望20。 直接滚去看T3，感觉这题面好诡异，刚开始想了一个贪心，认为能做1操作尽量做1操作，直到没有长度$&gt;1$的段，然后做2、3操作。复杂度玄学，过了小样例，大样例一个都没过（第一个答案是77，我输出79）。 直接自闭，又想了一个贪心，就是先当做都做2、3操作，然后把可以合并的2、3操作合并成1操作（？）细节巨多，然后发现是假的，连小样例都过不去，大样例第一个输出91？（有点忘了）。 心态有点崩了，打算写那个 $T2$ 没分的，看看能不能水点分？细节依旧巨多，然后写完了发现没过样例，于是写了个大暴力（复杂度 $O((\\frac{n*(n+1)}2)^kn)$ ）跑极小的数据进行调试。可笑的是，我没发现这个有 $10pts$。然后把那个0分的调过样例了。 然后继续想T3，突然发现，我打了这么久，竟然连一个提高组级别的算法都没用到。。。于是考虑 $dp$，发现好像是可以的，设 $dp[i][j][a][b]$ 表示$i$用了$j$个1操作，$a$个2/3操作，$i-1$用了$b$ 个2/3操作。然后发现$j+a=a_i$，可以优化掉一维，转移枚举$i-2$用了几个1操作，复杂度$O(n\\max{a_i}^3)$。可以有 $30pts$。 然后考试时间快到了，写了个T2 $k=1$的，直接在线段树瞎 $dp$，过了样例就走了。 最后检查了一下文件名，依旧没有发现那个大暴力能过 $10pts$，然后考试时间结束了。 出去遇见同学，发现有T1有40，T2有20，才发现T2那个大暴力竟然有$10pts$，所以没一起放在提交的代码里。。。然后T1可以对本质相同的串一起考虑它们对答案的影响，可以做到$n^2\\log n$。感觉自己凉了。 Day2 开题先看T2，期望？？？我最差的就是期望/数论了，数学题咋做啊？ 瞄了眼T1和T3，感觉完全不可做。（下文好像把 $m$ 都写成了 $n$） 刚开始又看错了题，以为每个数只能取一次，有重复，死活不会做。 后来仔细看了看样例解释，怎么还能一直抽，才发现题又看错了。。。 发现还是不会做，$n\\leq 10$ 的部分分不可做，手算了一次样例，第一次还算错了。 然后开始考虑怎么算，我现在加入了一些数，要么现在加一个没出现过的数，要么加一个出现过了的数。 这东西被我算了个把小时（概率论基础太差），还写了个代码，发现错的十分离谱。 开始试小数据，然后手算答案，最后发现我想错了。。。 然后想到，假如每一次有 $p$ 的概率取到，那么步数的期望为 $1+(1-p)+(1-p)^2+…=\\frac{1}{1-(1-p)}=\\frac 1p$？（有点忘了） 然后推出了一个 $dp$ 式子，形如 $dp_i=dp_{i+1}+\\frac{n}{i}$。 然后，发现 $n=k$ 的时候，要么没有合法方案，要么有一种，要么有两种。 有两种的时候，相当于 $a_i=i$ 。那么 $dp_{i,0/1,0/1}$ 记一下第一个位置和最后一个位置选了没有即可，转移方程有 $4$ 个，每个都移项，把式子推出来，写出来，过了自己造的小数据。 然后做 $n=10$ ，状压，然后再推式子，又推了好久，写完过样例后，大概考试时间过去大半了。 开始想T1的一条链，细节挺多，写了不少时间。然后写T3，枚举第一个的$b$，感觉跑的不慢？结果一测大样例，慢到飞起，一组数据1.5s，一共5组。。。直接自闭，考试也快结束了。 考完与同学交流，他说T1 $10pts$ 和 $5pts$ 做法一样（这个 $+5pts$ 在下面没看到）。T2 $50pts$可以Min-Max容斥，然后 $dp$ 就行了。和uoj422差不多。我一脸懵逼，我只是考前背了些板子，也背到过Min-Max容斥的式子，但咋还有期望形式，还有uoj422是啥题啊？ 回到家后 学习了一下 $min-max$ 容斥的期望形式，还有这种操作！然后15min写完T2 $50pts$。就是设 $dp[i][j][0/1]$ 表示前 $i$ 个数，选了 $j$ 个数，集合大小奇偶性 $0/1$ 的方案数（其中第 $i$ 个数必须选），然后暴力 $dp$ ，枚举上一个选了的数，时间复杂度 $O(kn^2)$。 经过思考，由于值域是 $1\\cdots 2m$ ，可以设 $dp[i][j][0/1]$ 表示当前值为 $i$ 的方案数，然后对于每个 $i$ 都计算（不管有没有在 $a$ 中出现过），在转移的时候再判断，没有出现的位置就不要转移过来。然后我们可以发现： 初始时，$dp[i][K][1]=1$。 1234567891011for (int j=1;j&lt;=m;j++) for (int k=0;k&lt;=1;k++)&#123; for (int t=1;t&lt;i;t++) if (max(j-K,t-(i-j))&gt;=0) dp[i][j][k]=(dp[i][j][k]+dp[t][max(j-K,t-(i-j))][k^1])%Mod; /* for (int t=1;t&lt;i-1;t++) if (max(j-1-K,t-(i-j))&gt;=0) dp[i-1][j-1][k]=(dp[i-1][j-1][k]+dp[t][max(j-1-K,t-(i-j))][k^1])%Mod; */ &#125; 考虑 $dp[i][j][k]$ 和 $dp[i-1][j][k]$，相差的是一段前缀（上界不同）和 $dp[i-1][j-1][k\\oplus 1]$，然后一个前缀和即可，但是实际上细节也不少（前缀和要把在 $a$ 中出现过的更新进去，并且还要考虑 $j-1==K\\ and \\ k==0$的情况），也调了不少时间，代码（不保证正确性，预计$70pts$）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int Mod=998244353;int m,K,a[210000],len[210000];int dp[2][5100][2],sum[10005][5005][2];int ans,Ans[210000];bool vis[410000];int getinv(int x)&#123; if (x==1) return 1; return 1ll*(Mod-Mod/x)*getinv(Mod%x)%Mod;&#125;inline int getnum(int x,int y,int z)&#123; if (x&lt;0) return 0; return (sum[x][y+1][z]-sum[x][y][z]+Mod)%Mod;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;K); for (int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+m+1); for (int i=m;i&gt;=1;i--)&#123; if (a[i+1]==a[i]+1) len[i]=len[i+1]; len[i]++; &#125; for (int i=1;i&lt;=m;i++) if (len[i]&gt;=K) vis[a[i]]=true; for (int j=1;j&lt;=m;j++) Ans[j]=(Ans[j-1]+1ll*m*getinv(j))%Mod; if (vis[1]) sum[1][K][1]=1; int now=0; for (int i=2;i&lt;=2*m;i++,now^=1)&#123; for (int j=1;j&lt;=m;j++) for (int k=0;k&lt;=1;k++) dp[now][j][k]=(dp[now^1][j-1][k]+getnum(i-K-1,j-(K+1),k^1))%Mod; dp[now^1][K][1]=(dp[now^1][K][1]+1)%Mod; if (vis[i-1])&#123; for (int j=0;j&lt;=m;j++) for (int k=0;k&lt;=1;k++) if (k&amp;1) ans=(ans+1ll*dp[now^1][j][k]*Ans[j])%Mod; else ans=(ans-1ll*dp[now^1][j][k]*Ans[j]%Mod+Mod)%Mod;// printf(&quot;%d:%d\\n&quot;,i-1,ans); &#125; for (int j=1;j&lt;=m;j++) for (int k=0;k&lt;=1;k++)&#123; if (vis[i-1]) dp[now][j][k]=(dp[now][j][k]+dp[now^1][j-1][k^1])%Mod; if (vis[i]) sum[i][j][k]=(sum[i-1][j][k]+dp[now][j][k])%Mod; else sum[i][j][k]=sum[i-1][j][k]; &#125; if (vis[i]) sum[i][K][1]=(sum[i][K][1]+1)%Mod; &#125; if (vis[2*m])&#123; dp[now][K][1]=(dp[now][K][1]+1)%Mod; for (int j=0;j&lt;=m;j++) for (int k=0;k&lt;=1;k++) if (k&amp;1) ans=(ans+1ll*dp[now][j][k]*Ans[j])%Mod; else ans=(ans-1ll*dp[now][j][k]*Ans[j]%Mod+Mod)%Mod; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; （网上有神仙说可以多项式求逆，不会做） 然后又做了做 $Day1T2$ ，首先先去看去年的那道线段树，就是分成5类点来分别算贡献。（可以参考$\\rm \\color{red}p\\color{black}inkrabbit$ 的 $blog$：https://www.cnblogs.com/PinkRabbit/p/ZJOI2019D1T2.html） 设当前区间为 $[l,r]$ ,父区间为 $[fa_l,fa_r]$。 令 $tot_i$ 表示第 $i$ 类点的个数，那么： 1234567tot1=seg_cnt-l*(n-r+1)-(getcnt(l-1)+getcnt(n-r));if (l==fa_l) tot2=l*(fa_r-r);else tot2=(l-fa_l)*(n-r+1);if (l==fa_l) tot3=getsum(n-fa_r+1,n-(r+1)+1);else tot3=getsum(fa_l,l-1);tot4=l*(n-r+1)-tot2;tot5=getcnt(l-1)+getcnt(n-r)-tot3; 其中，$getcnt(x)$ 是 $x(x+1)/2$ ，$getsum(l,r)$ 是 $l+(l+1)+\\cdots+r$。$seg_{cnt}=getcnt(n)$。 用同样的 $f,g$ 的定义，一次操作后，有：$\\ =\\ &lt;\\frac{tot_10+tot_21+tot_3g[u]+tot_4f[u]+tot_5f[u]}{seg_{cnt}},\\frac{tot_10+tot_21+tot_3g[u]+tot_4*1+tot_5g[u]}{seg_{cnt}}&gt;$ 设 $f[u]=af[u]+bg[u]+c,g[u]=xg[u]+y$ ，一个 $3*3$ 的矩阵即可。时间复杂度 $O(n \\log K)$。为了卡常可以把矩乘展开。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int Mod=998244353;int n,k,ans; ll seg_cnt,inv;ll tot1,tot2,tot3,tot4,tot5;ll a,b,c,x,y;inline ll getcnt(int n)&#123; return (1ll*n*(n+1)/2)%Mod;&#125;inline ll getsum(int x,int y)&#123; return (1ll*(x+y)*(y-x+1)/2)%Mod;&#125;ll getinv(int x)&#123; if (x==1) return 1; return 1ll*(Mod-Mod/x)*getinv(Mod%x)%Mod;&#125;struct mat&#123; ll m11,m12,m13,m21,m22,m23,m31,m32,m33; mat()&#123; m11=m12=m13=m21=m22=m23=m31=m32=m33=0;&#125; mat(ll v11,ll v12,ll v13,ll v21,ll v22,ll v23,ll v31,ll v32,ll v33)&#123; m11=v11; m21=v21; m31=v31; m12=v12; m22=v22; m32=v32; m13=v13; m23=v23; m33=v33; &#125; void operator*=(const mat &amp;x)&#123; ll t1,t2; t1=(m11*x.m11+m12*x.m21+m13*x.m31)%Mod; t2=(m11*x.m12+m12*x.m22+m13*x.m32)%Mod; m13=(m11*x.m13+m12*x.m23+m13*x.m33)%Mod; m11=t1; m12=t2; t1=(m21*x.m11+m22*x.m21+m23*x.m31)%Mod; t2=(m21*x.m12+m22*x.m22+m23*x.m32)%Mod; m23=(m21*x.m13+m22*x.m23+m23*x.m33)%Mod; m21=t1; m22=t2; t1=(m31*x.m11+m32*x.m21+m33*x.m31)%Mod; t2=(m31*x.m12+m32*x.m22+m33*x.m32)%Mod; m33=(m31*x.m13+m32*x.m23+m33*x.m33)%Mod; m31=t1; m32=t2; &#125;&#125;;int qpow()&#123; int a=k; mat res(1,0,0,0,1,0,0,0,1); mat x(::a,::b,::c,0,::x,::y,0,0,1); while (a)&#123; if (a&amp;1) res*=x; x*=x; a&gt;&gt;=1; &#125; return res.m13;&#125;int getans()&#123; tot1%=Mod; tot2%=Mod; tot3%=Mod; tot4%=Mod; tot5%=Mod; a=tot4+tot5; b=tot3; c=tot2; x=tot3+tot5; y=tot2+tot4; a=a*inv%Mod; b=b*inv%Mod; c=c*inv%Mod; //f[i][u]=a*f[i-1][u]+b*g[i-1][u]+c x=x*inv%Mod; y=y*inv%Mod; //g[i][u]=x*g[i-1][u]+y return qpow();&#125;void calc(int l,int r,int fa_l,int fa_r)&#123; tot1=seg_cnt-1ll*l*(n-r+1)-(getcnt(l-1)+getcnt(n-r)); if (l==fa_l) tot2=1ll*l*(fa_r-r); else tot2=1ll*(l-fa_l)*(n-r+1); if (l==fa_l) tot3=getsum(n-fa_r+1,n-(r+1)+1); else tot3=getsum(fa_l,l-1); tot4=1ll*l*(n-r+1)-tot2; tot5=getcnt(l-1)+getcnt(n-r)-tot3; ans=(ans+getans())%Mod;&#125;void solve(int l,int r)&#123; if (l==r) return; int mid; scanf(&quot;%d&quot;,&amp;mid); solve(l,mid); solve(mid+1,r); calc(l,mid,l,r); calc(mid+1,r,l,r);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); seg_cnt=getcnt(n); inv=getinv(seg_cnt); tot1=seg_cnt-1; tot2=1; tot3=0; tot4=0; tot5=0; ans=getans(); solve(1,n); printf(&quot;%d\\n&quot;,ans); return 0;&#125; 出分后 Day1T2挂成0了是什么鬼 Day2T1挂成0了是什么鬼 Day2T2挂成10了是什么鬼 凉了:cry: 总结 数学基础太差，这种期望竟然能推这么久。（dalao好像都一眼秒） 关于历年的题和难题做得太少（uoj422是一道集训队作业题） 在考试的时候要注意心态，不要刚开始想A，最后直接自闭去写最低档部分分。 明年再接再厉吧。","categories":[{"name":"ZJOI2020","slug":"ZJOI2020","permalink":"http://hydd.cf/categories/ZJOI2020/"}],"tags":[]},{"title":"20200705 五校联考题解","slug":"sol_2","date":"2020-07-04T16:00:00.000Z","updated":"2020-10-01T04:58:11.192Z","comments":true,"path":"2020/07/05/sol_2/","link":"","permalink":"http://hydd.cf/2020/07/05/sol_2/","excerpt":"","text":"mother 设字符集大小为 $|C|$。 这个问题可以 $dp$，设 $f[i]$ 表示，只考虑 $T$ 的前 $i$ 个元素，$S$ 出现在了$[i-m+1,i]$ ，同时这是 $S$ 唯一一次在 $T$ 中出现的方案数。 转移可以考虑容斥，减掉 $T$ 之前出现过的方案数。$f[i]=|C|^{i-m}-\\sum_{j=1}^{i-1} f[j]\\times P(i,j)$。其中 $P(i,j)$ 表示$S$ 第一次出现了以 $j$ 结尾的位置上，且 $S$ 在以 $i$ 结尾的位置也出现了的方案数。 若 $j\\leq i-m$，那么两个串不交的位置可以随便选。$\\sum_{k=m}^{i-1} f[i-k]\\times 52^{k-m}$。 若 $i-m+1\\leq j\\leq i-1$，那么要满足重复部分相同。$\\sum_{k\\in border(S),k\\neq m}f[i-(m-k)]$。 第一部分，直接类似前缀和记录一下即可。 第二部分，由于 $border$ 可以分成 $\\log n$ 个等差数列，所以可以对每个等差数列记相隔它的公差的前缀和即可。 时间复杂度 $O(n\\log m)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int Mod=998244353;int n,m,pre[21][1100000],f[1100000];int cnt,b[110000],Next[110000];char s[110000];int tot;struct node&#123; int mn,mx,d; node()&#123; mn=0; mx=0; d=0;&#125; node(int a,int b,int c)&#123; mn=a; mx=b; d=c;&#125;&#125; border[21];void solve(int x)&#123; if (x&gt;cnt) return; int d=max(1,b[x+1]-b[x]); for (int i=x;i&lt;=n;i++) if (i==n||b[i+1]-b[i]!=d)&#123; tot++; border[tot]=node(m-b[i],m-b[x],d); solve(i+1); break; &#125;&#125;int getsum(int x,int d,int l,int r)&#123; return (pre[x][r]-pre[x][max(l-d,0)]+Mod)%Mod;&#125;int main()&#123; freopen(&quot;mother.in&quot;,&quot;r&quot;,stdin); freopen(&quot;mother.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); m=strlen(s+1); Next[1]=0; int k=0; for (int i=2;i&lt;=m;i++)&#123; while (k&amp;&amp;s[k+1]!=s[i]) k=Next[k]; if (s[k+1]==s[i]) k++; Next[i]=k; &#125; while (k) b[++cnt]=k,k=Next[k]; reverse(b+1,b+cnt+1); solve(1); f[m]=1; for (int j=1;j&lt;=tot;j++) pre[j][m]=1; int mul=1,sum=0; for (int i=m+1;i&lt;=n;i++)&#123; mul=52ll*mul%Mod; sum=(52ll*sum+f[i-m])%Mod; int tmp=0;// for (int j=1;j&lt;=tot;j++) tmp=(tmp+f[i-(m-b[i])])%Mod; for (int j=1;j&lt;=tot;j++) tmp=(tmp+getsum(j,border[j].d,i-border[j].mx,i-border[j].mn))%Mod; f[i]=((mul-(sum+tmp))%Mod+Mod)%Mod; for (int j=1;j&lt;=tot;j++) pre[j][i]=(pre[j][i-border[j].d]+f[i])%Mod; &#125; int ans=0; mul=1; for (int i=n;i&gt;=m;i--)&#123; ans=(ans+1ll*mul*f[i])%Mod; mul=52ll*mul%Mod; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; rectangle 这真是一道神仙乱搞题。 首先我们把周长都 $/2$，现在的 $c$ 代表“半周长”。 我们发现 $c=2,s=1$ 是周长/面积比最大的矩形（也就是 $1\\times 1$ 的小正方形），我们称作“特殊正方形”。 那么我们可以考虑 $k=2s-c$，对于每一个 $k$ ，如果最小的可行的 $s’$ 满足，那么我们加入一个“特殊正方形”后，$k$ 不变，$s+1$。所以所有可行的 $s$ 为 $[s’,+\\infty)$。 记 $f(k)$ 为 $k=2s-c$ 的最小的可行的 $s’$，一种是单个矩形满足 $2s-c=k$，另外一种是多个矩形拼起来，我们可以暴力枚举，从 $f(t)+f(k-t)$ 转移过来。这样的复杂度是 $O(s^2)$ 的，注意 $k$ 最大值要枚举到 $2S$。 显然这样还是过不去，我们考虑优化掉一些不必要的转移。显然，我们不会从 $f(t)+f(k-t)$，其中 $f(t)$ 和$f(k-t)$ 都是拼接起来的转移过来。 通过打表，我们发现 $f(i)$ 只有可能从 $i$ 之前 $12$ 个非拼接出来的 $t$ 转移过来。 转移时间复杂度 $O(S)$，常数为 $24$。预处理时间复杂度约为 $O(S\\log S)$。 故总时间复杂度为 $O(S \\log S)$。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int s,c,cnt,num[1100000];int f[1100000];long long ans;int main()&#123; freopen(&quot;rectangle.in&quot;,&quot;r&quot;,stdin); freopen(&quot;rectangle.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;s,&amp;c); c&gt;&gt;=1; if (c&gt;s*2) c=s*2; memset(f,0x3f,sizeof(f)); int x,y; for (int i=1;i*i&lt;=s&amp;&amp;i+i&lt;=c;i++) for (int j=i;i*j&lt;=s&amp;&amp;i+j&lt;=c;j++)&#123; x=i*j; y=(x&lt;&lt;1)-i-j; if (y&lt;=2*s) f[y]=min(f[y],x); &#125; for (int i=2;i&lt;=2*s;i++)&#123; bool flag=false; for (int j=max(cnt-12,1);j&lt;=cnt;j++)&#123; int t=num[j]; if (f[t]&lt;INF&amp;&amp;f[i-t]&lt;INF&amp;&amp;f[i]&gt;f[t]+f[i-t])&#123; flag=true; f[i]=f[t]+f[i-t]; &#125; &#125; if (!flag) num[++cnt]=i; &#125; for (int i=0;i&lt;=2*s;i++) if (f[i]&lt;=s&amp;&amp;(c-(f[i]&lt;&lt;1)+i)&gt;=0) ans+=min(s-f[i]+1,((c-(f[i]&lt;&lt;1)+i)&gt;&gt;1)+1);//c必须和s+i奇偶性相同 printf(&quot;%lld\\n&quot;,ans); return 0;&#125; secret 显然得到每种局面都是等概率的。 假设最后第 $i$ 个人最后多获得了 $a_i$ 枚绿宝石，则有 $\\sum a_i=d$。 我们记 $f_{i,j}$ 表示 $i$ 个人（不是前 $i$ 个人）分 $j$ 枚绿宝石的方案数，记 $g_{i,j}$ 表示 $i$ 个人，其中绿宝石前 $r$ 多的人的数量之和。 我们考虑当前有绿宝石的人数 $k$，它们会对答案产生 $min(k,r)$ 的贡献，然后我们将这 $k$ 个人绿宝石数 $-1$。 f_{i,j}=\\sum_{i=0}^{\\min\\{i,j\\}}\\binom ik f_{k,j-k}\\\\ g_{i,j}=\\sum_{i=0}^{\\min\\{i,j\\}}\\binom ik (g_{k,j-k}+\\min\\{k,r\\}f_{k,j-k}) 当然，每个人初始还有一颗绿宝石，所以答案为 $\\frac{g_{i,j}}{f_{i,j}}+r$。 时间复杂度 $O(nd\\min\\{n,d\\})$。 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,d,r;long double C[1100][1100],f[1100][1100],g[1100][1100];int main()&#123; freopen(&quot;secret.in&quot;,&quot;r&quot;,stdin); freopen(&quot;secret.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;d,&amp;r); for (int i=0;i&lt;=1000;i++)&#123; C[i][0]=1; for (int j=1;j&lt;=i;j++) C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125; f[0][0]=1; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;=d;j++) for (int k=0;k&lt;=i&amp;&amp;k&lt;=j;k++)&#123; f[i][j]+=f[k][j-k]*C[i][k]; g[i][j]+=(g[k][j-k]+f[k][j-k]*min(k,r))*C[i][k]; &#125; double ans=g[n][d]/f[n][d]+r; printf(&quot;%.8lf\\n&quot;,ans); return 0;&#125;","categories":[{"name":"NOI模拟赛","slug":"NOI模拟赛","permalink":"http://hydd.cf/categories/NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[]},{"title":"多项式求逆/除法 笔记","slug":"note_2","date":"2020-07-04T16:00:00.000Z","updated":"2020-10-01T05:00:49.688Z","comments":true,"path":"2020/07/05/note_2/","link":"","permalink":"http://hydd.cf/2020/07/05/note_2/","excerpt":"","text":"多项式求逆 求满足 $G(x)F(x)\\equiv 1(\\operatorname{mod} x^n)$ 的 $n-1$ 次多项式 $G(x)$。 考虑倍增，假设我们求出了$G_0(x)$，$G_0(x)F(x)\\equiv 1(\\operatorname{mod} x^{\\lceil \\frac{n}{2}\\rceil})$。 移项可得 $G_0(x)F(x)-1\\equiv 0(\\operatorname{mod} x^{\\lceil \\frac{n}{2}\\rceil})$。两边同时平方有 $(G_0(x)F(x)-1)^2\\equiv 0(\\operatorname{mod} x^n)$。 化简，$F^2(x){G_0}^2(x)-2F(x)G_0(x)+1\\equiv 0(\\operatorname{mod} x^n)$。 整理可得 $(2G_0(x)-F(x){G_0}^2(x))F(x)\\equiv 1(\\operatorname{mod} x^n)$。 故 $G(x)\\equiv 2G_0(x)-F(x){G_0}^2(x) (\\operatorname{mod} x^n)$。 时间复杂度：$T(n)=T(\\frac{n}{2})+O(n \\log n)$。又因为 $(n+\\frac n2+\\frac n4+\\frac n8+\\cdots)\\times\\log n=2n\\log n$，所以 $T(n)=O(n \\log n)$。 多项式除法/取模 给定一个 $n$ 次多项式 $F(x)$，一个 $m$ 次多项式 $G(x)$（$n\\geq m$）。 求 $n-m$ 次多项式 $H(x)$ 和至多 $m-1$ 次多项式 $R(x)$，满足 $F(x)=G(x)H(x)+R(x)$。 考虑将多项式反转，$n$ 次多项式 $F(x)$ 反转后为 $x^nF(\\frac 1x)$。 那么有 $x^n F(\\frac 1x)=x^n(G(\\frac 1x)H(\\frac 1x)+R(\\frac 1x))$。（直观理解：将 $x$ 替换为 $\\frac 1x$ 然后两边 $\\times x^n$）。 配一下系数可得 $x^n F(\\frac 1x)=(x^mG(\\frac 1x))(x^{n-m}H(\\frac 1x))+(x^nR(\\frac 1x))$。 因为 $R(x)$ 的指数范围为 $[0,m-1]$，所以 $x^nR(\\frac 1x)$ 的指数范围为 $[n-m+1,n]$。 其它的多项式指数范围不变，只是系数反转了一下。 两边对 $x^{n-m+1}$ 取模可得 $x^n F(\\frac 1x)\\equiv (x^mG(\\frac 1x))(x^{n-m}H(\\frac 1x))(\\operatorname{mod} x^{n-m+1})$。 移项：$x^{n-m}H(\\frac 1x)\\equiv \\dfrac{x^n F(\\frac 1x)}{x^mG(\\frac 1x)}(\\operatorname{mod} x^{n-m+1})$。 将 $G(x)$ 反转后求逆，乘上反转后的 $F(x)$，得到反转后的 $H(x)$，再反转回来即可。$R(x)=F(x)-G(x)H(x)$。 时间复杂度：$O(n \\log n)$。 Note 附上代码（洛谷$P4512$）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define ls (now&lt;&lt;1)#define rs (now&lt;&lt;1|1)using namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int Mod=998244353;const int G=3; const int invG=332748118;int n,m,a[310000],rev[310000],ans[310000];poly f,g;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(poly a,poly b,poly &amp;c,int n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;void polyinv(int len,int bit,poly &amp;a,poly &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len);&#125;int getbit(int x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(int n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125;poly c,d;poly getdiv(poly a,poly b)&#123; int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; d.resize(1); d[0]=0; return d; &#125; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); b.resize(n-m+1); c.clear(); getinv(n-m+1,b,c); d.clear(); mult(c,a,d,n+(n-m+1)); d.resize(n-m+1); reverse(d.begin(),d.end()); return d;&#125;poly ans1,tmp,ans2;void getmod(poly &amp;a,poly b,poly &amp;c)&#123; int n=a.size()-1,m=b.size()-1; if (n&lt;m) return; ans1=getdiv(a,b); mult(ans1,b,tmp,n+m); c.resize(m); for (int i=0;i&lt;m;i++) c[i]=dec(a[i],tmp[i]);&#125;int main()&#123; n=read(); m=read(); f.resize(n+1); g.resize(m+1); for (int i=0;i&lt;=n;i++) f[i]=read(); for (int i=0;i&lt;=m;i++) g[i]=read(); getmod(f,g,ans2); ans1.resize(n-m); for (int i=0;i&lt;=n-m;i++) printf(&quot;%d &quot;,ans1[i]); putchar(&#x27;\\n&#x27;); for (int i=0;i&lt;m;i++) printf(&quot;%d &quot;,ans2[i]); return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hydd.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://hydd.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}]},{"title":"多项式牛顿迭代/Ln/Exp 笔记","slug":"note_3","date":"2020-07-03T16:00:00.000Z","updated":"2020-10-01T05:00:48.186Z","comments":true,"path":"2020/07/04/note_3/","link":"","permalink":"http://hydd.cf/2020/07/04/note_3/","excerpt":"","text":"多项式牛顿迭代 求满足 $G(F(x))\\equiv 0(\\operatorname{mod} x^n)$ 的 $n-1$ 次多项式 $F(x)$。 考虑倍增，假设我们求出了 $G(F_0(x))\\equiv 0(\\operatorname{mod} x^{\\lceil \\frac n2\\rceil})$。 由泰勒展开，有 $G(F(x))=\\frac{G(F_0(x))}{0!}+\\frac{G’(F_0(x))}{1!}(F(x)-F_0(x))+\\frac{G’’(F_0(x))}{2!}(F(x)-F_0(x))^2+\\cdots$。 显然 $F(x)\\equiv F_0(x)(\\operatorname{mod} x^{\\lceil \\frac n2\\rceil})$，那么 $F(x)-F_0(x)\\equiv 0(\\operatorname{mod} x^n)$。 则 $G(F(x))\\equiv G(F_0(x))+G’(F_0(x))(F(x)-F_0(x))(\\operatorname{mod} x^n)$。 又因为 $G(F(x))\\equiv 0(\\operatorname{mod} x^n)$，所以$F(x)\\equiv F_0(x)-\\frac{G(F_0(x))}{G’(F_0(x))}(\\operatorname{mod} x^n)$。 时间复杂度：$T(n)=T(\\frac{n}{2})+O(n \\log n)=O(n\\log n)$。 多项式 $\\ln$ 求满足 $B(x)\\equiv \\ln A(x)(\\operatorname{mod} x^n)$ 的 $n-1$ 次多项式 $B(x)$。 两边对 $x$ 求导，有 $B’(x)\\equiv\\frac{A’(x)}{A(x)}(\\operatorname{mod} x^n)$。（注意是复合函数求导，外层函数 $y=\\ln x$，内层函数 $y=f(x)$）。 这个 $B’(x)$ 可以通过多项式求逆，多项式求导，多项式乘法算出。$B(x)$ 可以通过多项式积分算出。 注意，这个方法需要 $A(x)$ 常数项为 $1$，否则求导再积分会出现奇怪的事情。 时间复杂度：$O(n\\log n)$。 多项式 $exp$ 求满足 $B(x)\\equiv e^{A(x)}(\\operatorname{mod} x^n)$ 的 $n-1$ 次多项式 $B(x)$。 两边取对数，$\\ln B(x)\\equiv A(x)(\\operatorname{mod} x^n)$。 令 $F(B(x))\\equiv \\ln B(x)-A(x)\\equiv 0(\\operatorname{mod} x^n)$。将 $A(x)$ 作为常数，则 $F’(B(x))\\equiv \\frac 1{B(x)}(\\operatorname{mod} x^n)$。 考虑牛顿迭代，$F(B(x))\\equiv F(B_0(x))+F’(B_0(x))(B(x)-B_0(x))(\\operatorname{mod} x^n)$，$B(x)\\equiv B_0(x)-\\frac{F(B_0(x))}{F’(B_0(x))}(\\operatorname{mod} x^n)$。 化简， $B(x)\\equiv B_0(x)(1-F(B_0(x)))\\equiv B_0(x)(1-\\ln B_0(x)+A(x))(\\operatorname{mod} x^n)$。 这个可以用多项式 $ln$，多项式乘法算出。 注意，这个方法需要 $A(x)$ 常数项为 $0$，否则 $\\ln$ 会出现奇怪的事情。 时间复杂度：$T(n)=T(\\frac{n}{2})+O(n \\log n)=O(n\\log n)$。（常数极大） 多项式快速幂 如果保证常数项为 $1$，直接 $\\ln$，然后每一项 $\\times k$，再 $exp$ 回去即可。 否则，设多项式为 $f(x)=\\sum a_ix^i$，$u$ 是满足 $a_u$ 不为 $0$ 的 $u$ 的最小值。把原多项式 $\\times \\frac 1{a_ux^u}$，正常的求快速幂，最后乘上 $(a_ux^u)^k=a_u^kx^{uk}$ 即可。 Note 多项式求导就是 $(x^n)’=nx^{n-1}$，多项式积分就是求导的逆运算。 附上代码（保证常数项为 $1$，洛谷$P5245$）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef vector&lt;int&gt; poly;typedef long long ll;const int Mod=998244353;const int G=3;int n,m,k,a[310000],rev[310000];poly f,g,ans;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=(1ll*x*10+ch-&#x27;0&#x27;)%Mod,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(const int &amp;x)&#123; return qpow(x,Mod-2);&#125;void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(poly a,poly b,poly &amp;c,const int &amp;n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;void polyinv(const int &amp;len,const int &amp;bit,poly &amp;a,poly &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len);&#125;inline int getbit(const int &amp;x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(const int &amp;n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125;void Dao(poly &amp;A,poly &amp;B,int len)&#123; for (int i=1;i&lt;len;i++) B[i-1]=1ll*i*A[i]%Mod; B[len-1]=0;&#125;void Jifen(poly &amp;A,poly &amp;B,int len)&#123; for (int i=1;i&lt;len;i++) B[i]=1ll*A[i-1]*getinv(i)%Mod; B[0]=0;&#125;poly A,B,C;void getln(poly &amp;f,poly &amp;g,int n)&#123; f.resize(n); g.resize(n); A.resize(n); B.resize(n); Dao(f,A,n); getinv(n,f,B); mult(A,B,C,n+n); Jifen(C,g,n);&#125;poly t;void getexp(const int &amp;n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=1; return; &#125; getexp(n&gt;&gt;1,a,b); getln(b,t,n); for (int i=0;i&lt;n;i++) t[i]=dec(a[i],t[i]); t[0]=add(1,t[0]); mult(t,b,b,n+n); t.clear(); b.resize(n);&#125;int main()&#123; n=read(); k=read(); f.resize(n); for (int i=0;i&lt;n;i++) f[i]=read(); for (m=1;m&lt;=n;m&lt;&lt;=1); f.resize(m); getln(f,g,m); for (int i=0;i&lt;m;i++) g[i]=1ll*g[i]*k%Mod; g.resize(m); getexp(m,g,ans); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,ans[i]); return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hydd.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://hydd.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}]},{"title":"2020年5月数竞 笔记","slug":"note_1","date":"2020-05-13T16:00:00.000Z","updated":"2020-10-01T05:11:20.342Z","comments":true,"path":"2020/05/14/note_1/","link":"","permalink":"http://hydd.cf/2020/05/14/note_1/","excerpt":"","text":"0513上午1、子图导出子图（Induced subgraph） $G=(V,E)$，$G$ 在 $v_1$ 上的导出子图 $G_1=(V_1,E_1),E_1=\\{e\\in E\\mid u,v\\in v_1\\}$ 相当于在图中去掉一些点。$n$ 阶导出子图有 $2^n$ 个。 生成子图（Spanning subgraph） $G=(V,E)$，$G_1$ 为 $G$ 生成子图是指 $V(G_1)=V(G),E(G_1)\\subseteq E(G)$ 相当于在图中去掉一些边。生成子图有 $2^{|E|}$ 个。 $\\color{red}{\\texttt{Note: }}$ 导出子图和生成子图都不限定是否为简单图。 既是导出子图又是生成子图为原图。 2、Mantel 定理、托兰定理Mantel’s thm 如果图 $G=(V,E)$ 中没有三角形，则 $|E|\\leq [\\frac{n^2}4]$ 。 等号成立条件 $\\Longleftrightarrow$ $G=K_{\\lfloor \\frac n2\\rfloor\\lceil \\frac n2\\rceil}$。 Turan’s thm 若 $G$ 无 $K_k$ 子图，$G$ 的边数取最大值的图唯一，为$G=K_{x_1,x_2,…,x_{k-1}}$，其中$\\sum_{i=1}^{k-1} x_i=n$，同时 $|x_i-x_j|\\leq 1$。 形式化的，$G=K_{[\\frac n{k-1}][\\frac {n+1}{k-1}]…[\\frac{n+k-2}{k-1}]}$，$\\sum_{i=0}^{r-1} [\\frac{x+i}r]=[x]$。 3、二分图二分图（Bipartite Graph） 定义 $G=(V,E),V=A\\cup B$。 $\\forall u,v\\in A,(u,v)\\notin E$ 且 $\\forall u,v\\in B,(u,v)\\notin E$。 则称 $G$ 为二分图。 二分图判定定理 一个图 $G$ 是二分图，当且仅当图 $G$ 无奇环。 命题①：$G$ 是二分图 命题②：$G$ 无奇环 命题③：$G$ 无奇数长的回路 通过 ①$\\Rightarrow$②$\\Rightarrow$③$\\Rightarrow$① 可证得三个命题相互等价，在此略去。 4、完美匹配、Hall定理、Tutte定理匹配（Matching） $G=(V,E)$，$E$ 的子集 $E_1$ 的顶点两两不重合。则 $E_1$ 为 $G$ 的匹配。 完美匹配（Perfect Matching,PM） 匹配 $E_1$ 的顶点覆盖 $V$，$G$有PM $\\Rightarrow$ $|G|\\equiv 0(\\operatorname{mod} 2)$ 二分图完美匹配 $G$ 为二分图 $(x,y,E)$。 $G$ 有 PM ，则 $|X|=|Y|$ 且 $X$ 到 $Y$ 有双射。 $f$ 称为由 PM $E$ 诱导（induce） 的双射。 满足 $f(x_i)=y_i,(x_i,y_i)\\in E(E_1=\\{(x_i,y_i)\\mid 1\\leq i\\leq |X|\\})$。 Hall 定理 二分图有完美匹配的充要条件为：$\\forall S\\subseteq X，|N(S)|\\geq |S|$（有匹配覆盖 $X$ 的所有顶点），$\\forall S\\subseteq Y,|N(S)|\\geq |S|$（有匹配覆盖 $Y$ 的所有顶点）。 Tutte 定理 对于图 $G$ ，$G$ 有PM的充要条件为 $\\forall S\\subseteq V$ ，$G$ 在 $V-S$ 上的导出子图 $M$ 的有奇数个顶点的连通分支的个数 $\\leq |S|$。 5、正则图的定义正则图 一个图为 $k-\\texttt{正则}$ 的，定义为 $\\forall v\\in V,d(v)=K$ 。 0513下午1、欧拉图的定义欧拉图 Euler Graph 存在一条回路，经过图 $G$ 的全部的边恰好一次。（欧拉回路） 2、一笔画的算法，欧拉图的充要条件 若一个图 $G$ 存在 $0$ 个或 $2$ 个奇点，则这个图可以一笔画。 欧拉图充要条件：$\\forall v\\in V,2\\mid d(v)$。 3、哈密顿（Hamilton）图、哈密顿链的定义哈密顿图 一个图 $G$ 为哈密顿图 $\\Longleftrightarrow$ 存在一条回路包含图 $G$ 的全部顶点，这个回路被称为 Hamilton 圈。 哈密顿链 若一条链 $P$ 遍历了图 $G$ 的全部顶点，则称 $P$ 为哈密顿链。 4、Hamilton 性质、必要条件必要条件 设 $S$ 为 $G$ 的一个顶点子集，若 $G$ 在 $V-S$ 上导出子图的连通分量个数大于 $|S|$ $(|S|+1)$ ，则 $G$ 无哈密顿图（链）。 二分图有哈密顿圈（链），必要条件为 $||X|-|Y||\\leqslant 0$（$1$）。 5、哈密顿图（链）的一些充分条件：Ore条件、Dirac条件Ore 条件 若 $G$ 为哈密顿图，设 $|G|=n$，则 $\\forall v,d(v)\\geqslant \\frac{n}{2}$。 Dirac 条件 若 $G$ 为哈密顿图，设 $|G|=n$，则 $\\forall u,v$，若 $(u,v)\\notin E$ ，$d(u)+d(v)\\geqslant n$。 若 $G$ 存在哈密顿链，则 $d(u)+d(v)\\geqslant n-1$。 6、图的笛卡尔积的定义 集合的笛卡尔积： $A\\times B=\\{(a,b)\\mid a\\in A,b\\in B\\}$。 图的笛卡尔积： $G=(V,E)\\space ,\\space H=(U,F)$。 定义 $G\\times H=(V\\times U,E’)$。$E’=\\{(v_1,u)(v_2,u)\\mid v_1,v_2\\in E,u\\in U\\}\\cup\\{(v,u_1)(v,u_2)\\mid u_1,u_2\\in F,v\\in V\\}$。 0514上午1、图的顶点染色染色的定义 一般染色：$f:x\\rightarrow \\{1,2,3,\\cdots,k\\}$。其中，$1\\cdots k$ 是颜色集合。（高联一般不考虑无穷染色） 图的顶点染色：$G=(V,E)$ 无限制的染色：$f:V\\rightarrow \\{1,2,3,\\cdots,k\\}$ 一般意义上的图染色：$f:V\\rightarrow \\{1,2,3,\\cdots,k\\}$，且对于 $\\forall(a,b)\\in E,a\\neq b,f(a)\\neq f(b)$ 染色数的定义 最小使得染色映射 $f$ 存在的 $k$ 称为图 $G$ 的色数，记为 $\\chi(G)$。（chromatic number） $\\color{red}{\\texttt{Note: }}$ $n$ 阶图一定可以用 $n$ 种颜色染色。随机图算色数较为困难。 答题方法：考试时将颜色标在图上，再证明不存在更少的色数。 常用结论： $\\chi(K_n)=n$（ $n$ 阶完全图 ） $\\chi (C_n)=\\begin{cases}2, &amp;2\\mid n \\\\3, &amp;2\\nmid n\\end{cases}$（ $n$ 个点的环） $\\chi (T)=2\\ (n\\geqslant 2)$ （ $n(n\\geqslant 2)$个点的树） 2、色数的简单估计估计色数上下界下界 团数（clique number）：设团数 $\\omega(G)$ 为 $G$ 中最大完全子图的阶数。 明显的下界：$\\chi (G)\\geqslant \\omega(G)$。 最大独立集：一个图的最大独立集 $S\\subseteq V$，是指点数最大的两两不连的顶点集合。 独立数（independence number）：设独立数 $\\alpha(G)$ 为图 $G$ 的最大独立集顶点数。 另一个下界：$\\chi(G)\\geqslant \\frac{n}{\\alpha(G)}$。 上界 上界：$\\chi(G)\\leqslant 1+\\Delta(G)$。 3、Brooks 定理简介Brook’s Thm 设 $G$ 为连通图且不是完全图或奇圈。则必有 $\\chi(G)\\leqslant \\Delta(G)$。 前提的等价表述：$\\Delta\\geqslant 3$，且$\\exists\\ u,v\\in V,(u,v)\\notin E$。 4、色多项式（chromatic polynomial） 我们考虑一张一般的图 $G$ ，将它 $k$ 染色的方案数。 我们在图 $G$ 上任取一条边 $e=(u,v)$，把 $e$ 去掉。 然后我们对 $G\\setminus e$（从 $G$ 中删去边 $e$）的任一种染色 $f$。 对于 $f(u)\\neq f(v)$ 的 $f$，则 $f$ 也是 $G$ 的染色。 对于 $f(u)=f(v)$ 的 $f$，则$f$ 是图 $G\\cdot e$ 的染色（把 $G$ 中 $e$ 的端点合并，去掉重边） 反之，$G$ 的染色均是 $G\\setminus e$ 的使 $f(u)\\neq f(v)$ 的染色，$G\\cdot e$ 的染色均是 $G\\setminus e$ 的使 $f(u)=f(v)$ 的染色。 于是，我们定义 $F_G(k)$ 为 $k$ 种颜色对 $G$ 染色的方案数。 此时，$F_{G\\setminus e}(k)=F_G(k)+F_{G\\cdot e}(k)$，即 $F_G(k)=F_{G\\setminus E}-F_{G\\cdot E}(k)$。 对边数归纳可证对于任意的 $G$，$F_G$ 为关于 $k$ 的 $n$ 次多项式。$F_\\texttt{n个点，没边}=k^n$ 。 $F$ 首项系数$=1$，次高项系数$=-|E|$。 当 $k&lt;\\chi(G)$ 时，$F_G(k)=0$，$(x-k)|F_G(k)$。 5、平面图的定义 可以画在平面上，使边与边只在顶点处相交（边可以为曲线或折线）。 6、库拉托夫斯基定理Kuratowski’s Thm 一个图是平面图当且仅当 $G$ 无同胚与 $K_5$ 或 $K_{3,3}$ 的子图。 同胚：如果两个图 $G_1$ 和 $G_2$ 同构，或经过反复插入（将 $e=(u,v)$ 拆成 $e_1=(u,w),e_2=(w,v)$）或消去 $2$ 度顶点后同构，则称 $G_1$ 与 $G_2$ 同胚。 7、欧拉公式（多面体/平面图） 连通图 $G$ 为平面图，$|G|=n,||G||=e,$面数$=f$，则 $n-e+f=2$。 0514下午1、Ramsey 问题前置知识 图 $G=(V,E)$ ，图的一个边染色指映射 $f:E\\rightarrow \\{1,2,3,\\cdots\\}$。 对 $\\forall e_i,e_j$ ，若 $e_i\\cap e_j\\neq \\varnothing$，则 $f(e_i)\\neq f(e_j)$。 所需最小色数 $k$ 称为图 $G$ 的边染色数 $\\chi’(G)$，显然 $\\chi’(G)\\geqslant \\Delta(G)$。 Viking Thm $\\chi’(G)\\leqslant 1+\\Delta(G)$。 Ramsey’s Thm $\\forall s,t\\in \\mathbb{N}^+$，对 $K_n$ 的边 $2$ 染色，当 $n$ 足够大时，存在红色 $K_s$ 或 蓝色 $K_t$ 子图。 最小满足上述条件的 $n$ 称为 Ramsey 数 $r(s,t)$。 $\\color{red}{\\texttt{Note: }}$ 常用结论： $r(s,t)=r(t,s)$，显然。 $\\forall x\\quad r(x,1)=r(1,x)=1$，证明显然。 $\\forall x\\quad r(x,2)=r(2,x)=x$，证明显然。 $r(s,t)\\leqslant r(s,t-1)+r(s-1,t)$，证明可以对 $s+t$ 归纳，在此略去。 ④的推论：$r(s,t)\\leqslant \\binom{s+t-2}{s-1}$，显然。 2、简单的 Ramsey 数$r(3,3)=6$ 根据结论⑤，有$r(3,3)\\leqslant \\binom{4}{2}=6$ 证明 $5$ 不可以，请读者自行证明。 $r(3,4)=9$ 请读者自行证明。 $r(3,5)=14$ $r(3,5)\\leqslant r(3,4)+r(2,5)=9+5=14$ 证明 $13$ 不可以，给出简要思路：循环构造，将 $i-j\\equiv \\pm 1 \\operatorname{or} \\pm 5$ 连红边，否则连蓝边。 3、范德瓦尔登定理Vander Waerden’s Thm $\\forall m\\in \\mathbb{N}^+,\\exists N$，使集合 $\\{1,2,3,4,\\cdots,N\\}$ 的任意 $2$ 染色必定存在同色，长度为 $m$ 的等差数列。 上面的表述等价于 $\\exists N_1,\\{1,\\cdots ,N_1\\}$ $2$ 染色存在长为 $N$ 的同色等差数列。 4、同色角，异色角方法 我们将角的两条边颜色相同的角称为 同色角 ，将角的两条边颜色不同的角称为 异色角 。 显然，有同色 $\\Delta$ 数 $+$ 异色 $\\Delta$ 数 $=\\binom n3$。 同色$\\Delta$ 异色$\\Delta$ $\\sum$ 同色角 3 1 $3\\times \\texttt{同色}+1\\times {异色}$ 异色角 0 2 $2\\times \\texttt{异色}$ 计 3 3 / 我们考虑顶点在 $v$ 处的 $\\Delta$ 。同色角数$=\\binom{d_\\texttt{红}(v)}2+\\binom{d_\\texttt{蓝}(v)}2$。异色角数$=d_\\texttt{红}(v)\\times d_\\texttt{蓝}(v)$。所有角数$=\\binom{d_\\texttt{红}(v)+ d_\\texttt{蓝}(v)}2$。 整个图 $\\sum_{v\\in V} \\binom{d_\\texttt{红}(v)}2+\\sum_{v\\in V} \\binom{d_\\texttt{蓝}(v)}2+\\sum_{v\\in V}d_\\texttt{红}(v)\\times d_\\texttt{蓝}(v)$。 即我们可以将 同/异色$\\Delta$ 与 顶点的红蓝度 相互转化。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hydd.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数竞","slug":"数竞","permalink":"http://hydd.cf/tags/%E6%95%B0%E7%AB%9E/"}]},{"title":"正睿5月集训 总结","slug":"sum_4","date":"2020-05-07T16:00:00.000Z","updated":"2020-10-01T05:06:06.510Z","comments":true,"path":"2020/05/08/sum_4/","link":"","permalink":"http://hydd.cf/2020/05/08/sum_4/","excerpt":"","text":"2020.05.01 ZR集训ZROJ1390 【五一省选集训day1】a 当时的解法：多项式快速幂 中间过程没开 $\\rm long\\ long$ 。 期望得分60，实际得分0，修改后得分40（被卡常数）。 总结：要仔细检查 $\\rm long\\ long$，也可以使用#define int long long 进行对拍。 2020.05.02 ZR集训ZROJ1404 【五一省选集训day2-T1】或许 当时的解法：离线可删除的线性基 $2e6$ 读入没加快读（233），用 $\\rm scanf$ 读入TLE 期望得分100，实际得分53，修改后得分100。 总结：读入规模超过 $5\\times 10^5$，就需要使用快读 ZROJ1405 【五一省选集训day2-T2】这就是 当时的解法：大暴力 合并两个 $\\rm subtask$ 时，$\\rm subtask1$ 的情况完成后没有 $\\rm return$，再用 $\\rm subtask2$ 做了一遍，RE 期望得分14，实际得分11，修改后得分14。 总结：每个 $\\rm subtask$ 做完之后必须 $\\rm return$ 。 ZROJ1413 【五一省选集训day6】A 当时的解法：线性筛，sg函数 求一个数的质因子个数时，将 gettot[i*prime[j]]=gettot[i]+1 写成 gettot[i*prime[j]]=gettot[prime[j]]+1;。 期望得分30，实际得分0，修改后得分30 总结：要仔细 T1 T2 T3 Day1 期望，多项式 dp，概率 随机，二分图匹配 Day2 离线删除线性基 状压dp，计数 莫队，根号分治 Day3 贪心，计数 dp，线段树优化 构造，基数排序 Day4 回滚莫队，分块 贪心，构造，基数排序 二分，ST表 Day5 子序列自动机，倍增 矩乘优化dp，期望 贪心，类最大生成树 Day6 Surreal number 博弈 建图，线段树 Suurballe’s algorithm 考试过程中发现的错误/订正中出现的错误 精度问题：const ll INF=1e18+1或const ll INF=(1e18)+1。而默认double的精度只有53位（二进制下），由于精度误差，最后INF变成了$10^{18}$，而不是预计的$10^{18}+1$。 变量名重名和混用。（要尽量避免变量名相似？） Note 相对比较擅长简单数据结构题。 实现的时候要注意细节，时间充足时要对拍 计划 要多做计数，构造，期望题。（这类题目应该在atcoder上比较多） 多项式方面还有很大的空缺，需要学习多项式算法。 要记各种各样的模板。（网络流，splay，LCT，FFT/NTT，FWT等）","categories":[],"tags":[]}],"categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"http://hydd.cf/categories/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"CSP-S2020","slug":"CSP-S2020","permalink":"http://hydd.cf/categories/CSP-S2020/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://hydd.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"省选模拟赛","slug":"省选模拟赛","permalink":"http://hydd.cf/categories/%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://hydd.cf/categories/Codeforces/"},{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://hydd.cf/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"FOI2020高级培训","slug":"FOI2020高级培训","permalink":"http://hydd.cf/categories/FOI2020%E9%AB%98%E7%BA%A7%E5%9F%B9%E8%AE%AD/"},{"name":"NOI2020","slug":"NOI2020","permalink":"http://hydd.cf/categories/NOI2020/"},{"name":"APIO2020","slug":"APIO2020","permalink":"http://hydd.cf/categories/APIO2020/"},{"name":"WC2020","slug":"WC2020","permalink":"http://hydd.cf/categories/WC2020/"},{"name":"NOI模拟赛","slug":"NOI模拟赛","permalink":"http://hydd.cf/categories/NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"字符串","slug":"字符串","permalink":"http://hydd.cf/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"ZJOI2020","slug":"ZJOI2020","permalink":"http://hydd.cf/categories/ZJOI2020/"},{"name":"省选联考2020","slug":"省选联考2020","permalink":"http://hydd.cf/categories/%E7%9C%81%E9%80%89%E8%81%94%E8%80%832020/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"http://hydd.cf/tags/%E5%AE%B9%E6%96%A5/"},{"name":"搜索","slug":"搜索","permalink":"http://hydd.cf/tags/%E6%90%9C%E7%B4%A2/"},{"name":"FMT","slug":"FMT","permalink":"http://hydd.cf/tags/FMT/"},{"name":"图论","slug":"图论","permalink":"http://hydd.cf/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"树形dp","slug":"树形dp","permalink":"http://hydd.cf/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"概率/期望","slug":"概率-期望","permalink":"http://hydd.cf/tags/%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"},{"name":"斯特林数","slug":"斯特林数","permalink":"http://hydd.cf/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://hydd.cf/tags/Tarjan/"},{"name":"树上差分","slug":"树上差分","permalink":"http://hydd.cf/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"},{"name":"字符串","slug":"字符串","permalink":"http://hydd.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"多项式","slug":"多项式","permalink":"http://hydd.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"数竞","slug":"数竞","permalink":"http://hydd.cf/tags/%E6%95%B0%E7%AB%9E/"}]}