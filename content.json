{"meta":{"title":"hydd's blog","subtitle":"","description":"","author":"hydd","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2020-09-30T05:49:05.000Z","updated":"2020-09-30T06:17:40.281Z","comments":true,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"分类","date":"2020-09-29T16:00:00.000Z","updated":"2020-09-30T06:06:27.120Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-29T16:00:00.000Z","updated":"2020-09-30T06:05:48.846Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"模板","date":"2020-09-30T11:25:33.000Z","updated":"2020-09-30T11:30:40.238Z","comments":true,"path":"template/index.html","permalink":"http://example.com/template/index.html","excerpt":"","text":"此博客不对外公开，有些代码/算法讲解是从网上copy的，所以应该不存在版权问题（？） 若有人公开了这篇博客的密码，请联系我。QQ：3058728305 0. 一些奇怪的东西 常用结论： 普通幂转第二类斯特林数：$i^k=\\sum\\limits_{j=1}^{i}S_{k,j}\\times C_{i,j}\\times j! $。 第二类斯特林数求自然数幂和：$\\sum\\limits ^{n}_{i=0}i^k= \\sum\\limits_{j=1}^{n}S_{k,j}\\times j!\\times C_{n+1,j+1}$。 $\\rm min-max$容斥：$\\max(S)=\\sum_{T \\subseteq S}(-1)^{|T|+1}\\min(T)$，$\\min(S)=\\sum_{T \\subseteq S}(-1)^{|T|+1}\\max(T)$ $\\gcd-\\mathrm{lcm}$容斥：$\\mathrm{lcm}(T)=\\prod_{S\\in T}\\gcd(S)^{(-1)^{|S|+1}}$ 多项式开根：若$B’^2(x)\\equiv A(x) (mod\\ x^{\\frac{n}{2}})$，$B^2(x)\\equiv A(x) (mod\\ x^{n})$，则有以下等式成立：$B(x)\\equiv \\dfrac{A(x)+B’^2(x)}{2B’(x)} (mod\\ x^n)$。 0.1 读入优化 复习完成！！！ 1234567891011121314151617181920212223char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;char readop()&#123; char ch=Getchar(); while (ch&lt;&#x27;A&#x27;||ch&gt;&#x27;Z&#x27;) ch=Getchar(); return ch;&#125; 0.2 输出优化123456789101112131415161718192021char pbuf[100000],*pp=pbuf;void pc(const char c) &#123; if (pp-pbuf==100000) fwrite(pbuf,1,100000,stdout),pp=pbuf; *pp++=c;&#125;void write(int x) &#123; static int sta[35]; if (x&lt;0)&#123; pc(&#x27;-&#x27;); x=-x; &#125; int top=0; do&#123; sta[top++]=x%10; x/=10; &#125; while(x); while (top) pc(sta[--top]+&#x27;0&#x27;);&#125;void myfflush()&#123; fwrite(pbuf,1,pp-pbuf,stdout);&#125; 0.3 取模优化123inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125; 1. 数论1.1 预处理阶乘和阶乘逆元1234567fac[0]=1; for (int i=1;i&lt;=10000000;i++) fac[i]=fac[i-1]*i%Mod;inv[1]=1; for (int i=2;i&lt;=10000000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;inv[0]=1; for (int i=1;i&lt;=10000000;i++) inv[i]=inv[i-1]*inv[i]%Mod;ll C(int n,int m)&#123; if (n&lt;m) return 0; return 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;&#125; 1.2 快速幂12345678ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125; 1.3 gcd&amp;lcm12345int gcd(int a,int b)&#123; if (!b) return a; return gcd(b,a%b);&#125;int lcm(int a,int b)&#123; return 1ll*a/gcd(a,b)*b;&#125; 1.4 CRT12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int n;ll a[11],b[11];ll mult(ll a,ll b,ll mod)&#123; if (a&lt;b) swap(a,b); ll ans=0; while (b)&#123; if (b&amp;1) ans=(ans+a)%mod; a=(a&lt;&lt;1)%mod; b&gt;&gt;=1; &#125; return ans;&#125;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if (!b)&#123; x=1; y=0; return; &#125; exgcd(b,a%b,x,y); ll tmp=x; x=y; y=tmp-a/b*y;&#125;ll CRT(int n)&#123; ll x,y; ll ans=0,lcm=1; for (int i=1;i&lt;=n;i++) lcm*=b[i]; for (int i=1;i&lt;=n;i++)&#123; ll tmp=lcm/b[i]; exgcd(tmp,b[i],x,y); x=(x%b[i]+b[i])%b[i]; ans=(ans+mult(mult(tmp,x,lcm),a[i],lcm))%lcm; &#125; return (ans+lcm)%lcm;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lld&quot;,&amp;b[i]); a[i]=(a[i]%b[i]+b[i])%b[i]; &#125; printf(&quot;%lld\\n&quot;,CRT(n)); return 0;&#125; 1.5 exgcd&amp;excrt 背过了 考虑合并两个方程 $x\\equiv a_1(\\operatorname{mod} m_1),x\\equiv a_2(\\operatorname{mod} m_2)$。 那么，有 $x=a_1+k_1\\times m_1,x=a_2+k_2\\times m_2$。 $k_2\\times m_2-k_1\\times m_1=a_1-a_2$。 令 $c=a_1-a_2$，$g=gcd(m_2,m_1)$。 那么，若 $g\\nmid c$，则方程无解。否则 $g\\mid c,\\frac{c}{g}\\in \\Z$。 我们可以用 $exgcd$ 求出 $k_2’\\times m_2+k_1’\\times m_1=g$ 中满足条件的 $k_1’$。 将两边同时乘 $\\frac{c}{g}$，即 $k_1’,k_2’$ 乘上 $\\frac cg$，右边变成 $c$ 。 我们得到了 $k_2’\\times m_2+k_1’\\times m_1=c$ 的解 $k_1’$。可以将 $k_1’ \\mod m_2$。 但是注意，我们的原方程是 $k_2\\times m_2-k_1\\times m_1=a_1-a_2$，故 $k_1=-k_1’$。 也就是 $x=a_1-k_1’\\times m_1$。我们就求出了一个解 $x_0$。那么通解是 $x\\equiv x_0(\\operatorname{mod} \\operatorname{lcm}(m_1,m_2))$。 1234567891011121314151617181920212223typedef long long ll;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if (!b)&#123; x=1; y=0; return a; &#125; ll g=exgcd(b,a%b,y,x); y-=a/b*x; return g;&#125;ll a[N],m[N];ll excrt()&#123; ll M=m[1],A=a[1],x,y,d; for (int i=2;i&lt;=n;i++)&#123; d=exgcd(M,m[i],x,y); if ((A-a[i])%d) return -1; x=(A-a[i])/d*x%m[i]; A-=M*x; M=M/d*m[i]; A%=M; &#125; return (A%M+M)%M;&#125; 1.6 Pollard Rho 输出 $n$ 的最大质因子（$1\\leqslant n\\leqslant 10^{18}$） todo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;#define ctz __builtin_ctzllusing namespace std;typedef long long ll;ll ans;/*inline ll mul(ll x,ll y,ll Mod)&#123; ll ret=x*y-((ll)((long double)x/Mod*y+0.5))*Mod; return (ret%Mod+Mod)%Mod;&#125;*/inline ll mul(ll x,ll y,ll p)&#123; return (__int128)x*y%p;&#125;inline ll qpow(ll x,ll a,ll Mod)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=mul(res,x,Mod); x=mul(x,x,Mod); a&gt;&gt;=1; &#125; return res;&#125;inline ll rdm()&#123; return 1ll*rand()&lt;&lt;31|rand();&#125;ll gcd(ll x,ll y)&#123; if (!y) return x; return gcd(y,x%y);&#125;bool Miller_Rabin(ll n)&#123; if (n==2||n==3) return true; if (!(n&amp;1)||(n==1)||!(n%3)) return false; ll p=n-1,m=0; while (!(p&amp;1)) p&gt;&gt;=1,++m; int Case=8; while (Case--)&#123; ll lst=qpow(rdm()%(n-1)+1,p,n),now=lst; for (int i=1;i&lt;=m;i++)&#123; now=mul(now,now,n); if (now==1&amp;&amp;lst!=1&amp;&amp;lst!=n-1) return false; lst=now; &#125; if (now!=1) return false; &#125; return true;&#125;ll Pollard_Rho(ll n,int c)&#123; ll i=1,k=2,x=rand()%(n-1)+1,y=x,sum=1; while (true)&#123; i++; x=(mul(x,x,n)+c)%n; sum=mul(sum,(y-x+n)%n,n); if (x==y||!sum) return n; if (i==k||i%127==0)&#123; int d=gcd(sum,n); if (d!=1) return d; if (i==k)&#123; y=x; k&lt;&lt;=1;&#125; &#125; &#125;&#125;void work(ll n)&#123; if (n&lt;=ans) return; if (Miller_Rabin(n))&#123; ans=max(ans,n); return; &#125; ll tmp=n; while (tmp==n) tmp=Pollard_Rho(n,rand()%n); while (n%tmp==0) n/=tmp; work(tmp); work(n);&#125;int main()&#123; srand(time(NULL)); int T; ll x; scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; scanf(&quot;%lld&quot;,&amp;x); if (Miller_Rabin(x))&#123; puts(&quot;Prime&quot;); continue;&#125; ans=0; work(x); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;//贴个超级短的：LL pollardRho(LL n, int a)&#123; LL x=2,y=2,d=1; while(d==1)&#123; x=(x*x+a)%n; y=(y*y+a)%n;y=(y*y+a)%n; d=gcd(abs(x-y),n); &#125; if(d==n) return pollardRho(n,a+1); return d;&#125; 1.7 欧拉筛（线性筛）最小质因子 复习完成 1234567891011//注意1不为质数 for (int i=2;i&lt;=n;i++)&#123; if (!lst[i])&#123; lst[i]=i; prime[++cnt]=i; &#125; for (int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123; lst[i*prime[j]]=prime[j]; if (i%prime[j]==0) break; &#125;&#125; 1.8 BSGS todo 12345678910111213141516int BSGS(ll a,ll b)&#123; int blo=(int)(sqrt(p)+1); ll base=b; for(int i=0;i&lt;blo;i++)&#123; myhash[base]=i; base=base*a%Mod; &#125; ll tmp=1; base=qpow(a,blo); for(int i=1;i&lt;=blo+1;i++)&#123; tmp=tmp*base%Mod; int t=tmp; if (myhash.count(t)) return i*blo-myhash[t]; &#125; return -1;&#125; 1.9 欧拉筛（线性筛）mu/phi 复习完成 12345678910111213141516171819202122int cnt,mu[110000],p[110000],phi[110000];bool vis[110000];void init(int n)&#123; vis[1]=1;//注意，1不是质数 phi[1]=0; mu[1]=1; for (int i=2;i&lt;=n;i++)&#123; if (!vis[i])&#123; p[++cnt]=i; phi[i]=i-1; mu[i]=-1; &#125; for (int j=1;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;j++)&#123; vis[i*p[j]]=true; if (i%p[j]==0)&#123; phi[i*p[j]]=phi[i]*p[j]; mu[i*p[j]]=0; break; &#125; phi[i*p[j]]=phi[i]*(p[j]-1); mu[i*p[j]]=-mu[i]; &#125; &#125;&#125; 2.数据结构2.1 树状数组 没必要 单点加，区间求和12345678void add(int *tree,int x,int y)&#123; for (;x&lt;=N;x+=x&amp;-x) tree[x]+=y;&#125;int getsum(int *tree,int x)&#123; int sum=0; for (;x;x-=x&amp;(-x)) sum+=tree[x]; return sum;&#125; 区间加，区间求和123456789101112131415161718192021222324252627282930313233/* b[i]=a[i]-a[i-1] a[1] + a[2] + ... + a[n] = (b[1]) + (b[1]+b[2]) + ... + (b[1]+b[2]+...+b[n]) = n*b[1] + (n-1)*b[2] +... +b[n] = n * (b[1]+b[2]+...+b[n]) - (0*b[1]+1*b[2]+...+(n-1)*b[n]) sum1[i] = \\sum b[i],sum2[i] = \\sum b[i]*(i-1)*/int n,a[N];int sum1[N],sum2[N];void change(int x,int y)&#123; for (int i=x;i&lt;=n;i+=(i&amp;-i))&#123; sum1[i]+=y; sum2[i]+=y*(x-1); &#125;&#125;void range_change(int l,int r,int y)&#123; change(l,y); change(r+1,-y);&#125;int query(int x)&#123; int res=0; for (int i=x;i&gt;=1;i-=(i&amp;-i)) res+=x*sum1[i]-sum2[i]; return res;&#125;int range_query(int l,int r)&#123; return query(r)-query(l-1);&#125; int main()&#123; for (int i=1;i&lt;=n;i++) change(i,a[i]-a[i-1]); //[l,r] +x range_change(l,r,x); //sum(l,r) range_query(l,r) return 0;&#125; 2.2 线段树（ 区间加，区间求和） 没必要 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#define ls ((now)&lt;&lt;1)//左儿子 #define rs ((now)&lt;&lt;1|1)//右儿子 using namespace std;const int MAXN=110000;typedef long long ll;int n,m;ll a[MAXN];//n-&gt;区间长度，m-&gt;询问个数，a-&gt;区间初始值 struct node&#123; ll val,add;//线段树的值，加法标记 &#125; tree[MAXN&lt;&lt;2];void pushup(int now)&#123;//上传标记 tree[now].val=tree[ls].val+tree[rs].val; &#125;void pushdown(int now,int l,int r)&#123;//下传标记 int mid=(l+r)&gt;&gt;1; //更新实际值 tree[ls].val+=tree[now].add*(mid-l+1); tree[rs].val+=tree[now].add*(r-mid); //下传加法标记 tree[ls].add+=tree[now].add; tree[rs].add+=tree[now].add; //清空当前标记 tree[now].add=0;&#125;void buildtree(int now,int l,int r)&#123;//建树 //零标记 tree[now].add=0; if (l==r)&#123; tree[now].val=a[l];//初始化 return; &#125; int mid=(l+r)&gt;&gt;1; buildtree(ls,l,mid); buildtree(rs,mid+1,r);//建子树 pushup(now);//上传更新 &#125;void change(int now,int l,int r,int x,int y,ll k)&#123; if (l&gt;r||x&gt;y) return; if (l==x&amp;&amp;r==y)&#123; tree[now].add+=k;//更新加法标记 tree[now].val+=k*(r-l+1);//更新值 return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(now,l,r);//先下传 if (y&lt;=mid) change(ls,l,mid,x,y,k);//更新左子树 else if (x&gt;mid) change(rs,mid+1,r,x,y,k);//更新右子树 else change(ls,l,mid,x,mid,k),change(rs,mid+1,r,mid+1,y,k);//更新左右子树 pushup(now);//上传标记 &#125;ll query(int now,int l,int r,int x,int y)&#123; if (l&gt;r||x&gt;y) return 0; if (l==x&amp;&amp;r==y) return tree[now].val;//返回实际值 int mid=(l+r)&gt;&gt;1; pushdown(now,l,r);//先下传 if (y&lt;=mid) return query(ls,l,mid,x,y);//询问左子树 else if (x&gt;mid) return query(rs,mid+1,r,x,y);//询问右子树 else return query(ls,l,mid,x,mid)+query(rs,mid+1,r,mid+1,y);//将左右子树的询问答案相加 pushup(now);//上传标记 &#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);//读入初始值 int op,x,y; ll k; buildtree(1,1,n);//建树 while (m--)&#123; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;x,&amp;y); if (op==1)&#123;//1代表加 scanf(&quot;%lld&quot;,&amp;k); change(1,1,n,x,y,k); &#125; else printf(&quot;%lld\\n&quot;,query(1,1,n,x,y));//其它数代表询问 &#125; return 0;&#125; 2.3 splay todo？？？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int INF=1e9;int n,m,op,x,a[110000];int root,sz,tag[110000],ch[110000][2],f[110000],cnt[110000],key[110000],size[110000];inline void clear(int x)&#123; ch[x][0]=ch[x][1]=f[x]=cnt[x]=key[x]=size[x]=0;&#125;inline int get(int x)&#123; return ch[f[x]][1]==x;&#125;inline void update(int x)&#123; if (x)&#123; size[x]=cnt[x]; if (ch[x][0]) size[x]+=size[ch[x][0]]; if (ch[x][1]) size[x]+=size[ch[x][1]]; &#125;&#125;inline void pushdown(int x)&#123; if (x&amp;&amp;tag[x])&#123; tag[ch[x][0]]^=1; tag[ch[x][1]]^=1; swap(ch[x][0],ch[x][1]); tag[x]=0; &#125;&#125;inline void rotate(int x)&#123; pushdown(f[x]); pushdown(x); int fa=f[x],gfa=f[fa],dir=get(x); ch[fa][dir]=ch[x][dir^1]; f[ch[fa][dir]]=fa; f[fa]=x; ch[x][dir^1]=fa; f[x]=gfa; if (gfa) ch[gfa][ch[gfa][1]==fa]=x; update(fa); update(x);&#125;void splay(int x,int goal=0)&#123; for (int fa;(fa=f[x])!=goal;rotate(x)) if (f[fa]!=goal) rotate((get(x)==get(fa))?fa:x); if (!goal) root=x;&#125;inline int build(int l,int r,int fa)&#123; if (l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; int now=++sz; key[now]=a[mid]; f[now]=fa; cnt[now]=1; tag[now]=0; ch[now][0]=build(l,mid-1,now); ch[now][1]=build(mid+1,r,now); update(now); return now;&#125;inline void insert(int v)&#123; if (!root)&#123; root=++sz; ch[sz][0]=ch[sz][1]=f[sz]=0; key[sz]=v; cnt[sz]=size[sz]=1; return; &#125; int now=root,fa=0; while (true)&#123; if (key[now]==v)&#123; cnt[now]++; update(now); update(fa); splay(now); break; &#125; fa=now; now=ch[now][key[now]&lt;v]; if (!now)&#123; sz++; ch[sz][0]=ch[sz][1]=0; key[sz]=v; size[sz]=1; cnt[sz]=1; f[sz]=fa; ch[fa][key[fa]&lt;v]=sz; update(fa); splay(sz); break; &#125; &#125;&#125;inline int Rank(int v)&#123; int ans=0,now=root; while (true)&#123; if (v&lt;key[now]) now=ch[now][0]; else&#123; ans+=(ch[now][0]?size[ch[now][0]]:0); if (v==key[now])&#123; splay(now); return ans+1; &#125; ans+=cnt[now]; now=ch[now][1]; &#125; &#125;&#125;inline int find(int x)&#123; int now=root; while (true)&#123; pushdown(now); if (ch[now][0]&amp;&amp;x&lt;=size[ch[now][0]]) now=ch[now][0]; else&#123; int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now]; if (x&lt;=temp) return now;//key[now]; x-=temp; now=ch[now][1]; &#125; &#125;&#125;inline int pre()&#123; int now=ch[root][0]; while (ch[now][1]) now=ch[now][1]; return now;&#125; inline int next()&#123; int now=ch[root][1]; while (ch[now][0]) now=ch[now][0]; return now;&#125;inline void del(int x)&#123; Rank(x); if (cnt[root]&gt;1)&#123; cnt[root]--; update(root); return; &#125; if (!ch[root][0]&amp;&amp;!ch[root][1])&#123; clear(root); root=0; return; &#125; if (!ch[root][0])&#123; int oldroot=root; root=ch[root][1]; f[root]=0; clear(oldroot); return; &#125; else if (!ch[root][1])&#123; int oldroot=root; root=ch[root][0]; f[root]=0; clear(oldroot); return; &#125; int leftbig=pre(),oldroot=root; splay(leftbig); f[ch[oldroot][1]]=root; ch[root][1]=ch[oldroot][1]; clear(oldroot); update(root); return;&#125;inline void print(int now)&#123; pushdown(now); if (ch[now][0]) print(ch[now][0]); if (key[now]!=-INF&amp;&amp;key[now]!=INF) printf(&quot;%d &quot;,key[now]); if (ch[now][1]) print(ch[now][1]);&#125;void reverse(int x,int y)&#123;//翻转[x,y] int a=find(x); int b=find(y+2); splay(a); splay(b,a); tag[ch[ch[root][1]][0]]^=1;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); insert(-INF); insert(INF); for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d%d&quot;,&amp;op,&amp;x); switch (op)&#123; case 1: insert(x); break; case 2: del(x); break; case 3: printf(&quot;%d\\n&quot;,Rank(x)-1); break; case 4: printf(&quot;%d\\n&quot;,key[find(x+1)]); break; case 5: insert(x); printf(&quot;%d\\n&quot;,key[pre()]); del(x); break; case 6: insert(x); printf(&quot;%d\\n&quot;,key[next()]); del(x); break; &#125; &#125; return 0;&#125; 2.4 左偏树 敲过了1234567891011121314struct pq&#123; int v[110000]; int l[110000],r[110000],d[110000]; int merge(int x,int y)&#123; if (!x||!y) return x|y; if (v[x]&lt;v[y]) swap(x,y); r[x]=merge(r[x],y); if (d[r[x]]&gt;d[l[x]]) swap(l[x],r[x]); d[x]=d[r[x]]+1; return x; &#125; void pop(int &amp;x)&#123; x=merge(l[x],r[x]);&#125; int top(int x)&#123; return v[x];&#125;&#125; que; 2.5 LCT（Link-Cut Tree） 这部分代码敲了好几遍了，易错点 把fa[x]和f[x]混起来写。。。 access中加注释的地方写成nroot(x)。 link的时候写成f[y]=x。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;algorithm&gt; #define ls c[x][0]#define rs c[x][1]using namespace std;int n,m,type,x,y,f[310000],c[310000][2],v[310000],s[310000],st[310000];bool r[310000];inline bool nroot(int x)&#123; return x==c[f[x]][0]||x==c[f[x]][1];&#125;inline void pushup(int x)&#123; s[x]=s[ls]^s[rs]^v[x];&#125;inline void pushr(int x)&#123; swap(ls,rs); r[x]^=1;&#125;inline void pushdown(int x)&#123; if (r[x])&#123; if (ls) pushr(ls); if (rs) pushr(rs); r[x]=0; &#125;&#125;inline int dir(int x)&#123; return c[f[x]][1]==x;&#125;void rotate(int x)&#123; int y=f[x],z=f[y],k=dir(x),w=c[x][!k]; if (nroot(y)) c[z][dir(y)]=x; c[x][!k]=y; c[y][k]=w; if (w) f[w]=y; f[y]=x; f[x]=z; pushup(y);&#125;void splay(int x)&#123; int y=x,z=0; st[++z]=y; while (nroot(y)) st[++z]=y=f[y]; while (z) pushdown(st[z--]); while (nroot(x))&#123; y=f[x]; if (nroot(y)) rotate(dir(x)!=dir(y)?x:y); rotate(x); &#125; pushup(x);&#125;void access(int x)&#123; for (int y=0;x;y=x,x=f[y])&#123;//注意此处，x是打通到整棵树的根的路径，所以是;x;而不是;nroot(x);。 splay(x); rs=y; pushup(x); &#125; &#125;inline void makeroot(int x)&#123; access(x); splay(x); pushr(x);&#125;int findroot(int x)&#123; access(x); splay(x); while (ls)&#123; pushdown(x); x=ls; &#125; splay(x); return x;&#125;inline void split(int x,int y)&#123; makeroot(x); access(y); splay(y);&#125;void link(int x,int y)&#123; makeroot(x); if (findroot(y)!=x) f[x]=y;&#125;void cut(int x,int y)&#123; makeroot(x); if (findroot(y)==x&amp;&amp;f[y]==x&amp;&amp;!c[y][0])&#123; f[y]=0; c[x][1]=0; pushup(x); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;v[i]); while (m--)&#123; scanf(&quot;%d%d%d&quot;,&amp;type,&amp;x,&amp;y); switch (type)&#123; case 0: split(x,y); printf(&quot;%d\\n&quot;,s[y]); break; case 1: link(x,y); break; case 2: cut(x,y); break; case 3: splay(x); v[x]=y; break; &#125; &#125; return 0;&#125; 2.6 虚树 背完了 现在改为luogu2495的某篇题解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;#define il inline#define re register#define debug printf(&quot;Now is Line : %d\\n&quot;,__LINE__)#define file(a) freopen(#a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(#a&quot;.out&quot;,&quot;w&quot;,stdout)#define int long long#define inf 123456789000000000#define mod 1000000007il int read()&#123; re int x = 0, f = 1; re char c = getchar(); while(c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; if(c == &#x27;-&#x27;) f = -1; c = getchar();&#125; while(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - 48, c = getchar(); return x * f;&#125;#define maxn 250005struct edge&#123; int v, w, next;&#125;e[maxn &lt;&lt; 1];int n, m, head[maxn], cnt, is[maxn], mi[maxn], dfn[maxn], col, t;int size[maxn], fa[maxn], top[maxn], son[maxn], dep[maxn], s[maxn];vector&lt;int&gt;v[maxn];il void add(int u, int v, int w)&#123; e[++ cnt] = (edge)&#123;v, w, head[u]&#125;; head[u] = cnt;&#125;il bool cmp(int a, int b)&#123;return dfn[a] &lt; dfn[b];&#125;il void dfs1(int u, int fr)&#123; size[u] = 1, fa[u] = fr, dep[u] = dep[fr] + 1; for(re int i = head[u]; i; i = e[i].next) &#123; int v = e[i].v; if(v == fr) continue; mi[v] = min(mi[u], e[i].w); dfs1(v, u), size[u] += size[v]; if(size[son[u]] &lt; size[v]) son[u] = v; &#125;&#125;il void dfs2(int u, int fr)&#123; top[u] = fr, dfn[u] = ++ col; if(!son[u]) return; dfs2(son[u], fr); for(re int i = head[u]; i; i = e[i].next) &#123; int v = e[i].v; if(v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v); &#125;&#125;il int lca(int a, int b)&#123; while(top[a] != top[b]) dep[top[a]] &gt; dep[top[b]] ? a = fa[top[a]] : b = fa[top[b]]; return dep[a] &lt; dep[b] ? a : b;&#125;il void push(int x)&#123; if(t == 1) &#123;s[++ t] = x;return;&#125; int l = lca(x, s[t]); if(l == s[t]) return; while(t &gt; 1 &amp;&amp; dfn[s[t - 1]] &gt;= dfn[l]) v[s[t - 1]].push_back(s[t]), --t; if(s[t] != l) v[l].push_back(s[t]), s[t] = l; s[++ t] = x;&#125;il int dp(int u)&#123; if(v[u].size() == 0) return mi[u]; int temp = 0; for(re int i = 0; i &lt; v[u].size(); ++ i) temp += dp(v[u][i]); v[u].clear(); return min(mi[u], temp);&#125;signed main()&#123; file(a); n = read(); for(re int i = 1; i &lt; n; ++ i) &#123; int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w); &#125; mi[1] = inf, dfs1(1, 0), dfs2(1, 1); int T = read(); while(T --) &#123; m = read(); for(re int i = 1; i &lt;= m; ++ i) is[i] = read(); sort(is + 1, is + m + 1, cmp); s[t = 1] = 1; for(re int i = 1; i &lt;= m; ++ i) push(is[i]); while(t &gt; 0) v[s[t - 1]].push_back(s[t]), --t; printf(&quot;%lld\\n&quot;, dp(1)); &#125; return 0;&#125; 3.网络流&amp;图论3.1 最大流（ISAP）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int INF=0x3f3f3f3f;int n,m,s,t,gap[11000],cur[11000],d[11000],que[11000];int edgenum,vet[210000],val[210000],Next[210000],Head[11000];void addedge(int u,int v,int cost)&#123; vet[++edgenum]=v; val[edgenum]=cost; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void bfs()&#123; memset(gap,0,sizeof(gap)); memset(d,0,sizeof(d)); d[t]=1; gap[1]++; int head=1,tail=1; que[1]=t; while (head&lt;=tail)&#123; int u=que[head++]; for (int e=Head[u];e;e=Next[e]) if (!d[vet[e]])&#123; d[vet[e]]=d[u]+1; gap[d[vet[e]]]++; que[++tail]=vet[e]; &#125; &#125;&#125;int dfs(int u,int flow)&#123; if (u==t) return flow; int used=0; for (int &amp;e=cur[u];e;e=Next[e]) if (d[u]==d[vet[e]]+1)&#123; int tmp=dfs(vet[e],min(flow,val[e])); used+=tmp; flow-=tmp; val[e]-=tmp; val[e^1]+=tmp; if (!flow) return used; &#125; if (!(--gap[d[u]])) d[s]=n+1; d[u]++; gap[d[u]]++; cur[u]=Head[u]; return used;&#125;int maxflow()&#123; bfs(); for (int i=1;i&lt;=n;i++) cur[i]=Head[i]; int ans=dfs(s,INF); while (d[s]&lt;=n) ans+=dfs(s,INF); return ans;&#125;int main()&#123; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); int u,v,cost; edgenum=1; for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;cost); addedge(u,v,cost); addedge(v,u,0); &#125; printf(&quot;%d\\n&quot;,maxflow()); return 0;&#125; 3.2 最大流（dinic） 背过了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int INF=0x3f3f3f3f;int n,m,s,t,maxflow;int vis[11000];//是否到达过该点 int dep[11000]; int edgenum=1,F[210000],V[210000],Next[210000],Head[11000];//f:最大流量（flow），w:单位费用 void addedge(int u,int v,int f)&#123; V[++edgenum]=v; F[edgenum]=f; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void Add(int u,int v,int f)&#123; addedge(u,v,f); addedge(v,u,0);&#125;bool bfs()&#123; memset(vis,false,sizeof(vis)); memset(dep,0x3f,sizeof(dep)); dep[s]=0; vis[s]=true; queue&lt;int&gt; que; que.push(s); while (!que.empty())&#123; int u=que.front(); que.pop(); vis[u]=false; for (int e=Head[u];e;e=Next[e])&#123; int d=V[e]; if (dep[d]&gt;dep[u]+1&amp;&amp;F[e])&#123; dep[d]=dep[u]+1; if (!vis[d])&#123; que.push(d); vis[d]=true; &#125; &#125; &#125; &#125; return dep[t]&lt;INF;&#125;int dfs(int u,int flow)&#123; if (u==t)&#123; vis[t]=true; maxflow+=flow; return flow; &#125; int used=0; vis[u]=true; for (int e=Head[u];e;e=Next[e])&#123; int d=V[e]; if ((!vis[d]||d==t)&amp;&amp;F[e]&amp;&amp;dep[d]==dep[u]+1)&#123; int minflow=dfs(d,min(flow-used,F[e])); if (minflow!=0) F[e]-=minflow,F[e^1]+=minflow,used+=minflow; if (used==flow) break; &#125; &#125; return used;&#125;int dinic()&#123; while (bfs())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,false,sizeof(vis)); dfs(s,INF); &#125; &#125; return maxflow;&#125;int main()&#123; n=read(),m=read(),s=read(),t=read(); int u,v,f; for (register int i=1;i&lt;=m;i++)&#123; u=read(),v=read(),f=read(); Add(u,v,f); &#125; dinic(); printf(&quot;%d\\n&quot;,maxflow); return 0;&#125; 3.3 最小费用最大流（dinic） 背过了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int INF=0x3f3f3f3f;int n,m,s,t;int ans,maxflow;int vis[5100];//是否到达过该点 int dist[5100]; int edgenum=1,F[110000],V[110000],Next[110000],W[110000],Head[5100];//f:最大流量（flow），w:单位费用 void addedge(int u,int v,int f,int w)&#123; V[++edgenum]=v; W[edgenum]=w; F[edgenum]=f; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void Add(int u,int v,int f,int w)&#123; addedge(u,v,f,w); addedge(v,u,0,-w);&#125;bool spfa()&#123; memset(vis,false,sizeof(vis)); memset(dist,0x3f,sizeof(dist)); dist[s]=0; vis[s]=true; queue&lt;int&gt; que; que.push(s); while (!que.empty())&#123; int u=que.front(); que.pop(); vis[u]=false; for (int e=Head[u];e;e=Next[e])&#123; int d=V[e]; if (dist[d]&gt;dist[u]+W[e]&amp;&amp;F[e])&#123; dist[d]=dist[u]+W[e]; if (!vis[d])&#123; que.push(d); vis[d]=true; &#125; &#125; &#125; &#125; return dist[t]&lt;INF;&#125;int dfs(int u,int flow)&#123; if (u==t)&#123; vis[t]=true; maxflow+=flow; return flow; &#125; int used=0; vis[u]=true; for (int e=Head[u];e;e=Next[e])&#123; int d=V[e]; if ((!vis[d]||d==t)&amp;&amp;F[e]&amp;&amp;dist[d]==dist[u]+W[e])&#123; int minflow=dfs(d,min(flow-used,F[e])); if (minflow!=0) ans+=W[e]*minflow,F[e]-=minflow,F[e^1]+=minflow,used+=minflow; if (used==flow) break; &#125; &#125; return used;&#125;int mincostmaxflow()&#123; while (spfa())&#123; vis[t]=1; while (vis[t])&#123; memset(vis,false,sizeof(vis)); dfs(s,INF); &#125; &#125; return maxflow;&#125;int main()&#123; n=read(),m=read(),s=read(),t=read(); int u,v,f,w; for (register int i=1;i&lt;=m;i++)&#123; u=read(),v=read(),f=read(),w=read(); Add(u,v,f,w); &#125; mincostmaxflow(); printf(&quot;%d %d\\n&quot;,maxflow,ans); return 0;&#125; 3.4 无向图Tarjan算法&amp;欧拉回路 敲了一遍，注意!的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// tarjan算法求无向图的桥、边双连通分量并缩点#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int SIZE = 100010;int head[SIZE], ver[SIZE * 2], Next[SIZE * 2];int dfn[SIZE], low[SIZE], c[SIZE];int n, m, tot, num, dcc, tc;bool bridge[SIZE * 2];int hc[SIZE], vc[SIZE * 2], nc[SIZE * 2];void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot;&#125;void add_c(int x, int y) &#123; vc[++tc] = y, nc[tc] = hc[x], hc[x] = tc;&#125;void tarjan(int x, int in_edge) &#123; dfn[x] = low[x] = ++num; for (int i = head[x]; i; i = Next[i]) &#123; int y = ver[i]; if (!dfn[y]) &#123; tarjan(y, i); low[x] = min(low[x], low[y]); if (low[y] &gt; dfn[x]) bridge[i] = bridge[i ^ 1] = true; &#125; else if (i != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); &#125;&#125;void dfs(int x) &#123; c[x] = dcc; for (int i = head[x]; i; i = Next[i]) &#123; int y = ver[i]; if (c[y] || bridge[i]) continue; dfs(y); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; tot = 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y), add(y, x); &#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, 0); for (int i = 2; i &lt; tot; i += 2) if (bridge[i]) printf(&quot;%d %d\\n&quot;, ver[i ^ 1], ver[i]); for (int i = 1; i &lt;= n; i++) if (!c[i]) &#123; ++dcc; dfs(i); &#125; printf(&quot;There are %d e-DCCs.\\n&quot;, dcc); for (int i = 1; i &lt;= n; i++) printf(&quot;%d belongs to DCC %d.\\n&quot;, i, c[i]); tc = 1; for (int i = 2; i &lt;= tot; i++) &#123; int x = ver[i ^ 1], y = ver[i]; if (c[x] == c[y]) continue; add_c(c[x], c[y]); &#125; printf(&quot;缩点之后的森林，点数 %d，边数 %d\\n&quot;, dcc, tc / 2); for (int i = 2; i &lt; tc; i += 2) printf(&quot;%d %d\\n&quot;, vc[i ^ 1], vc[i]);&#125;// tarjan算法求无向图的割点、点双连通分量并缩点#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int SIZE = 100010;int head[SIZE], ver[SIZE * 2], Next[SIZE * 2];int dfn[SIZE], low[SIZE], stack[SIZE], new_id[SIZE], c[SIZE];int n, m, tot, num, root, top, cnt, tc;bool cut[SIZE];vector&lt;int&gt; dcc[SIZE];int hc[SIZE], vc[SIZE * 2], nc[SIZE * 2];void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot;&#125;void add_c(int x, int y) &#123; vc[++tc] = y, nc[tc] = hc[x], hc[x] = tc;&#125;void tarjan(int x) &#123; dfn[x] = low[x] = ++num; stack[++top] = x; if (x == root &amp;&amp; head[x] == 0) &#123; // 孤立点 !!!!!!!!!!!!!!!!!!!!!! dcc[++cnt].push_back(x); return; &#125; int flag = 0; for (int i = head[x]; i; i = Next[i]) &#123; int y = ver[i]; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (low[y] &gt;= dfn[x]) &#123; flag++; if (x != root || flag &gt; 1) cut[x] = true; cnt++; int z; do &#123; z = stack[top--]; dcc[cnt].push_back(z); &#125; while (z != y); dcc[cnt].push_back(x); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; tot = 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (x == y) continue; add(x, y), add(y, x); &#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) root = i, tarjan(i); for (int i = 1; i &lt;= n; i++) if (cut[i]) printf(&quot;%d &quot;, i); puts(&quot;are cut-vertexes&quot;); for (int i = 1; i &lt;= cnt; i++) &#123; printf(&quot;v-DCC #%d:&quot;, i); for (int j = 0; j &lt; dcc[i].size(); j++) printf(&quot; %d&quot;, dcc[i][j]); puts(&quot;&quot;); &#125; // 给每个割点一个新的编号(编号从cnt+1开始) num = cnt; for (int i = 1; i &lt;= n; i++) if (cut[i]) new_id[i] = ++num; // 建新图，从每个v-DCC到它包含的所有割点连边 tc = 1; for (int i = 1; i &lt;= cnt; i++) for (int j = 0; j &lt; dcc[i].size(); j++) &#123; int x = dcc[i][j]; if (cut[x]) &#123; add_c(i, new_id[x]); add_c(new_id[x], i); &#125; else c[x] = i; // 除割点外，其它点仅属于1个v-DCC &#125; printf(&quot;缩点之后的森林，点数 %d，边数 %d\\n&quot;, num, tc / 2); printf(&quot;编号 1~%d 的为原图的v-DCC，编号 &gt;%d 的为原图割点\\n&quot;, cnt, cnt); for (int i = 2; i &lt; tc; i += 2) printf(&quot;%d %d\\n&quot;, vc[i ^ 1], vc[i]);&#125;// 求出欧拉图中的一条欧拉回路#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int head[100010], ver[1000010], Next[1000010], tot; // 邻接表int stack[1000010], ans[1000010]; // 模拟系统栈，答案栈bool vis[1000010];int n, m, top, t;void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot;&#125;void euler() &#123; stack[++top] = 1; while (top &gt; 0) &#123; int x = stack[top], i = head[x]; // 找到一条尚未访问的边 while (i &amp;&amp; vis[i]) i = Next[i]; // 沿着这条边模拟递归过程，标记该边，并更新表头 if (i) &#123; stack[++top] = ver[i]; head[x] = Next[i]; vis[i] = vis[i ^ 1] = true; &#125; // 与x相连的所有边均已访问，模拟回溯过程，并记录于答案栈中 else &#123; top--; ans[++t] = x; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; tot = 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y), add(y, x); &#125; euler(); for (int i = t; i; i--) printf(&quot;%d\\n&quot;, ans[i]);&#125; 3.5 有向图Tarjan算法（强连通分量） 敲了一遍，注意!的部分 12345678910111213141516171819202122232425262728void tarjan(int u)&#123; int v; dfn[u]=low[u]=++idx;//每次dfs，u的次序号增加1 s.push(u);//将u入栈 ins[u]=1;//标记u在栈内 for(int i=head[u];i!=-1;i=e[i].next)//访问从u出发的边 &#123; v=e[i].v; if(!dfn[v])//如果v没被处理过 &#123; tarjan(v);//dfs(v) low[u]=min(low[u],low[v]);//u点能到达的最小次序号是它自己能到达点的最小次序号和连接点v能到达点的最小次序号中较小的 &#125; else if(ins[v])low[u]=min(low[u],dfn[v]);//如果v在栈内，u点能到达的最小次序号是它自己能到达点的最小次序号和v的次序号中较小的 &#125; if(dfn[u]==low[u])//!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &#123; Bcnt++; do &#123; v=s.top(); s.pop(); ins[v]=0; Belong[v]=Bcnt; &#125;while(u != v); &#125;&#125; 3.6 二分图匹配（匈牙利算法） 敲了一遍 12345678910111213141516bool dfs(int x) &#123; for (int i = head[x], y; i; i = next[i]) if (!visit[y = ver[i]]) &#123; visit[y] = 1; if (!match[y] || dfs(match[y])) &#123; match[y]=x; return true; &#125; &#125; return false;&#125;for (int i = 1; i &lt;= n; i++) &#123; memset(visit, 0, sizeof(visit)); if (dfs(i)) ans++;&#125; 4. 矩阵&amp;多项式4.1 多项式基础模板1234567891011121314151617181920212223242526272829303132333435363738394041424344struct poly&#123; vector&lt;int&gt; v; poly()&#123; v.clear();&#125; inline int size()&#123; return v.size();&#125; friend poly operator+(poly A,poly B)&#123; int lenA=A.v.size()-1,lenB=B.v.size()-1; int len=max(lenA,lenB); A.v.resize(len+1); B.v.resize(len+1); poly C; C.v.resize(len+1); for (int i=0;i&lt;=len;i++) C.v[i]=add(A.v[i],B.v[i]); return C; &#125; friend poly operator*(poly A,int v)&#123; for (int i=0;i&lt;A.size();i++) A.v[i]=mul(A.v[i],v); return A; &#125; friend poly operator*(const poly &amp;A,const poly &amp;B)&#123; int len=A.v.size()+B.v.size()-2; poly C; C.v.resize(len+1); for (int i=0;i&lt;(int)A.v.size();i++) for (int j=0;j&lt;(int)B.v.size();j++) C.v[i+j]=add(C.v[i+j],mul(A.v[i],B.v[j])); return C; &#125; friend poly operator%(poly A,const poly &amp;B)&#123; int lenA=(int)A.v.size()-1,lenB=(int)B.v.size()-1; int inv=getinv(B.v[lenB]); if (lenA&lt;lenB) return A; for (int i=lenA;i&gt;=lenB;i--) if (A.v[i])&#123; int t=mul(A.v[i],inv); for (int j=i;j&gt;=i-lenB;j--) A.v[j]=dec(A.v[j],mul(t,B.v[lenB-i+j])); &#125; A.v.resize(lenB+1); return A; &#125;&#125;;poly qpow(poly x,char *a,const poly &amp;M)&#123;//a为二进制数 poly res; res.v.clear(); res.v.push_back(1); for (int i=strlen(a)-1;i&gt;=0;i--)&#123; if (a[i]==&#x27;1&#x27;) res=(res*x)%M; x=(x*x)%M; &#125; return res;&#125; 4.2 FWT :star: 背过一遍 123456789101112131415161718192021222324252627282930// 均类似于FFT/NTT的三重循环。// Or卷积，正变换是大的+小的，逆变换是大的-小的。（两个数Or起来会变大）。// And卷积，正变换是小的+大的，逆变换是小的-大的。（两个数And起来会变小）。// Xor卷积，正变换和FFT/NTT一样，小的=(X+Y)，大的=(X-Y)。逆变换把结果都/2。void FWT_or(int *a,int op)&#123; for (int i=1;i&lt;N;i&lt;&lt;=1) for (int p=i&lt;&lt;1,j=0;j&lt;N;j+=p) for (int k=0;k&lt;i;++k) if (op==1) a[i+j+k]=(a[j+k]+a[i+j+k])%Mod; else a[i+j+k]=(a[i+j+k]+Mod-a[j+k])%Mod;&#125;void FWT_and(int *a,int op)&#123; for (int i=1;i&lt;N;i&lt;&lt;=1) for (int p=i&lt;&lt;1,j=0;j&lt;N;j+=p) for (int k=0;k&lt;i;++k) if (op==1) a[j+k]=(a[j+k]+a[i+j+k])%Mod; else a[j+k]=(a[j+k]+Mod-a[i+j+k])%Mod;&#125;void FWT_xor(int *a,int op)&#123; for (int i=1;i&lt;N;i&lt;&lt;=1) for (int p=i&lt;&lt;1,j=0;j&lt;N;j+=p) for (int k=0;k&lt;i;k++)&#123; int X=a[j+k],Y=a[i+j+k]; a[j+k]=(X+Y)%Mod; a[i+j+k]=(X+Mod-Y)%Mod; if (op==-1)&#123; a[j+k]=1ll*a[j+k]*inv2%Mod; a[i+j+k]=1ll*a[i+j+k]*inv2%Mod;//inv2为2的逆元 &#125; &#125;&#125; 4.3 FFT:star2: 敲过了 首先，重要的一点是rev[x]=(rev[x&gt;&gt;1]&gt;&gt;1)|((x&amp;1)&lt;&lt;(bit-1))。相当于把它的最后一个位置删去，然后反过来，此时所有位置都往左移了一位，那么右移一位，最后把最后一个位置的数放在最高位。 然后，将原序列x&lt;rev[x]的位置，交换x,rev[x]。（否则会交换两次，相当于没交换）。 考虑正变换 枚举mid，表示当前长度的一半。此时，$\\omega=\\cos \\frac{2\\pi}{2mid}+sin\\frac{2\\pi}{2mid}=\\cos\\frac{\\pi}{mid}+sin \\frac{\\pi}{mid}$。 然后枚举起始位置$i$，必须是 $2mid$ 的倍数。 初始时，$w=1$，然后，枚举段中的位置 $j$ ，则 $i+j$ 为左边段的真实位置，$i+j+mid$ 是右边段的真实位置。 $a[i+j]=(X+Y),a[i+j+mid]=w(X-Y)$，最后$w=\\omega$。 接着考虑逆变换，其实就是改变了$\\omega$，此时$\\omega=cos \\frac{\\pi}{mid}-i\\sin\\frac{\\pi}{mid}$。最后要把每个数都/n。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1e7+10;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;const double Pi=acos(-1.0);struct complex&#123; double x,y; complex (double xx=0,double yy=0)&#123; x=xx; y=yy;&#125;&#125; a[MAXN],b[MAXN];complex operator+(complex a,complex b)&#123; return complex(a.x+b.x,a.y+b.y);&#125;complex operator-(complex a,complex b)&#123; return complex(a.x-b.x,a.y-b.y);&#125;complex operator*(complex a,complex b)&#123; return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125; int N,M;int l,r[MAXN];int len=1;void FFT(complex *A,int type)&#123; for (int i=0;i&lt;len;i++) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; complex Wn(cos(Pi/mid),type*sin(Pi/mid)); for (int R=mid&lt;&lt;1,j=0;j&lt;len;j+=R)&#123; complex w(1,0); for (int k=0;k&lt;mid;k++,w=w*Wn)&#123; complex x=A[j+k],y=w*A[j+mid+k]; A[j+k]=x+y; A[j+mid+k]=x-y; &#125; &#125; &#125;&#125;int main()&#123; int N=read(),M=read(); for (int i=0;i&lt;=N;i++) a[i].x=read(); for (int i=0;i&lt;=M;i++) b[i].x=read(); while (len&lt;=N+M) len&lt;&lt;=1,l++; for (int i=0;i&lt;len;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); FFT(a,1); FFT(b,1); for (int i=0;i&lt;=len;i++) a[i]=a[i]*b[i]; FFT(a,-1); for (int i=0;i&lt;=N+M;i++) printf(&quot;%d &quot;,(int)(a[i].x/len+0.5)); return 0;&#125; 4.4 NTT:star2: 敲过了 正变换：改变了FFT中的$\\omega$，此时$\\omega=g^\\dfrac{\\varphi(Mod)}{mid2}=g^\\dfrac{Mod-1}{mid2}$。 逆变换：改变了FFT中的$\\omega$，此时$\\omega=\\dfrac1{g^\\dfrac{\\varphi(Mod)}{mid2}}=\\dfrac 1{g^\\dfrac{Mod-1}{mid2}}$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int g=3;const int Mod=998244353;const int MAXN=2100000;//&gt;n+m上取到2的幂次 int n,m,len,rev[MAXN];ll a[MAXN],b[MAXN],c[MAXN];inline ll qpow(ll x,int a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline int getinv(int x)&#123; return qpow(x,Mod-2);&#125;void NTT(ll *a,int inv)&#123; for (int i=0;i&lt;n;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;n;mid&lt;&lt;=1)&#123; int tmp=qpow(g,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;n;i+=mid*2)&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=omega*tmp%Mod)&#123; int x=a[i+j],y=omega*a[i+j+mid]%Mod; a[i+j]=(x+y)%Mod,a[i+j+mid]=(x-y+Mod)%Mod; &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); n++; m++; for (int i=0;i&lt;n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for (int i=0;i&lt;m;i++) scanf(&quot;%lld&quot;,&amp;b[i]); len=n+m-1; int bit=0; while ((1&lt;&lt;bit)&lt;len) bit++; n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,1); NTT(b,1); for (int i=0;i&lt;n;i++) a[i]=a[i]*b[i]%Mod; NTT(a,-1); ll inv=getinv(n); for (int i=0;i&lt;len;i++)&#123; c[i]=a[i]*inv%Mod; printf(&quot;%lld &quot;,c[i]); &#125; return 0;&#125; 4.5 多项式求逆:star: 背过一遍 就一个式子，将变换后的按位乘改为：$b[i]=(2-c[i]b[i])b[i]$。 1234567891011121314151617181920212223242526272829303132333435void polymul(vec &amp;a,vec &amp;b,vec &amp;c,int bit)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(n,a,1); NTT(n,b,1); for (int i=0;i&lt;n;i++) a[i]=a[i]*b[i]%Mod; NTT(n,a,-1); ll inv=getinv(n); c.resize(n); for (int i=0;i&lt;n;i++) c[i]=a[i]*inv%Mod; a.clear(); b.clear();&#125;void polyinv(int len,int bit,vec &amp;a,vec &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); vec c=a; c.resize(len); NTT(n,c,1); NTT(n,b,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(n,b,-1); b.resize(len); ll inv=getinv(n); for (int i=0;i&lt;len;i++) b[i]=b[i]*inv%Mod;&#125;int getbit(int x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(int n,vec &amp;a,vec &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125; 4.6 拉格朗日插值 背完了 $\\displaystyle f(x)=\\sum_{i=1}^n y_i\\prod_{i\\not= j} \\frac{x-x_j}{x_i-x_j} $ 1234567891011121314151617181920212223242526272829303132 scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);//求f(k) for (int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;x[i],&amp;y[i]);//f(x[i])=y[i] ll s1,s2,ans=0; for (int i=1;i&lt;=n;i++)&#123; s1=y[i]%Mod; s2=1ll; for (int j=1;j&lt;=n;j++) if (i!=j)&#123; s1=s1*(k-x[j])%Mod; s2=s2*(x[i]-x[j])%Mod; &#125; s1=(s1+Mod)%Mod; s2=(s2+Mod)%Mod; ans=(ans+s1*inv(s2))%Mod; &#125; printf(&quot;%lld\\n&quot;,ans); //1..nint Lagrange(int k)&#123; if (k&lt;=n) return f[k]; int res=0; for (int i=1;i&lt;=n;i++)&#123; int s=1; for (int j=0;j&lt;=n;j++)&#123; if (i==j) continue; s=1ll*s*((k-j)%Mod+Mod)%Mod; if (i&gt;j) s=1ll*s*inv[i-j]%Mod; else s=(Mod-1ll*s*inv[j-i]%Mod)%Mod; &#125; res=(res+1ll*f[i]*s%Mod)%Mod; &#125; return res;&#125; 4.7 下降幂多项式乘法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int Mod=998244353;const int G=3;int n,m,len;ll f[610000],g[610000],s[610000];ll fac[610000],invfac[610000];int rev[610000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;char readop()&#123; char ch=Getchar(); while (ch&lt;&#x27;A&#x27;||ch&gt;&#x27;Z&#x27;) ch=Getchar(); return ch;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;void NTT(ll *a,int inv)&#123; for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;n;i++) a[i]=mul(a[i],inv); &#125;&#125;void FDT(ll *f,int inv)&#123; if (inv==1) for (int i=0;i&lt;n;i++) s[i]=invfac[i]; else for (int i=0;i&lt;n;i++) if (i&amp;1) s[i]=Mod-invfac[i]; else s[i]=invfac[i]; for (int i=n;i&lt;len;i++) s[i]=0; NTT(f,1); NTT(s,1); for (int i=0;i&lt;len;i++) f[i]=mul(f[i],s[i]); NTT(f,-1); for (int i=n;i&lt;len;i++) f[i]=0;&#125;int main()&#123; n=read()+1; m=read()+1; for (int i=0;i&lt;n;i++) f[i]=read(); for (int i=0;i&lt;m;i++) g[i]=read(); n=n+m-1; int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); fac[0]=1; for (int i=1;i&lt;=len;i++) fac[i]=fac[i-1]*i%Mod; invfac[1]=1; for (int i=2;i&lt;=len;i++) invfac[i]=(Mod-Mod/i)*invfac[Mod%i]%Mod; invfac[0]=1; for (int i=1;i&lt;=len;i++) invfac[i]=invfac[i-1]*invfac[i]%Mod; FDT(f,1); FDT(g,1); for (int i=0;i&lt;n;i++) f[i]=mul(mul(f[i],g[i]),fac[i]); FDT(f,-1); for (int i=0;i&lt;n;i++) printf(&quot;%lld &quot;,f[i]); return 0;&#125; 4.8 多项式除法:star: 背过一遍 $A(x)/B(x)$ $A$的最高次项为 $x^n$，$B$ 的最高次项为 $x^m$。 把 $A,B$ 翻转，$B$ 的最高此项改为 $x^{n-m}$。 求出 $B$ 的逆，和 $A$ 乘起来，再取 $x^0…x^{n-m}$。再翻转 ，输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;//#define int long long#define ls (now&lt;&lt;1)#define rs (now&lt;&lt;1|1)using namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int Mod=998244353;const int G=3; const int invG=332748118;int n,m,a[310000],rev[310000],ans[310000];poly f,g;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp);// printf(&quot;%d &quot;,(Mod-1)/(mid&lt;&lt;1)); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(poly a,poly b,poly &amp;c,int n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;void polyinv(int len,int bit,poly &amp;a,poly &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len);&#125;int getbit(int x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(int n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125;poly c,d;poly getdiv(poly a,poly b)&#123; int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; d.resize(1); d[0]=0; return d; &#125; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); b.resize(n-m+1); c.clear(); getinv(n-m+1,b,c); d.clear(); mult(c,a,d,n+(n-m+1)); d.resize(n-m+1); reverse(d.begin(),d.end()); return d;&#125;poly ans1,tmp,ans2;void getmod(poly &amp;a,poly b,poly &amp;c)&#123; int n=a.size()-1,m=b.size()-1; if (n&lt;m) return; ans1=getdiv(a,b); mult(ans1,b,tmp,n+m); c.resize(m); for (int i=0;i&lt;m;i++) c[i]=dec(a[i],tmp[i]);&#125;int main()&#123;// freopen(&quot;P4512_4.in&quot;,&quot;r&quot;,stdin); n=read(); m=read(); f.resize(n+1); g.resize(m+1); for (int i=0;i&lt;=n;i++) f[i]=read(); for (int i=0;i&lt;=m;i++) g[i]=read(); getmod(f,g,ans2); ans1.resize(n-m); for (int i=0;i&lt;=n-m;i++) printf(&quot;%d &quot;,ans1[i]); putchar(&#x27;\\n&#x27;); for (int i=0;i&lt;m;i++) printf(&quot;%d &quot;,ans2[i]); return 0;&#125;/*5 115466465 9465465 2154654 64546 4546466 86644561545 75468*/ 4.9 多点求值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define ls (now&lt;&lt;1)#define rs (now&lt;&lt;1|1)using namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int Mod=998244353;const int G=3; const int invG=332748118;int n,m,a[310000],rev[310000],ans[310000];ll Inv[2100000],powG[2100000],powInvG[2100000];poly f;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(const int &amp;x)&#123; return qpow(x,Mod-2);&#125;void NTT(poly &amp;a,const int &amp;len,const int &amp;inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp; if (inv==1) tmp=powG[mid]; else tmp=powInvG[mid];// int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1));// if (inv==-1) tmp=getinv(tmp);// printf(&quot;%d &quot;,(Mod-1)/(mid&lt;&lt;1)); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=Inv[len]; for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;/*void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp);// printf(&quot;%d &quot;,(Mod-1)/(mid&lt;&lt;1)); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;*/void mult(poly a,poly b,poly &amp;c,const int &amp;n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;void polyinv(const int &amp;len,const int &amp;bit,poly &amp;a,poly &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len);&#125;inline int getbit(const int &amp;x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(const int &amp;n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125;poly c,d;poly getdiv(poly a,poly b)&#123; int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; d.resize(1); d[0]=0; return d; &#125; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); b.resize(n-m+1); c.clear(); getinv(n-m+1,b,c); d.clear(); mult(c,a,d,n+(n-m+1)); d.resize(n-m+1); reverse(d.begin(),d.end()); return d;&#125;poly ans1,tmp,ans2;void getmod(poly a,poly b,poly &amp;c)&#123; while (!b.empty()&amp;&amp;!b.back()) b.pop_back(); int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; c=a; return;&#125; ans1=getdiv(a,b); mult(ans1,b,tmp,n+m); c.resize(m); for (int i=0;i&lt;m;i++) c[i]=dec(a[i],tmp[i]);&#125;poly p[310000];void getpoly(const int &amp;now,const int &amp;l,const int &amp;r)&#123; if (l==r)&#123; p[now].push_back(dec(0,a[l])); p[now].push_back(1); return; &#125; int mid=(l+r)&gt;&gt;1; getpoly(ls,l,mid); getpoly(rs,mid+1,r); mult(p[ls],p[rs],p[now],r-l+2);&#125;void solve(const poly &amp;A,const int &amp;now,const int &amp;l,const int &amp;r)&#123; if (r-l&lt;=1000)&#123; for (int i=l;i&lt;=r;i++)&#123; int s=0; for (int j=A.size()-1;j&gt;=0;j--) s=add(mul(s,a[i]),A[j]); ans[i]=s; &#125; return; &#125; poly B; int mid=(l+r)&gt;&gt;1; getmod(A,p[ls],B); solve(B,ls,l,mid); getmod(A,p[rs],B); solve(B,rs,mid+1,r);&#125;int main()&#123; for (int mid=1;mid&lt;=2000000;mid&lt;&lt;=1)&#123; powG[mid]=qpow(G,(Mod-1)/(mid&lt;&lt;1)); powInvG[mid]=qpow(powG[mid],Mod-2); &#125; Inv[1]=1; for (int i=2;i&lt;=2000000;i++) Inv[i]=(Mod-Mod/i)*Inv[Mod%i]%Mod; n=read(); m=read(); f.resize(n+1); for (int i=0;i&lt;=n;i++) f[i]=read(); for (int i=1;i&lt;=m;i++) a[i]=read();// n=64000; m=64000; f.resize(n+1);// for (int i=0;i&lt;=n;i++) f[i]=1;// for (int i=1;i&lt;=m;i++) a[i]=i; getpoly(1,1,m); getmod(f,p[1],f); solve(f,1,1,m); for (int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0;&#125; 4.10 多项式ln/exp todo？？？？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef vector&lt;int&gt; poly;typedef long long ll;const int Mod=998244353;const int G=3;int n,m,a[310000],rev[310000],ans[310000];poly f,g;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(const int &amp;x)&#123; return qpow(x,Mod-2);&#125;void NTT(poly &amp;a,int len,int inv)&#123; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125; if (inv==-1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(poly a,poly b,poly &amp;c,const int &amp;n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;void polyinv(const int &amp;len,const int &amp;bit,poly &amp;a,poly &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len);&#125;inline int getbit(const int &amp;x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(const int &amp;n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125;void Dao(poly &amp;A,poly &amp;B,int len)&#123; for (int i=1;i&lt;len;i++) B[i-1]=1ll*i*A[i]%Mod; B[len-1]=0;&#125;void Jifen(poly &amp;A,poly &amp;B,int len)&#123; for (int i=1;i&lt;len;i++) B[i]=1ll*A[i-1]*getinv(i)%Mod; B[0]=0;&#125;poly A,B,C;void getln(poly &amp;f,poly &amp;g,int n)&#123; f.resize(n); g.resize(n); A.resize(n); B.resize(n); Dao(f,A,n); getinv(n,f,B); mult(A,B,C,n+n); Jifen(C,g,n);&#125;poly t;void getexp(const int &amp;n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=1; return; &#125; getexp(n&gt;&gt;1,a,b); getln(b,t,n); for (int i=0;i&lt;n;i++) t[i]=dec(a[i],t[i]); t[0]=add(1,t[0]); mult(t,b,b,n+n); t.clear(); b.resize(n);&#125;int main()&#123; n=read(); f.resize(n); for (int i=0;i&lt;n;i++) f[i]=read(); for (m=1;m&lt;=n;m&lt;&lt;=1); f.resize(m); getexp(m,f,g); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,g[i]); return 0;&#125; 4.11 普通多项式转下降幂多项式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define ls (now&lt;&lt;1)#define rs (now&lt;&lt;1|1)using namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int Mod=998244353;const int G=3; const int invG=332748118;int n,m,a[510000],rev[510000],ans[510000];ll Inv[1100000];int GPow[2][19][510000];ll fac[1100000],invfac[1100000];poly f;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(const int &amp;x)&#123; return qpow(x,Mod-2);&#125;inline void InitG()&#123; for (int p=1;p&lt;=18;p++) &#123; int buf1=qpow(G,(Mod-1)/(1&lt;&lt;p)); int buf0=qpow(invG,(Mod-1)/(1&lt;&lt;p)); GPow[1][p][0]=GPow[0][p][0]=1; for (int i=1;i&lt;(1&lt;&lt;p);i++)&#123; GPow[1][p][i]=1LL*GPow[1][p][i-1]*buf1%Mod; GPow[0][p][i]=1LL*GPow[0][p][i-1]*buf0%Mod; &#125; &#125;&#125;void NTT(poly &amp;a,const int &amp;len,int inv)&#123; if (inv==-1) inv=0; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); /*for (int mid=1;mid&lt;len;mid&lt;&lt;=1)&#123; int tmp; if (inv==1) tmp=powG[mid]; else tmp=powInvG[mid]; for (int i=0;i&lt;len;i+=(mid&lt;&lt;1))&#123; ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp))&#123; int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); &#125; &#125; &#125;*/ for (int l=2,cnt=1;l&lt;=len;l&lt;&lt;=1,cnt++)&#123; int m=l&gt;&gt;1; for (int i=0;i&lt;len;i+=l)&#123; int *buf=GPow[inv][cnt]; for (int j=0;j&lt;m;j++,buf++) &#123; int x=a[i+j],y=1LL*(*buf)*a[i+j+m]%Mod; a[i+j]=add(x,y),a[i+j+m]=dec(x,y); &#125; &#125; &#125; if (inv!=1)&#123; ll inv=Inv[len]; for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(poly a,poly b,poly &amp;c,const int &amp;n)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1);&#125;void polyinv(const int &amp;len,const int &amp;bit,poly &amp;a,poly &amp;b)&#123; int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=mul(dec(2,mul(c[i],b[i])),b[i]); NTT(b,n,-1); b.resize(len);&#125;inline int getbit(const int &amp;x)&#123; int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit;&#125;void getinv(const int &amp;n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b);&#125;poly c,d;poly getdiv(poly a,poly b)&#123; int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; d.resize(1); d[0]=0; return d; &#125; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); b.resize(n-m+1); c.clear(); getinv(n-m+1,b,c); d.clear(); mult(c,a,d,n+(n-m+1)); d.resize(n-m+1); reverse(d.begin(),d.end()); return d;&#125;poly ans1,tmp,ans2;void getmod(poly a,poly b,poly &amp;c)&#123; while (!b.empty()&amp;&amp;!b.back()) b.pop_back(); int n=a.size()-1,m=b.size()-1; if (n&lt;m)&#123; c=a; return;&#125; ans1=getdiv(a,b); mult(ans1,b,tmp,n+m); c.resize(m); for (int i=0;i&lt;m;i++) c[i]=dec(a[i],tmp[i]);&#125;poly p[510000];void getpoly(const int &amp;now,const int &amp;l,const int &amp;r)&#123; if (l==r)&#123; p[now].push_back(dec(0,a[l])); p[now].push_back(1); return; &#125; int mid=(l+r)&gt;&gt;1; getpoly(ls,l,mid); getpoly(rs,mid+1,r); mult(p[ls],p[rs],p[now],r-l+2);&#125;void solve(const poly &amp;A,const int &amp;now,const int &amp;l,const int &amp;r)&#123; if (r-l&lt;=700)&#123; for (int i=l;i&lt;=r;i++)&#123; int s=0; for (int j=A.size()-1;j&gt;=0;j--) s=add(mul(s,a[i]),A[j]); ans[i]=s; &#125; return; &#125; poly B; int mid=(l+r)&gt;&gt;1; getmod(A,p[ls],B); solve(B,ls,l,mid); getmod(A,p[rs],B); solve(B,rs,mid+1,r);&#125;poly s;void FDT(poly &amp;f,int len,int inv)&#123; f.resize(len); s.resize(len); if (inv==1) for (int i=0;i&lt;n;i++) s[i]=invfac[i]; else for (int i=0;i&lt;n;i++) if (i&amp;1) s[i]=Mod-invfac[i]; else s[i]=invfac[i]; for (int i=n;i&lt;len;i++) s[i]=0; NTT(f,len,1); NTT(s,len,1); for (int i=0;i&lt;len;i++) f[i]=mul(f[i],s[i]); NTT(f,len,-1); for (int i=n;i&lt;len;i++) f[i]=0;&#125;int main()&#123; Inv[1]=1; for (int i=2;i&lt;=1000000;i++) Inv[i]=(Mod-Mod/i)*Inv[Mod%i]%Mod; InitG(); n=read(); f.resize(n);// n=100000; f.resize(n); // for (int i=0;i&lt;n;i++) f[i]=i; for (int i=0;i&lt;n;i++) f[i]=read(); m=n; for (int i=1;i&lt;=m;i++) a[i]=i-1; getpoly(1,1,m); getmod(f,p[1],f); solve(f,1,1,m); int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); fac[0]=1; for (int i=1;i&lt;=len;i++) fac[i]=fac[i-1]*i%Mod; invfac[1]=1; for (int i=2;i&lt;=len;i++) invfac[i]=(Mod-Mod/i)*invfac[Mod%i]%Mod; invfac[0]=1; for (int i=1;i&lt;=len;i++) invfac[i]=invfac[i-1]*invfac[i]%Mod; f.resize(n); for (int i=0;i&lt;n;i++) f[i]=mul(ans[i+1],invfac[i]); FDT(f,len,-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,f[i]); return 0;&#125; 4.12 下降幂多项式转普通多项式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int G=3,invG=332748118;const int Mod=998244353;typedef long long ll;typedef vector&lt;int&gt; poly;struct node&#123; poly g,f;&#125;;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;int n,GPow[2][20][1100000];int rev[1100000]; ll fac[1100000],inv[1100000],invfac[1100000];poly f,tmp,ans;inline void InitG()&#123; fac[0]=1; for (int i=1;i&lt;=1000000;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=1000000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; invfac[0]=1; for (int i=1;i&lt;=1000000;i++) invfac[i]=invfac[i-1]*inv[i]%Mod; for (int p=1;p&lt;=19;p++) &#123; int buf1=qpow(G,(Mod-1)/(1&lt;&lt;p)); int buf0=qpow(invG,(Mod-1)/(1&lt;&lt;p)); GPow[1][p][0]=GPow[0][p][0]=1; for (int i=1;i&lt;(1&lt;&lt;p);i++)&#123; GPow[1][p][i]=1LL*GPow[1][p][i-1]*buf1%Mod; GPow[0][p][i]=1LL*GPow[0][p][i-1]*buf0%Mod; &#125; &#125;&#125;void NTT(poly &amp;a,const int &amp;len,int inv)&#123; if (inv==-1) inv=0; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int l=2,cnt=1;l&lt;=len;l&lt;&lt;=1,cnt++)&#123; int m=l&gt;&gt;1; for (int i=0;i&lt;len;i+=l)&#123; int *buf=GPow[inv][cnt]; for (int j=0;j&lt;m;j++,buf++)&#123; int x=a[i+j],y=1LL*(*buf)*a[i+j+m]%Mod; a[i+j]=add(x,y),a[i+j+m]=dec(x,y); &#125; &#125; &#125; if (inv!=1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;poly A,B;void mult(int n,int m,const poly &amp;a,const poly &amp;b,poly &amp;c)&#123; n++; m++; int len=1,bit=0; while (len&lt;(n+m)) len&lt;&lt;=1,bit++; A.resize(n); B.resize(m); for (int i=0;i&lt;n;i++) A[i]=a[i]; for (int i=0;i&lt;m;i++) B[i]=b[i]; c.resize(len); for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(A,len,1); NTT(B,len,1); for (int i=0;i&lt;len;i++) c[i]=1ll*A[i]*B[i]%Mod; NTT(c,len,-1);&#125;poly s;void ADD(poly &amp;a,const poly &amp;b)&#123; if (b.size()&gt;a.size()) a.resize(b.size()); for (int i=0;i&lt;(int)b.size();i++) a[i]=add(a[i],b[i]); &#125;void FDT(poly &amp;f,int len,int inv)&#123; f.resize(len); s.resize(len); if (inv==1) for (int i=0;i&lt;n;i++) s[i]=invfac[i]; else for (int i=0;i&lt;n;i++) if (i&amp;1) s[i]=Mod-invfac[i]; else s[i]=invfac[i]; for (int i=n;i&lt;len;i++) s[i]=0; NTT(f,len,1); NTT(s,len,1); for (int i=0;i&lt;len;i++) f[i]=mul(f[i],s[i]); NTT(f,len,-1); f.resize(n);&#125;node interpolation(int l,int r,const poly &amp;A,const poly &amp;B)&#123; if (l==r)&#123; node tmp; tmp.g.clear(); tmp.f.clear(); tmp.g.push_back(dec(0,l)); tmp.g.push_back(1); tmp.f.push_back(mul(A[l],B[l])); return tmp; &#125; int mid=(l+r)&gt;&gt;1; node a=interpolation(l,mid,A,B); node b=interpolation(mid+1,r,A,B); poly c; mult(mid-l+1,r-mid,a.g,b.g,c); poly d; mult(mid-l+1,r-mid-1,a.g,b.f,d); poly e; mult(mid-l,r-mid,a.f,b.g,e); ADD(d,e); return (node)&#123;c,d&#125;;&#125;int main()&#123; InitG(); n=read(); f.resize(n); tmp.resize(n); for (int i=0;i&lt;n;i++) f[i]=read(); int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1));f.resize(n); tmp.resize(n); FDT(f,len,1); for (int i=0;i&lt;n;i++) f[i]=mul(f[i],fac[i]); for (int i=0;i&lt;n;i++) tmp[i]=mul(invfac[i],((n-i)&amp;1)?invfac[n-i-1]:Mod-invfac[n-i-1]); ans=interpolation(0,n-1,f,tmp).f; ans.resize(n); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,ans[i]); return 0;&#125; 4.13 常系数齐次线性递推123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int G=3,invG=332748118;const int Mod=998244353;typedef long long ll;typedef vector&lt;int&gt; poly;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;inline int add(int x,int y)&#123;return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123;return x-y&lt;0?x-y+Mod:x-y;&#125;inline int mul(int x,int y)&#123;return 1ll*x*y%Mod;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline ll getinv(int x)&#123; return qpow(x,Mod-2);&#125;int GPow[2][19][410000];int rev[410000],f[410000],g[410000];poly A,B,c,a,b;inline void InitG()&#123; for (int p=1;p&lt;=18;p++) &#123; int buf1=qpow(G,(Mod-1)/(1&lt;&lt;p)); int buf0=qpow(invG,(Mod-1)/(1&lt;&lt;p)); GPow[1][p][0]=GPow[0][p][0]=1; for (int i=1;i&lt;(1&lt;&lt;p);i++)&#123; GPow[1][p][i]=1LL*GPow[1][p][i-1]*buf1%Mod; GPow[0][p][i]=1LL*GPow[0][p][i-1]*buf0%Mod; &#125; &#125;&#125;void NTT(poly &amp;a,const int &amp;len,int inv)&#123; if (inv==-1) inv=0; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int l=2,cnt=1;l&lt;=len;l&lt;&lt;=1,cnt++)&#123; int m=l&gt;&gt;1; for (int i=0;i&lt;len;i+=l)&#123; int *buf=GPow[inv][cnt]; for (int j=0;j&lt;m;j++,buf++) &#123; int x=a[i+j],y=1LL*(*buf)*a[i+j+m]%Mod; a[i+j]=add(x,y),a[i+j+m]=dec(x,y); &#125; &#125; &#125; if (inv!=1)&#123; ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); &#125;&#125;void mult(int n,int m,const poly &amp;a,const poly &amp;b,poly &amp;c)&#123; int len=1,bit=0; while (len&lt;(n+m)) len&lt;&lt;=1,bit++; A.resize(n); B.resize(m); for (int i=0;i&lt;n;i++) A[i]=a[i]; for (int i=0;i&lt;m;i++) B[i]=b[i]; c.resize(len); for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(A,len,1); NTT(B,len,1); for (int i=0;i&lt;len;i++) c[i]=1ll*A[i]*B[i]%Mod; NTT(c,len,-1);&#125;void PolyInv(int n,poly &amp;a,poly &amp;b)&#123; if (n==1)&#123; b.resize(1); b[0]=getinv(a[0]); return; &#125; PolyInv((n+1)&gt;&gt;1,a,b); int len=1,bit=0; while (len&lt;(n&lt;&lt;1)) len&lt;&lt;=1,bit++; c.resize(n); for (int i=0;i&lt;n;i++) c[i]=a[i]; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(c,len,1); NTT(b,len,1); for (int i=0;i&lt;len;i++) b[i]=1ll*(2-1ll*c[i]*b[i]%Mod+Mod)%Mod*b[i]%Mod; NTT(b,len,-1); b.resize(n);&#125;poly fr,gr,tmp,q,R,Q;void PolyMod(int n,int m,poly &amp;f,poly &amp;g,poly &amp;r)&#123; fr.clear(); tmp.clear(); q.clear(); R.clear(); f.resize(n+1); fr.resize(n+1); for (int i=0;i&lt;=n;i++) fr[n-i]=f[i]; mult(n-m+1,n,gr,fr,q); q.resize(n-m+1); reverse(q.begin(),q.end()); mult(m+1,n-m+1,g,q,R); for (int i=0;i&lt;m;i++) r[i]=(f[i]-R[i]+Mod)%Mod; r.resize(m);&#125;int n,k; poly res,x;int val[410000];int main()&#123; InitG(); n=read(); k=read(); a.resize(k+1); res.resize(k+1); x.resize(k+1); for (int i=1;i&lt;=k;i++) a[k-i]=(Mod-read()%Mod)%Mod; for (int i=0;i&lt;=k-1;i++) val[i]=(read()%Mod+Mod)%Mod; a[k]=res[0]=1; x[1]=1; gr.resize(k+1); for (int i=0;i&lt;=k;i++) gr[k-i]=a[i]; PolyInv(k+1,gr,tmp); for (int i=0;i&lt;=k;i++) gr[i]=tmp[i]; while (n)&#123; if (n&amp;1)&#123; mult(k,k,res,x,res); PolyMod(2*k+1,k,res,a,res); &#125; mult(k,k,x,x,x); PolyMod(2*k+1,k,x,a,x); n&gt;&gt;=1; &#125; int ans=0; res.resize(k); for (int i=0;i&lt;k;i++) ans=(ans+1ll*res[i]*val[i])%Mod; printf(&quot;%d\\n&quot;,ans); return 0;&#125; 5.字符串5.1 后缀自动机（SAM） 敲了一遍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int S=1;int z,n,cnt,sz[2100000],a[2100000],c[2100000],len[2100000];int link[2100000],trans[2100000][27];long long ans;char s[1100000];inline void add(int loc)&#123; int c=s[loc]-&#x27;a&#x27;,v=z; z=++cnt; len[z]=loc; for (;v&amp;&amp;!trans[v][c];v=link[v]) trans[v][c]=z; if (!v) link[z]=S; else&#123; int x=trans[v][c]; if (len[v]+1==len[x]) link[z]=x; else &#123; int y=++cnt; len[y]=len[v]+1; for (int i=0;i&lt;=26;i++) trans[y][i]=trans[x][i]; link[y]=link[x]; link[x]=y; link[z]=y; for (;trans[v][c]==x;v=link[v]) trans[v][c]=y; &#125; &#125; sz[z]=1;&#125;void calc()&#123; for (int i=1;i&lt;=cnt;i++) c[len[i]]++; for (int i=1;i&lt;=cnt;i++) c[i]+=c[i-1]; for (int i=1;i&lt;=cnt;i++) a[c[len[i]]--]=i; for (int i=cnt;i;i--)&#123; int u=a[i]; sz[link[u]]+=sz[u]; ans+=1ll*(len[u]-len[link[u]])*sz[u]*(n-sz[u]); &#125;&#125;int main()&#123; scanf(&quot;%s&quot;,s+1); n=strlen(s+1); z=1; cnt=1; for (int i=1;i&lt;=n;i++) add(i); calc(); printf(&quot;%lld\\n&quot;,ans); return 0;&#125; 5.2 回文自动机（PAM） 敲过一遍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int MAXN=310000;const int Mod=1e9+7;const int inv2=5e8+4;char s[MAXN];class Palindromic_tree&#123; /* 两棵树，记录长度为奇数和偶数的回文串 0为长度为偶数的根,1为长度为奇数的根 *1. 偶数根节点字符长度为0，不存在，将它看做一个不在字符集中的字符-1 *2. 奇数根节点字符长度为-1，作用相当于backspace，方便处理单字符形成的回文串 *3. 只更改了最长的满足条件回文串的个数， 最后要从1-&gt;tot，把fail,fail[fail],...都也加上，这样显然会T 所以要倒过来，从tot-&gt;1，cnt[fail]+=cnt[now]; */ private: int now,tot,s[MAXN]; int fail[MAXN],cnt[MAXN],len[MAXN],ch[MAXN][26]; inline int newnode(int x)&#123; //新建一个节点，长度为x len[++tot]=x; return tot; &#125; inline int getfail(int x,int r)&#123; //从l节点开始找s[r]的fail while (s[r-len[x]-1]!=s[r]) x=fail[x]; //一直跳直到找到后缀回文 return x; &#125; public: void build(const char *t,int n)&#123; for (int i=1;i&lt;=n;i++) s[i]=t[i]-&#x27;a&#x27;; s[0]=-1; fail[0]=1; len[0]=0; //*1. len[1]=-1; //*2. now=0; tot=1; //当前在0号节点，用了&lt;=1的位置 int x,y; for (int i=1;i&lt;=n;i++)&#123; x=getfail(now,i); //找到回文的位置 if (!ch[x][s[i]])&#123; //没转移过 y=newnode(len[x]+2); //前后都加上这个字符，长度加2 fail[y]=ch[getfail(fail[x],i)][s[i]]; //记录新的fail ch[x][s[i]]=y; &#125; now=ch[x][s[i]]; cnt[now]++; //记录出现次数（只记录了最长的满足条件的）*3. &#125; &#125; ll getans()&#123; ll res=0; for (int i=tot;i&gt;=1;i--)&#123; cnt[fail[i]]+=cnt[i]; res=(res+1ll*cnt[i]*(cnt[i]-1)%Mod*inv2)%Mod; &#125; return res; &#125;&#125; tree;int main()&#123; scanf(&quot;%s&quot;,s+1); tree.build(s,strlen(s+1)); printf(&quot;%lld\\n&quot;,tree.getans()); return 0;&#125; 5.3 后缀数组（SA） 背过一遍 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char s[1100000];int y[1100000],x[1100000],c[1100000],sa[1100000],rk[1100000],height[1100000],wt[30];int n,m;void get_SA()&#123; for (int i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; //c数组是桶 //x[i]是第i个元素的第一关键字 for (int i=2;i&lt;=m;++i) c[i]+=c[i-1]; //做c的前缀和，我们就可以得出每个关键字最多是在第几名 for (int i=n;i&gt;=1;--i) sa[c[x[i]]--]=i; for (int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for (int i=n-k+1;i&lt;=n;++i) y[++num]=i; //y[i]表示第二关键字排名为i的数，第一关键字的位置 //第n-k+1到第n位是没有第二关键字的 所以排名在最前面 for (int i=1;i&lt;=n;++i) if (sa[i]&gt;k) y[++num]=sa[i]-k; //排名为i的数 在数组中是否在第k位以后 //如果满足(sa[i]&gt;k) 那么它可以作为别人的第二关键字，就把它的第一关键字的位置添加进y就行了 //所以i枚举的是第二关键字的排名，第二关键字靠前的先入队 for (int i=1;i&lt;=m;++i) c[i]=0; //初始化c桶 for (int i=1;i&lt;=n;++i) ++c[x[i]]; //因为上一次循环已经算出了这次的第一关键字 所以直接加就行了 for (int i=2;i&lt;=m;++i) c[i]+=c[i-1];//第一关键字排名为1~i的数有多少个 for (int i=n;i&gt;=1;--i) sa[c[x[y[i]]]--]=y[i],y[i]=0; //因为y的顺序是按照第二关键字的顺序来排的 //第二关键字靠后的，在同一个第一关键字桶中排名越靠后 //基数排序 swap(x,y); //这里不用想太多，因为要生成新的x时要用到旧的，就把旧的复制下来，没别的意思 x[sa[1]]=1;num=1; for (int i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]] &amp;&amp; y[sa[i]+k]==y[sa[i-1]+k]) ? num : ++num; //因为sa[i]已经排好序了，所以可以按排名枚举，生成下一次的第一关键字 if (num==n) break; m=num; //这里就不用那个122了，因为都有新的编号了 &#125; for (int i=1;i&lt;=n;++i) printf(&quot;%d &quot;,sa[i]);&#125;void get_height()&#123; int k=0; for (int i=1;i&lt;=n;++i) rk[sa[i]]=i; for (int i=1;i&lt;=n;++i)&#123; if (rk[i]==1) continue;//第一名height为0 if (k) --k;//h[i]&gt;=h[i-1]-1; int j=sa[rk[i]-1]; while (j+k&lt;=n &amp;&amp; i+k&lt;=n &amp;&amp; s[i+k]==s[j+k]) ++k; height[rk[i]]=k;//h[i]=height[rk[i]]; &#125; putchar(10); for (int i=1;i&lt;=n;++i) printf(&quot;%d &quot;,height[i]);&#125;int main()&#123; gets(s+1); n=strlen(s+1); m=122; //因为这个题不读入n和m所以要自己设 //n表示原字符串长度，m表示字符个数，ascll(&#x27;z&#x27;)=122 //我们第一次读入字符直接不用转化，按原来的ascll码来就可以了 //因为转化数字和大小写字母还得分类讨论，怪麻烦的 get_SA(); //get_height(); return 0;&#125; 5.4 Manacher1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int p[21000000];char s[11000000];char t[21000000];//存添加字符后的字符串 int init()&#123;//形成新的字符串 int len=strlen(s);//len是输入字符串的长度 t[0]=&#x27;$&#x27;;//处理边界，防止越界 t[1]=&#x27;#&#x27;; int j=2; for (int i=0;i&lt;len;i++)&#123; t[j++]=s[i]; t[j++]=&#x27;#&#x27;; &#125; t[j]=&#x27;\\0&#x27;;//处理边界，防止越界（容易忘记） return j;// 返回t的长度 &#125;int Manacher()&#123;//返回最长回文串 int len=init();//取得新字符串的长度， 完成向t的转换 int max_len=-1;//最长回文长度 int id; int mx=0; for (int i=1;i&lt;=len;i++)&#123; if (i&lt;mx) p[i]=min(p[2*id-i],mx-i);//上面图片就是这里的讲解 else p[i]=1; while (t[i-p[i]]==t[i+p[i]])//不需边界判断，因为左有&#x27;$&#x27;，右有&#x27;\\0&#x27;标记； p[i]++;//mx对此回文中点的贡献已经结束，现在是正常寻找扩大半径 if (mx&lt;i+p[i])&#123;//每走移动一个回文中点，都要和mx比较，使mx是最大，提高p[i]=min(p[2*id-i],mx-i)效率 id=i;//更新id mx=i+p[i];//更新mx &#125; max_len=max(max_len,p[i]-1); &#125; return max_len; &#125;int main()&#123; scanf(&quot;%s&quot;,s); printf(&quot;%d&quot;,Manacher()); return 0;&#125; 5.5 0/1可持久化trie123456789101112131415void change(int &amp;x,int dep,int v)&#123; tree[++cnt]=tree[x]; x=cnt; tree[x].sz++; if (dep==-1) return; bool k=v&amp;(1&lt;&lt;dep); if (k) change(tree[x].ch[1],dep-1,v); else change(tree[x].ch[0],dep-1,v);&#125;void build()&#123; cnt=0; for (int i=1;i&lt;=n;i++)&#123; rt[i]=rt[i-1]; change(rt[i],30,a[i]); &#125;&#125; 5.6 离线可删线性基123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;unordered_map&gt;using namespace std;int n,m,Q,ans,sz,op[2100000],x[2100000],lst[2100000],nxt[2100000];bool vis[35];struct node&#123; int x,y; bool operator&gt;(const node &amp;a) const&#123; return nxt[y]&gt;nxt[a.y]; &#125;&#125; c[35];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;unordered_map&lt;int,int&gt; num;void ins(node x)&#123; for (int i=n;i&gt;=0;i--) if (x.x&amp;(1&lt;&lt;i))&#123; if (!vis[i])&#123; vis[i]=true; sz++; c[i]=x; break; &#125; else&#123; if (x&gt;c[i]) swap(c[i],x); x.x^=c[i].x; &#125; &#125;&#125;void del(int x)&#123; for (int i=n;i&gt;=0;i--) if (vis[i]&amp;&amp;c[i].y==x)&#123; vis[i]=false; sz--; break; &#125; &#125;int main()&#123; n=read(); Q=read(); m=(1&lt;&lt;n); for (int i=1;i&lt;=Q;i++)&#123; op[i]=read(); x[i]=read(); nxt[num[x[i]]]=i; lst[i]=num[x[i]]; num[x[i]]=i; &#125; for (int i=1;i&lt;=Q;i++) if (!nxt[i]) nxt[i]=Q+1; for (int i=1;i&lt;=Q;i++)&#123; if (op[i]==1) ins((node)&#123;x[i],i&#125;); else del(lst[i]); ans^=(m/(1&lt;&lt;sz)); &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; 5.7 AC自动机 todo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int T,n,q,a[510000],pos[510000],len[510000],l[510000];int tot,sum[510000],fail[510000],ch[510000][27];int head,tail,que[510000];char st[510000],s[510000],pre[510000],suf[510000];int ins()&#123; int now=0,len; len=strlen(suf); for (int i=0;i&lt;len;i++)&#123; if (!ch[now][suf[i]-&#x27;a&#x27;]) ch[now][suf[i]-&#x27;a&#x27;]=++tot; now=ch[now][suf[i]-&#x27;a&#x27;]; &#125; if (!ch[now][26]) ch[now][26]=++tot; now=ch[now][26]; len=strlen(pre); for (int i=0;i&lt;len;i++)&#123; if (!ch[now][pre[i]-&#x27;a&#x27;]) ch[now][pre[i]-&#x27;a&#x27;]=++tot; now=ch[now][pre[i]-&#x27;a&#x27;]; &#125; l[now]=strlen(suf)+strlen(pre); return now;&#125;void build()&#123; int head=1,tail=0; for (int i=0;i&lt;=26;i++) if (ch[0][i]) que[++tail]=ch[0][i]; while (head&lt;=tail)&#123; int now=que[head++]; for(int i=0;i&lt;=26;i++)&#123; if (ch[now][i])&#123; fail[ch[now][i]]=ch[fail[now]][i]; que[++tail]=ch[now][i]; &#125; else ch[now][i]=ch[fail[now]][i]; &#125; &#125;&#125;void query(int x,int len)&#123; int now=0; for (int i=x+1;i&lt;=x+len;i++) now=ch[now][st[i]-&#x27;a&#x27;]; now=ch[now][26]; for (int i=x+1;i&lt;=x+len;i++)&#123; now=ch[now][st[i]-&#x27;a&#x27;]; int tmp=now; while (l[tmp]&gt;len) tmp=fail[tmp]; sum[tmp]++; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; memset(fail,0,sizeof(fail)); memset(sum,0,sizeof(sum)); memset(ch,0,sizeof(ch)); scanf(&quot;%d%d&quot;,&amp;n,&amp;q); int cnt=0; tot=0; for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%s&quot;,s+1); len[i]=strlen(s+1); a[i]=cnt; for (int j=1;j&lt;=len[i];j++) st[++cnt]=s[j]; &#125; for (int i=1;i&lt;=q;i++)&#123; scanf(&quot;%s%s&quot;,pre,suf); pos[i]=ins(); &#125; build(); for (int i=1;i&lt;=n;i++) query(a[i],len[i]); for (int i=tot;i&gt;=1;i--) sum[fail[que[i]]]+=sum[que[i]]; for (int i=1;i&lt;=q;i++) printf(&quot;%d\\n&quot;,sum[pos[i]]); &#125; return 0;&#125; 6.分治6.1 整体二分 todo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int MAXN=1100000;typedef long long ll;int n,m,x,k,t[MAXN],ans[MAXN];ll tree[MAXN];vector&lt;int&gt; vec[MAXN];struct node&#123; int l,r,num; bool isq; ll k;&#125; a[MAXN],Left[MAXN],Right[MAXN];inline void add(int x,ll y)&#123; for (;x&lt;=m;x+=x&amp;-x) tree[x]+=y;&#125;inline ll getsum(int x)&#123; ll sum=0; for (;x;x-=x&amp;-x) sum+=tree[x]; return sum;&#125;void solve(int L,int R,int l,int r)&#123; if (l&gt;r) return; if (L==R)&#123; for (int i=l;i&lt;=r;i++) if (a[i].isq) ans[a[i].num]=L; return; &#125; int mid=(L+R)&gt;&gt;1,n=0,m=0; for (int i=l;i&lt;=r;i++)&#123; if (a[i].isq)&#123; ll tmp=0; for (int j=0;j&lt;vec[a[i].num].size();j++)&#123; tmp+=getsum(vec[a[i].num][j]); if (tmp&gt;=a[i].k) break; &#125; if (tmp&gt;=a[i].k) Left[++n]=a[i]; else a[i].k-=tmp,Right[++m]=a[i]; &#125; else&#123; if (a[i].num&lt;=mid)&#123; if (a[i].l&lt;=a[i].r)&#123; add(a[i].l,a[i].k); add(a[i].r+1,-a[i].k); &#125; else&#123; add(1,a[i].k); add(a[i].r+1,-a[i].k); add(a[i].l,a[i].k); &#125; Left[++n]=a[i]; &#125; else Right[++m]=a[i]; &#125; &#125; for (int i=l;i&lt;=r;i++) if (a[i].num&lt;=mid&amp;&amp;!a[i].isq)&#123; if (a[i].l&lt;=a[i].r)&#123; add(a[i].l,-a[i].k); add(a[i].r+1,a[i].k); &#125; else&#123; add(1,-a[i].k); add(a[i].r+1,a[i].k); add(a[i].l,-a[i].k); &#125; &#125; for (int i=1;i&lt;=n;i++) a[l+i-1]=Left[i]; for (int i=1;i&lt;=m;i++) a[l+n+i-1]=Right[i]; solve(L,mid,l,l+n-1); solve(mid+1,R,l+n,r);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d&quot;,&amp;x); vec[x].push_back(i); &#125; for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;t[i]); scanf(&quot;%d&quot;,&amp;k); for (int i=1;i&lt;=k;i++)&#123; scanf(&quot;%d%d%lld&quot;,&amp;a[i].l,&amp;a[i].r,&amp;a[i].k); a[i].isq=false; a[i].num=i; &#125; for (int i=1;i&lt;=n;i++)&#123; a[i+k].k=t[i]; a[i+k].isq=true; a[i+k].num=i; &#125; solve(1,k+1,1,k+n); for (int i=1;i&lt;=n;i++) if (ans[i]!=k+1) printf(&quot;%d\\n&quot;,ans[i]); else puts(&quot;NIE&quot;); return 0;&#125; 6.2 CDQ分治（三维偏序） todo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int MAXM=210000;struct node&#123; int s,c,m,num,tot;&#125; t[MAXN],a[MAXN];int n,k,cnt,tree[MAXM],tot[MAXN],num[MAXN],ans[MAXN];inline void add(int x,int y)&#123; for (;x&lt;=k;x+=x&amp;(-x)) tree[x]+=y;&#125;inline int getsum(int x)&#123; int sum=0; for (;x;x-=x&amp;(-x)) sum+=tree[x]; return sum;&#125;inline int cmp1(node a,node b)&#123; return (a.s&lt;b.s)||(a.s==b.s&amp;&amp;a.c&lt;b.c)||(a.s==b.s&amp;&amp;a.c==b.c&amp;&amp;a.m&lt;b.m);&#125;inline int cmp2(node a,node b)&#123; return (a.c&lt;b.c)||(a.c==b.c&amp;&amp;a.m&lt;b.m);&#125;void CDQ(int l,int r)&#123; if (l==r)&#123; tot[a[l].num]+=a[l].tot-1; return; &#125; int mid=(l+r)&gt;&gt;1; CDQ(l,mid); CDQ(mid+1,r); sort(a+l,a+mid+1,cmp2); sort(a+mid+1,a+r+1,cmp2); int i,j; for (i=l,j=mid+1;j&lt;=r;j++)&#123; for (;i&lt;=mid&amp;&amp;a[i].c&lt;=a[j].c;i++) add(a[i].m,a[i].tot); tot[a[j].num]+=getsum(a[j].m); &#125; while ((--i)&gt;=l) add(a[i].m,-a[i].tot);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;t[i].s,&amp;t[i].c,&amp;t[i].m); sort(t+1,t+n+1,cmp1); for (int i=1;i&lt;=n;i++) if (i==1||t[i-1].s!=t[i].s||t[i-1].m!=t[i].m||t[i-1].c!=t[i].c)&#123; a[++cnt]=t[i]; a[cnt].tot=1; a[cnt].num=cnt; &#125; else a[cnt].tot++; for (int i=1;i&lt;=cnt;i++) num[i]=a[i].tot; CDQ(1,cnt); for (int i=1;i&lt;=cnt;i++) ans[tot[i]]+=num[i]; for (int i=0;i&lt;n;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0;&#125; 7. 计算几何7.1 基础模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct Point&#123; double x,y; Point(double x=0,double y=0):x(x),y(y)&#123;&#125;&#125;;typedef Point Vector;Vector operator+(Vector A,Vector B)&#123; return Vector(A.x+B.x,A.y+B.y);&#125;Vector operator-(Point A,Point B)&#123; return Vector(A.x-B.x,A.y-B.y);&#125;Vector operator*(Vector A,double p)&#123; return Vector(A.x*p,A.y*p);&#125;Vector operator/(Vector A,double p)&#123; return Vector(A.x/p,A.y/p);&#125;const double eps=1e-6;int sgn(double x)&#123; if (fabs(x)&lt;eps) return 0; if (x&lt;0) return -1; return 1;&#125;bool operator==(const Point&amp; a,const Point&amp; b)&#123; if (sgn(a.x-b.x)==0&amp;&amp;sgn(a.y-b.y)==0) return true; return false;&#125;double Dot(Vector A,Vector B)&#123; return A.x*B.x+A.y*B.y;&#125;double Length(Vector A)&#123; return sqrt(Dot(A, A));&#125;double Angle(Vector A,Vector B)&#123; return acos(Dot(A,B)/Length(A)/Length(B));&#125;double Cross(Vector A,Vector B)&#123; return A.x*B.y-A.y*B.x;&#125;double Area(Point A,Point B,Point C)&#123;//计算两向量构成的三角形形有向面积 return Cross(B-A,C-A)/2;&#125;double Area2(Point A,Point B,Point C)&#123;//计算两向量构成的平行四边形有向面积 return Cross(B-A,C-A);&#125;Vector Rotate(Vector A,double rad)&#123;//rad为弧度 且为逆时针旋转的角 return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));&#125;Vector Normal(Vector A)&#123;//向量A左转90°的单位法向量 double L=Length(A); return Vector(-A.y/L,A.x/L);&#125;bool ToLeftTest(Point a,Point b,Point c)&#123; return Cross(b-a,c-b)&gt;0;&#125;double DistanceToLine(Point P,Point A,Point B)&#123;//点P到直线AB距离公式 Vector v1=B-A,v2=P-A; return fabs(Cross(v1,v2)/Length(v1));//不去绝对值，得到的是有向距离&#125;double DistanceToSegment(Point P,Point A,Point B)&#123;//点P到线段AB距离公式 if (A==B) return Length(P-A); Vector v1=B-A,v2=P-A,v3=P-B; if (dcmp(Dot(v1,v2))&lt;0) return Length(v2); if (dcmp(Dot(v1,v3))&gt;0) return Length(v3); return DistanceToLine(P,A,B);&#125; 8.矩阵12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364## 4.6 矩阵基础模板​```cppstruct matrix&#123; int v[55][55]; matrix()&#123; memset(v,0,sizeof(v));&#125; int det()&#123; int res=1; for (int i=1;i&lt;=K;i++)&#123; if (!v[i][i])&#123; for (int j=i+1;j&lt;=K;j++) if (v[j][i])&#123; swap(v[i],v[j]); break;&#125; res=dec(0,res); if (!v[i][i]) return 0; &#125; ll inv=getinv(v[i][i]); for (int j=i+1;j&lt;=K;j++)&#123; int tmp=mul(v[j][i],inv); for (int k=i;k&lt;=K;k++) v[j][k]=dec(v[j][k],mul(tmp,v[i][k])); &#125; &#125; for (int i=1;i&lt;=K;i++) res=mul(res,v[i][i]); return res; &#125; friend matrix operator+(const matrix &amp;a,const matrix &amp;b)&#123; matrix res; for (int i=1;i&lt;=K;i++) for (int j=1;j&lt;=K;j++) res.v[i][j]=add(a.v[i][j],b.v[i][j]); return res; &#125; friend matrix operator-(const matrix &amp;a,const matrix &amp;b)&#123; matrix res; for (int i=1;i&lt;=K;i++) for (int j=1;j&lt;=K;j++) res.v[i][j]=dec(a.v[i][j],b.v[i][j]); return res; &#125; friend matrix operator*(const matrix &amp;a,const int b)&#123; matrix res; for (int i=1;i&lt;=K;i++) for (int j=1;j&lt;=K;j++) res.v[i][j]=mul(a.v[i][j],b); return res; &#125; friend matrix operator*(const matrix &amp;a,const matrix &amp;b)&#123; matrix res; for (int i=1;i&lt;=K;i++) for (int k=1;k&lt;=K;k++) if (a.v[i][k]) for (int j=1;j&lt;=K;j++) res.v[i][j]=add(res.v[i][j],mul(a.v[i][k],b.v[k][j])); return res; &#125; friend matrix operator^(matrix x,int a)&#123; matrix res; for (int i=1;i&lt;=K;i++) res.v[i][i]=1; while (a)&#123; if (a&amp;1) res=res*x; x=x*x; a&gt;&gt;=1; &#125; return res; &#125;&#125;; ToDo List：多项式多点插值"}],"posts":[{"title":"有趣的题","slug":"sol_2","date":"2020-09-29T16:00:00.000Z","updated":"2020-09-30T10:55:33.990Z","comments":true,"path":"2020/09/30/sol_2/","link":"","permalink":"http://example.com/2020/09/30/sol_2/","excerpt":"","text":"概率problem 1一个圆中等概率随机选取 $4$ 个点，那么存在一条直径，使得点全在直径一侧的概率是？ 解答参考：https://www.zhihu.com/question/339701586/answer/789026122 不妨设没有两个点 $A,B$，使得 $O,A,B$ 三点共线。因为这样的概率$\\rightarrow 0$。 定义点 $A$ 为 “最右点” 当且仅当剩下三个点的圆心角都在 $A$ 的圆心角+90°之内。 我们不妨来研究一下“最右点”和答案的关系。 如果四个点处于同一半圆，当且仅当存在“最右点”。 “最右点”要么没有，要么只有一个，所以每个点是“最右点”是互斥的。 第一次、第二次选的点、第三次、第四次选的点，成为“最右点”的概率都是$\\frac 18$，且它们互不影响。 那么，概率为 $4\\times \\frac 18=\\frac 12$。 这个问题可以推广到随机选取 $n$ 个点，概率为 $\\frac n{2^{n-1}}$。 problem 2$S$ 是集合 $1,2,\\cdots,2004$ 的子集，$S$ 中的任意两个数的差不等于 $4$ 或 $7$，问 $S$ 中最多含有多少个元素？ 解答参考：https://wenku.baidu.com/view/e634ddcc69eae009581becc1.html 我们将任意连续 $11$ 个数排成一圈，如右图所示： 显然，由题目条件，相邻的两个数不能同时选，那么最多只能选 $5$ 个数。即每 $11$ 个数至多只能选 $5$ 个数。又因为 $2004=182\\times 11+2$，所以至多能选 $182\\times 5+2=912$ 个数。 其次，令 $S=\\{x|x=11k+t,k\\in \\mathcal{Z},t=1,2,4,7,10,1\\leqslant x\\leqslant 2004\\}$ ，那么 $S$ 满足题目条件，且 $|S|=912$。故答案为 $912$。 有趣的题problem 1解答参考：https://www.bilibili.com/video/BV1UD4y1U7or 有一个 $64$ 个格子的棋盘，每个格子上放着一个正面朝上或反面朝上的棋子。有一个格子下有硬币。 有两个人想得到这枚硬币。开始前，两人均不知道棋盘上每个棋子的正反，只知道是个 $8\\times 8$ 的棋盘，但他们可以商量一个策略。 第一个人先可以看到棋盘上每个棋子的正反，同时裁判会告诉第一个人钥匙在哪个棋子的下面。然后这个人必须要翻转且仅翻转一枚棋子，然后离开。 然后，第二个人再看到棋盘，他只知道现在棋盘上每个棋子的正反，要说出硬币的位置。 问是否有固定策略。 首先考虑只有 $2$ 个格子怎么做。不妨设 $0$ 为正面，$1$ 为反面。 对于第一个人，如果硬币在第一个位置，它要翻成 $0,0$ 或 $0,1$ 中的一种。如果在第二个位置，他要翻成 $1,0$ 或 $1,1$ 中的一种。可以发现，不管初始局面如何，第一个人都可以通过一步达到要求。 为什么呢，，因为每个点都可以通过走一条边到达一个红点和蓝点，点代表的是局面，颜色代表的是硬币的位置。 我们可以轻易得到 $3$ 个格子是无解的。$3$ 个格子相当于一个立方体，每个顶点有三条边，相邻的点分别为红、绿、蓝三种颜色，每个点最多影响 $3$ 个点的相邻点，所以至少有 $3$ 个红顶点，$3$ 个绿顶点，$3$ 个蓝顶点。而总共只有 $8$ 个顶点，所以不合法。发现只有当 $\\frac{2^n}n\\in\\mathcal Z$ 合法，即 $n\\mid 2^n$，也就是说 $n$ 为 $2$ 的次幂。 那么显然 $64$ 个格子是合法的。 那么具体策略是什么呢？ 不妨将每个位置标号为 $0,1,2,\\cdots,63$，设有硬币的格子为 $x$。将反面棋子的位置异或起来，记为 $y$。 将 $x\\oplus y$ 翻转，那么硬币的位置为当前状态下反面棋子的位置的异或和。 为什么呢？因为 $y\\oplus(x\\oplus y)=x$，就做完了。","categories":[],"tags":[]},{"title":"城市","slug":"sol_3","date":"2020-09-23T16:00:00.000Z","updated":"2020-09-30T12:06:25.326Z","comments":true,"path":"2020/09/24/sol_3/","link":"","permalink":"http://example.com/2020/09/24/sol_3/","excerpt":"","text":"城市设答案乘 $n^i$ 后的值为 $ans_i$。则： \\begin{align*} ans_i&=\\sum_{i\\texttt{次操作后得到的}\\\\\\texttt{可重有序点集}S}\\sum_{\\texttt{连通块}P}[S\\texttt{中的点都在}P\\texttt{中}]\\\\ &=\\sum_{\\texttt{连通块}P}\\sum_{i\\texttt{次操作后得到的}\\\\\\texttt{可重有序点集}S}[S\\texttt{中的点都在}P\\texttt{中}]\\\\ &=\\sum_{\\texttt{连通块}P}|P|^i \\end{align*}如果直接要求这个 $|P|^i$，要维护所有大小的连通块个数，而连通块大小可以达到 $O(n)$ 级别。 然后这里有个套路，将 $P^i$ 用斯特林数展开。展开公式：$x^k=\\sum \\limits_{i=1}^{x}S(k,i)C(x,i)i! $。（下界也可以从 $0$ 开始） 考虑证明：$x^k$ 可以理解为有 $x$ 个不同的盒子，把 $k$ 个不同的球放入盒子中的方案数，允许空盒。 现在把”允许空盒“转化成”不允许空盒“（所有盒子都至少放入一个球） 首先枚举非空的盒子个数，设为 $i$，那么存在 $k−i$ 个空盒。 选出这 $i$ 个不同的非空盒子有 $C(x,i)$ 种方案，将 $k$ 个不同的球放入 $i$ 个无序非空盒子有 $S(k,i)$ 种方案，现在这些盒子是有序的，再乘上 $i!$ 就是结果。 \\begin{align*} ans_i&=\\sum_{\\texttt{连通块}P}|P|^i\\\\ &=\\sum_{\\texttt{连通块}P}\\sum_{j=0}^iS(i,j)C(|P|,j)j!\\\\ &=\\sum_{j=0}^iS(i,j)j!\\sum_{\\texttt{连通块}P}C(|P|,j)\\\\ \\end{align*}那么现在就要求 $\\sum\\limits_{\\texttt{连通块}P}C(|P|,i),\\forall 0\\leqslant i\\leqslant k$。 考虑树形 $dp$，设 $dp[u][i]$ 表示以 $u$ 为根的所有连通块 $P$ 的 $C(|P|,i)$ 之和。 观察大小为 $a$ 的连通块和大小为 $b$ 的连通块合并后，现在的 $C(|P|,i)$ 的值和原来的值有什么关系，有$C(|a|+|b|,i)=\\sum\\limits_{j=0}^{|a|+|b|} C(|a|,j)C(|b|,|a|+|b|-j)$，可以直接背包合并（卷积），时间复杂度 $O(nk)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/********************************************************************* * Source：zr09 - day2 * Problem：city - T4 * Author：hydd * Date：2020/9/22*********************************************************************/#include&lt;cstdio&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;const int Mod=998244353;int n,k,dp[200005][105],S[105][105],sz[200005],f[200005],tmp[200005];int edgenum,vet[400005],Next[400005],Head[200005];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ll qpow(ll x,ll a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void dfs(int u,int fa)&#123; dp[u][0]=1; dp[u][1]=1; sz[u]=1; for (int e=Head[u];e;e=Next[e]) if (vet[e]!=fa)&#123; dfs(vet[e],u); for (int i=0;i&lt;=k&amp;&amp;i&lt;=sz[u]+sz[vet[e]];i++) tmp[i]=dp[u][i]; for (int i=0;i&lt;=k&amp;&amp;i&lt;=sz[u];i++) for (int j=0;i+j&lt;=k&amp;&amp;j&lt;=sz[vet[e]];j++) tmp[i+j]=(tmp[i+j]+1ll*dp[u][i]*dp[vet[e]][j])%Mod; for (int i=0;i&lt;=k&amp;&amp;i&lt;=sz[u]+sz[vet[e]];i++) dp[u][i]=tmp[i]; sz[u]+=sz[vet[e]]; &#125; for (int i=0;i&lt;=k&amp;&amp;i&lt;=sz[u];i++) f[i]=(f[i]+dp[u][i])%Mod;&#125;int main()&#123; freopen(&quot;city.in&quot;,&quot;r&quot;,stdin); freopen(&quot;city.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;k); int u,v; for (int i=1;i&lt;n;i++)&#123; u=read(); v=read(); addedge(u,v); addedge(v,u); &#125; S[0][0]=1; for (int i=1;i&lt;=k;i++) for (int j=1;j&lt;=k;j++) S[i][j]=(S[i-1][j-1]+1ll*S[i-1][j]*j)%Mod; dfs(1,0); int invn=qpow(n,Mod-2),tmp=1; for (int i=1;i&lt;=k;i++)&#123; int ans=0,mul=1; tmp=1ll*tmp*invn%Mod; for (int j=1;j&lt;=i;j++)&#123; mul=1ll*mul*j%Mod; ans=(ans+1ll*mul*S[i][j]%Mod*f[j])%Mod; &#125; printf(&quot;%lld\\n&quot;,1ll*ans*tmp%Mod); &#125; return 0;&#125;","categories":[{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://example.com/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"树形dp（期望）","slug":"树形dp（期望）","permalink":"http://example.com/tags/%E6%A0%91%E5%BD%A2dp%EF%BC%88%E6%9C%9F%E6%9C%9B%EF%BC%89/"}]},{"title":"ckw的树","slug":"sol_4","date":"2020-09-23T16:00:00.000Z","updated":"2020-09-30T12:06:31.944Z","comments":true,"path":"2020/09/24/sol_4/","link":"","permalink":"http://example.com/2020/09/24/sol_4/","excerpt":"","text":"ckw的树设 $f[u]$ 表示从 $u$ 开始游走的期望时间。不妨设 $f[u]=a_uf[fa(fa(u))]+b_uf[fa(u)]+c_usum[fa(u)]+d_u$。 不妨设 $fa(1)=0,fa(0)=0$，$f[0]=0$。设 $t_u$ 为与 $u$ 距离不超过 $2$ 的点的个数。 若它的子树中每个点的 $f[v]$ 都可以用 $a_v,b_v,c_v,d_v$ 表示出来，考虑怎么将 $f[u]$ 用 $a_u,b_u,c_u,d_u$ 表示出来。 根据题意，每次可以从 $u$ 到距离不超过 $2$ 的任意一个节点，记 $sum[u]=\\sum\\limits_{v\\in son(u)}f[v]$，那么满足： $t_uf[u]=f[fa(fa(u))]+f[fa(u)]+sum[fa(u)]+sum[u]+\\sum\\limits_{v\\in son(u)}sum[v]$（这个点不是标记点） $f[u]=0$（这个点是标记点） 若这个点是标记点，则 $a_u=0,b_u=0,c_u=0,d_u=0$，以下考虑不是标记点的情况。 我们发现这个 $sum[u]$ 和 $sum[v]$ 比较恶心，我们考虑把它拆开： \\begin{align*} sum[u] &=\\sum_{v\\in son(u)} f[v]\\\\ &=\\sum_{v\\in son(u)}(a_vf[fa(fa(v))]+b_vf[fa(v)]+c_vsum[fa(v)]+d_v)\\\\ &=\\sum_{v\\in son(u)}(a_vf[fa(u)]+b_vf[u]+c_vsum[u]+d_v)\\\\ &=\\sum_{v\\in son(u)}a_vf[fa(u)]+\\sum_{v\\in son(u)}b_vf[u]+\\sum_{v\\in son(u)}c_vsum[u]+\\sum_{v\\in son(u)}d_v \\end{align*}即 $sum_a=\\sum\\limits_{v\\in son(u)}a_v,sum_b=\\sum\\limits_{v\\in son(u)}b_v,sum_c=\\sum\\limits_{v\\in son(u)}c_v,sum_d=\\sum\\limits_{v\\in son(u)}d_v$。 则 $sum[u]=sum_a\\cdot f[fa(u)]+sum_b\\cdot f[u]+sum_c\\cdot sum[u]+sum_d$。 移项： $(1-sum_c)\\cdot sum[u]=sum_a\\cdot f[fa(u)]+sum_b\\cdot f[u]+sum_d$。 两边同除 $1-sum_c$ 可得：$sum[u]=\\dfrac{sum_a\\cdot f[fa(u)]+sum_b\\cdot f[u]+sum_d}{1-sum_c}$ 令 $sa[u]=\\dfrac{sum_a}{1-sum_c},sb[u]=\\dfrac{sum_b}{1-sum_c},sd[u]=\\dfrac{sum_d}{1-sum_c}$。 那么：$sum[u]=sa[u]f[fa(u)]+sb[u]f[u]+sd[u]$。由于 $a_v,b_v,c_v,d_v$ 已知，那么 $sa[u],sb[u],sd[u]$ 已知，即可求出 $sum[u],sum[v]$ 的表达式。 先将 $sum[v]$ 拆开，代入 $f[u]$ 所满足的式子：$t_uf[u]=f[fa(fa(u))]+f[fa(u)]+sum[fa(u)]+sum[u]+\\sum\\limits_{v\\in son(u)}(sa[v]f[u]+sb[v]f[v]+sd[v])$ 将和式拆分：$t_uf[u]=f[fa(fa(u))]+f[fa(u)]+sum[fa(u)]+sum[u]+f[u]\\sum\\limits_{v\\in son(u)}sa[v]+\\sum\\limits_{v\\in son(u)}sb[v]f[v]+\\sum\\limits_{v\\in son(u)} sd[v]$ 再将 $f[v]$ 拆开：$t_uf[u]=f[fa(fa(u))]+f[fa(u)]+sum[fa(u)]+sum[u]+f[u]\\sum\\limits_{v\\in son(u)}sa[v]+\\sum\\limits_{v\\in son(u)} sd[v]+\\sum\\limits_{v\\in son(u)} sb[v]\\cdot (a_vf[fa(u)]+b_vf[u]+c_vsum[u]+d_v)$ 整理：$t_uf[u]=f[fa(fa(u))]+f[fa(u)]+sum[fa(u)]+sum[u]+f[u]\\sum\\limits_{v\\in son(u)}sa[v]+\\sum\\limits_{v\\in son(u)} sd[v]+\\sum\\limits_{v\\in son(u)} sb[v]a_vf[fa(u)]+\\sum\\limits_{v\\in son(u)}sb[v]b_vf[u]+\\sum\\limits_{v\\in son(u)}sb[v]c_vsum[u]+\\sum\\limits_{v\\in son(u)}sb[v]d_v$ 移项：$f[fa(fa(u))]+(1+\\sum\\limits_{v\\in son(u)} sb[v]a_v)f[fa(u)]+sum[fa(u)]+(\\sum\\limits_{v\\in son(u)}sb[v]d_v+\\sum\\limits_{v\\in son(u)} sd[v])+(\\sum\\limits_{v\\in son(u)}sa[v]+\\sum\\limits_{v\\in son(u)}sb[v]b_v-t_u)f[u]+(1+\\sum\\limits_{v\\in son(u)}sb[v]c_v)sum[u]=0$ 再将 $sum[u]$ 拆开： $f[fa(fa(u))]+(1+\\sum\\limits_{v\\in son(u)} sb[v]a_v)f[fa(u)]+sum[fa(u)]+(\\sum\\limits_{v\\in son(u)}sb[v]d_v+\\sum\\limits_{v\\in son(u)} sd[v])+(\\sum\\limits_{v\\in son(u)}sa[v]+\\sum\\limits_{v\\in son(u)}sb[v]b_v-t_u)f[u]+(1+\\sum\\limits_{v\\in son(u)}sb[v]c_v)(sa[u]f[fa(u)]+sb[u]f[u]+sd[u])=0$ 记 $su=(1+\\sum\\limits_{v\\in son(u)}sb[v]c_v)$，可得： $f[fa(fa(u))]+(1+(\\sum\\limits_{v\\in son(u)} sb[v]a_v)+su\\cdot sa[u])f[fa(u)]+sum[fa(u)]+((\\sum\\limits_{v\\in son(u)}sa[v])+(\\sum\\limits_{v\\in son(u)}sb[v]b_v)-t_u+su\\cdot sb[u])f[u]+((\\sum\\limits_{v\\in son(u)}sb[v]d_v)+(\\sum\\limits_{v\\in son(u)} sd[v])+su\\cdot sd[u])=0$ 令 $c_1=t_u-(\\sum\\limits_{v\\in son(u)}sa[v])-(\\sum\\limits_{v\\in son(u)}sb[v]b_v)-su\\cdot sb[u],c_2=1+(\\sum\\limits_{v\\in son(u)} sb[v]a_v)+su\\cdot sa[u],c_3=(\\sum\\limits_{v\\in son(u)}sb[v]d_v)+(\\sum\\limits_{v\\in son(u)} sd[v])+su\\cdot sd[u]$ 整理：$c_1f[u]=f[fa(fa(u))]+c_2f[fa(u)]+sum[fa(u)]+c_3$ 两边同除 $c_1$：$f[u]=\\frac{1}{c_1}f[fa(fa(u))]+\\frac{c_2}{c_1}f[fa(u)]+\\frac{1}{c_1}sum[fa(u)]+\\frac{c_3}{c_1}$。 可得：$a_u=\\frac{1}{c_1},b_u=\\frac{c_2}{c_1},c_u=\\frac{1}{c_1},d_u=\\frac{c_3}{c_1}$。 至此可以求出所有点 $f$ 都可以用 $a,b,c,d$ 表达出来，同时也把所有点的 $sa,sb,sc,sd$ 也都求出来了。 $f[u]=a_uf[fa(fa(u))]+b_uf[fa(u)]+c_usum[fa(u)]+d_u$，那么可以将 $sum[fa(u)]$ 拆开，可得： $f[u]=a_uf[fa(fa(u))]+b_uf[fa(u)]+c_u(sa[fa(u)]f[fa(fa(u))]+sb[fa(u)]f[fa(u)]+sd[fa(u)])+d_u$ 整理：$f[u]=(a_u+c_usa[fa(u)])f[fa(fa(u))]+(b_u+c_usb[fa(u)])f[fa(u)]+(c_u\\cdot sd[fa(u)]+d_u)$。 令 $f[u]=a’_uf[fa(fa(u))]+b’_uf[fa(u)]+d’_u$ 则 $a’_u=a_u+c_usa[fa(u)],b’_u=b_u+c_usb[fa(u)],d’_u=c_u\\cdot sd[fa(u)]+d_u$。 注意，这个地方 $f[1]$ 不能这样拆开，因为 $fa(1)=0,sa[0],sb[0],sd[0]$ 没有处理，而 $sum[0]=f[1]$，解一下： $f[1]=c_1f[1]+d_1$，而 $(1-c_1)f[1]=d_1$，则 $f[1]=\\frac{d_1}{1-c_1}$。所有点的 $f$ 值可以用一遍从上到下的 $dfs$ 求得。 这样这道题就做完了，不过注意若一个点是标记点也要处理 $sa,sb,sc,sd$，它们会在转移它的父亲的时候用到。 时间复杂度 $O(n)$，空间复杂度 $O(n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/********************************************************************* * Source：zr09 - day3 * Problem：tree * Author：hydd * Date：2020/9/24*********************************************************************/#include&lt;cstdio&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;const int Mod=998244353;typedef long long ll;int n,m,tot[110000],f[110000]; bool vis[110000];int sa[110000],sb[110000],sd[110000];int a[110000],b[110000],c[110000],d[110000];int edgenum,vet[210000],Next[210000],Head[110000];inline void add(int &amp;x,int y)&#123; x+=y; if (x&gt;=Mod) x-=Mod;&#125;void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ll qpow(ll x,int a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;inline int getinv(int x)&#123; return qpow(x,Mod-2);&#125;void dfs(int u,int fa)&#123; tot[u]=1; for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; tot[u]++; dfs(vet[e],u); &#125;&#125;void dp(int u,int fa,int fa_2)&#123; int cnt=(fa?tot[fa]:1)+(fa_2!=0); for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; cnt+=tot[vet[e]]; dp(vet[e],u,fa); &#125; int fu=Mod-cnt,ffa=1,ffafa=1,sfa=1,fc=cnt,su=1; for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; add(fu,sa[vet[e]]); //sb[vet[e]]*f[vet[e]]; add(ffa,1ll*a[vet[e]]*sb[vet[e]]%Mod); add(fu,1ll*b[vet[e]]*sb[vet[e]]%Mod); add(su,1ll*c[vet[e]]*sb[vet[e]]%Mod); add(fc,1ll*d[vet[e]]*sb[vet[e]]%Mod); add(fc,sd[vet[e]]); &#125; int suma=0,sumb=0,sumc=0,sumd=0; for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; add(suma,a[vet[e]]); add(sumb,b[vet[e]]); add(sumc,c[vet[e]]); add(sumd,d[vet[e]]); &#125; ll inv=getinv(Mod+1-sumc); sa[u]=inv*suma%Mod; sb[u]=inv*sumb%Mod; sd[u]=inv*sumd%Mod; add(ffa,1ll*su*sa[u]%Mod); add(fu,1ll*su*sb[u]%Mod); add(fc,1ll*su*sd[u]%Mod); fu=(Mod-fu)%Mod; inv=getinv(fu); fu=inv*fu%Mod; ffa=inv*ffa%Mod; ffafa=inv*ffafa%Mod; sfa=inv*sfa%Mod; fc=inv*fc%Mod; a[u]=ffafa; b[u]=ffa; c[u]=sfa; d[u]=fc; if (vis[u]) a[u]=0,b[u]=0,c[u]=0,d[u]=0;&#125;void dfs2(int u,int fa)&#123; for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; add(a[vet[e]],1ll*c[vet[e]]*sa[u]%Mod); add(b[vet[e]],1ll*c[vet[e]]*sb[u]%Mod); add(d[vet[e]],1ll*c[vet[e]]*sd[u]%Mod); dfs2(vet[e],u); &#125;&#125;void getans(int u,int fa)&#123; for (int e=Head[u];e;e=Next[e])&#123; if (vet[e]==fa) continue; f[vet[e]]=(1ll*a[vet[e]]*f[fa]+1ll*b[vet[e]]*f[u]+d[vet[e]])%Mod; getans(vet[e],u); &#125;&#125;int main()&#123; freopen(&quot;tree.in&quot;,&quot;r&quot;,stdin); freopen(&quot;tree.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); int u,v; for (int i=1;i&lt;n;i++)&#123; u=read(); v=read(); addedge(u,v); addedge(v,u); &#125; int x; for (int i=1;i&lt;=m;i++)&#123; x=read(); vis[x]=true; &#125; dfs(1,0); dp(1,0,0); dfs2(1,0); f[1]=1ll*getinv(Mod+1-c[1])*d[1]%Mod; getans(1,0); for (int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,f[i]); return 0;&#125;","categories":[{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://example.com/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"树形dp（期望）","slug":"树形dp（期望）","permalink":"http://example.com/tags/%E6%A0%91%E5%BD%A2dp%EF%BC%88%E6%9C%9F%E6%9C%9B%EF%BC%89/"}]},{"title":"20200924 模拟赛题解","slug":"sol_5","date":"2020-09-23T16:00:00.000Z","updated":"2020-09-30T12:09:29.245Z","comments":true,"path":"2020/09/24/sol_5/","link":"","permalink":"http://example.com/2020/09/24/sol_5/","excerpt":"","text":"number \\begin{align*} ans&=\\sum_{i=1}^n\\sum_{j=i}^n\\sum_{p\\in \\mathcal{P}} [p\\mid\\prod_{k=i}^ja_k]\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{j=i}^n [p\\mid\\prod_{k=i}^ja_k]\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{j=i}^n [(p\\mid a_i) \\lor (p\\mid a_{i+1}) \\lor (p\\mid a_{i+2})\\lor\\cdots\\lor(p\\mid a_j)]\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{j=i}^n \\sum_{k=i}^j[(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})\\land (p\\mid a_{k})]\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{k=i}^n \\sum_{j=k}^n[(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})\\land (p\\mid a_{k})]\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{k=i}^n [(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})\\land (p\\mid a_{k})]\\sum_{j=k}^n1\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{i=1}^n\\sum_{k=i}^n [(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})\\land (p\\mid a_{k})]\\cdot (n-k+1)\\\\ &=\\sum_{p\\in \\mathcal{P}}\\sum_{k=1}^n(\\sum_{i=1}^k [(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})\\land (p\\mid a_{k})])\\cdot (n-k+1)\\\\ &=\\sum_{k=1}^n\\sum_{p\\in \\mathcal{P},p\\mid a_k}(n-k+1)(\\sum_{i=1}^k [(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})]) \\end{align*}注意到，求出最大的 $j&lt;k$ 满足 $p\\mid a_j$，那么上式 $\\sum\\limits_{i=1}^k [(p\\nmid a_i) \\land (p\\nmid a_{i+1}) \\land\\cdots\\land (p\\nmid a_{k-1})]=k-j$ 从左往右扫，对于每个 $p$ 记录满足条件的 $j$，就做完了。时间复杂度 $O(n \\ln n)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/********************************************************************* * Source：zr09 - day4 * Problem：number * Author：hydd * Date：2020/9/24*********************************************************************/#include&lt;cstdio&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;int n,lst[1100000],num[1100000];int cnt,prime[1100000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void init(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!lst[i])&#123; lst[i]=i; prime[++cnt]=i; &#125; for (int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123; lst[i*prime[j]]=prime[j]; if (i%prime[j]==0) break; &#125; &#125;&#125;int main()&#123; freopen(&quot;number.in&quot;,&quot;r&quot;,stdin); freopen(&quot;number.out&quot;,&quot;w&quot;,stdout); init(1000000); n=read(); for (int i=2;i&lt;=1000000;i++) num[i]=0; int x,y; ll ans=0; for (int i=1;i&lt;=n;i++)&#123; x=read(); y=-1; while (x!=1)&#123; if (y!=lst[x])&#123; ans+=1ll*(i-num[lst[x]])*(n-i+1); num[lst[x]]=i; &#125; y=lst[x]; x/=lst[x]; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; seq这个数列是个一阶递推数列。 又因为每个值都在 $[0,m)$ 内（除了 $x_0$ 有可能为 $m$）。 所以我们可以通过倍增轻易求出 $x_0=k,\\forall k\\in[0,m]$ 时，$x_i,\\forall i\\in[0,t]$ 的值。 然后，我们考虑每个 $k$，对于所有的 $t_1+t_2=k$，可能的 $|t_1-t_2|$ 的值。 若 $k\\leqslant m$ 若 $k$ 是偶数，可能为 $k,k-2,\\cdots ,2,0,2,\\cdots k-2,k$。即 $0,2,2,4,4,6,6,\\cdots,k,k$。 若 $k$ 是奇数，可能为 $k,k-2,\\cdots ,3,1,1,3,\\cdots k-2,k$。即 $1,1,3,3,5,5,\\cdots,k,k$。 若 $m+1\\leqslant k\\leqslant 2m$ 若 $k$ 是偶数，可能为 $2m-k,2m-k-2,\\cdots ,2,0,2,\\cdots 2m-k-2,2m-k$。即 $0,2,2,4,4,6,6,\\cdots,2m-k,2m-k$。 若 $k$ 是奇数，可能为 $2m-k,2m-k-2,\\cdots ,3,1,1,3,\\cdots 2m-k-2,2m-k$。即 $1,1,3,3,5,5,\\cdots,2m-k,2m-k$。 我们可以倍增记录 $x_0=a,\\forall 0\\leqslant l\\leqslant m,x_0+x_2+x_4+\\cdots,x_{2l}$。 那么偶数的答案可以轻松的算出，奇数的答案的话，先将 $x’_0$ 变为 $x_1$，再类似的做即可。 时间复杂度 $O(n\\log n)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/********************************************************************* * Source：zr09 - day4 * Problem：seq * Author：hydd * Date：2020/9/24*********************************************************************/#include&lt;cstdio&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;const int Mod=1e9+7;int t,a,c,m,k,f[1100000],fa[1100000][21],sum[1100000][21];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;int getsum(int x,int d)&#123; d++; int res=0; for (int i=20;i&gt;=0;i--) if (d&amp;(1&lt;&lt;i))&#123; res=(res+sum[x][i])%Mod; x=fa[x][i]; &#125; return res;&#125;int main()&#123; freopen(&quot;seq.in&quot;,&quot;r&quot;,stdin); freopen(&quot;seq.out&quot;,&quot;w&quot;,stdout); t=read(); a=read(); c=read(); m=read(); k=read(); for (int i=0;i&lt;=m;i++) f[i]=(1ll*a*i+c)%m; for (int i=0;i&lt;=m;i++)&#123; fa[i][0]=f[f[i]]; sum[i][0]=i%k; &#125; for (int j=1;j&lt;=20;j++) for (int i=0;i&lt;=m;i++)&#123; fa[i][j]=fa[fa[i][j-1]][j-1]; sum[i][j]=((sum[i][j-1]+sum[fa[i][j-1]][j-1])%Mod)%Mod; &#125; int ans=0; for (int i=0;i&lt;=t;i++) if (i&amp;1) ans=(ans+2ll*getsum(f[i],(i-1)/2))%Mod; else ans=(ans+2ll*getsum(i,i/2)-i%k)%Mod; for (int i=t+1;i&lt;=t+t;i++) if (i&amp;1) ans=(ans+2ll*getsum(f[i],(2*t-i-1)/2))%Mod; else ans=(ans+2ll*getsum(i,(2*t-i)/2)-i%k)%Mod; printf(&quot;%d\\n&quot;,ans); return 0;&#125; kth将相同的数也钦定一个大小关系，不妨设相同的情况下越靠后的数越大。 将数从大到小排序，求出当前数左边最靠右的 $k$ 个比它大的数和当前数右边靠左的 $k$ 个比它大的数。 这个可以用个链表串起来（直接 $set$ 暴力查是 $k\\log n$ 的，链表的话少个 $\\log$）然后求。 之后就随便求就好了，枚举左边有多少个比它大的即可。 时间复杂度 $O(n\\log n+nk)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/********************************************************************* * Source：zr09 - day4 * Problem：kth * Author：hydd * Date：2020/9/24*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;utility&gt;#include&lt;functional&gt;#include&lt;set&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;const int Mod=1e9+7;typedef pair&lt;int,int&gt; pii;int n,k,a[210000];int num1[210000],num2[210000];int nxt[210000],lst[210000];pii tmp[210000]; set&lt;int&gt; s;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;int main()&#123; freopen(&quot;kth.in&quot;,&quot;r&quot;,stdin); freopen(&quot;kth.out&quot;,&quot;w&quot;,stdout); n=read(); k=read(); for (int i=0;i&lt;=n+1;i++) nxt[i]=i,lst[i]=i; for (int i=1;i&lt;=n;i++) tmp[i].first=read(),tmp[i].second=i; sort(tmp+1,tmp+n+1,greater&lt;pii&gt;()); s.insert(0); s.insert(n+1); int x,l,r,ans=0; for (int i=1;i&lt;=n;i++)&#123; x=tmp[i].second; l=*--s.lower_bound(x); r=*s.upper_bound(x); s.insert(x); nxt[l]=x; lst[x]=l; lst[r]=x; nxt[x]=r; for (int i=1;i&lt;=k+1;i++) num1[i]=0,num2[i]=n+1; int cnt1=0,cnt2=0,now; now=x; while (cnt1&lt;=k&amp;&amp;now)&#123; num1[++cnt1]=now; now=lst[now];&#125; now=nxt[x]; while (cnt2&lt;=k&amp;&amp;now)&#123; num2[++cnt2]=now; now=nxt[now];&#125; for (int l=1;l&lt;=k;l++)&#123; int r=k-l+1; ans=(ans+1ll*(num1[l]-num1[l+1])*(num2[r]-x)%Mod*tmp[i].first)%Mod; &#125;// printf(&quot;%d\\n&quot;,ans); &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;/*6 296 29 71 28 91 64*/ subseq一般子序列的 $dp$，就是 $dp[i][j]=\\begin{cases} 1+\\sum\\limits_k dp[i-1][k] &amp; j=s_i \\\\ dp[i-1][j] &amp; j\\neq s_i\\end{cases}$ 现在要求 $\\bmod 2$ 的值，那就是 $dp[i][j]=\\begin{cases} 1\\oplus\\bigoplus\\limits_k dp[i-1][k] &amp; j=s_i \\\\ dp[i-1][j] &amp; j\\neq s_i\\end{cases}$ 可以发现一些性质： 若原来 $dp[i-1]$ 有奇数个 $1$，现在是一个 $dp[i-1][c]=0$ 的字符 $c$，那么 $dp[i-1][c]$ 没有任何变化。 若原来 $dp[i-1]$ 有奇数个 $1$，现在是一个 $dp[i-1][c]=1$ 的字符 $c$，那么 $dp[i-1][c]$ 变为了 $0$。 若原来 $dp[i-1]$ 有偶数个 $1$，现在是一个 $dp[i-1][c]=0$ 的字符 $c$，那么 $dp[i-1][c]$ 变为了 $1$。 若原来 $dp[i-1]$ 有偶数个 $1$，现在是一个 $dp[i-1][c]=1$ 的字符 $c$，那么 $dp[i-1][c]$ 没有任何变化。 那么，我们会发现，$dp[i-1]$ 中只有一个字符 $c$ 满足 $dp[i][c]=1$，其余位置都为 $0$。不妨记录这个字符。 考虑加入一个字符 $s_i$： 若 $c=\\emptyset$，由性质 3.，$c’=s_i$。 若 $c=s_i$，由性质 2.，$c’=\\emptyset$。 否则，由性质 1.，$c’=c$。 由于我们要合并两个字符串，所有需要知道所有 $c$ 作为初始时，每个字符串最后会变成哪个 $c’$。 然后直接设 $dp[i][j]$ 表示已经选了状态为 $i$ 的字符串，现在的 $c=j$ 的方案数，直接转移即可。 时间复杂度 $O(2^nn|\\Sigma|)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/********************************************************************* * Source：zr09 - day4 * Problem：subseq * Author：hydd * Date：2020/9/24*********************************************************************/#include&lt;cstdio&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;int n,trans[31][31];ll f[1100000][31];int len,s[110000];char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void readst()&#123; len=0; char ch=Getchar(); while (ch&lt;&#x27;a&#x27;||ch&gt;&#x27;z&#x27;) ch=Getchar(); while (ch&lt;=&#x27;z&#x27;&amp;&amp;ch&gt;=&#x27;a&#x27;) s[++len]=ch-&#x27;a&#x27;,ch=Getchar();&#125;int main()&#123; freopen(&quot;subseq.in&quot;,&quot;r&quot;,stdin); freopen(&quot;subseq.out&quot;,&quot;w&quot;,stdout); n=read(); for (int i=0;i&lt;n;i++)&#123; readst(); for (int c=0;c&lt;=26;c++)&#123; int now=c; for (int j=1;j&lt;=len;j++) if (now==26) now=s[j]; else if (now==s[j]) now=26; trans[i][c]=now; &#125; &#125; int upperlim=(1&lt;&lt;n)-1; f[0][26]=1; for (int i=0;i&lt;upperlim;i++) for (int j=0;j&lt;n;j++) if (!(i&amp;(1&lt;&lt;j))) for (int c=0;c&lt;=26;c++) f[i|(1&lt;&lt;j)][trans[j][c]]+=f[i][c]; ll ans=0; for (int c=0;c&lt;=25;c++) ans+=f[upperlim][c]; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;","categories":[{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://example.com/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"zr9月线下","slug":"zr9月线下","permalink":"http://example.com/tags/zr9%E6%9C%88%E7%BA%BF%E4%B8%8B/"}]},{"title":"CF555E 题解","slug":"sol_6","date":"2020-09-23T16:00:00.000Z","updated":"2020-09-30T12:00:18.369Z","comments":true,"path":"2020/09/24/sol_6/","link":"","permalink":"http://example.com/2020/09/24/sol_6/","excerpt":"","text":"CF555E题意给定一个 $n$ 个点 $m$ 条边的无向图。有 $q$ 个人，第 $i$ 个人要从 $s_i$ 到 $t_i$。 现在你要给无向图的每条边定向。问是否存在一种定向方法使得所有人都能够到达目的地。 $n,m,q\\leqslant 2\\times 10^5,u_i\\neq v_i,s_i\\neq t_i$ subtask1（1-8，20pts）：$n\\leqslant 8,m\\leqslant 15,q\\leqslant 8$。 subtask2（11-13，10pts）：保证原图是一个菊花图，$m=n-1$。（即有且仅有一个点 $u$，它向其它所有点都有一条边） subtask3（14-15，10pts）：保证图是一条链，$m=n-1$。 subtask4（16-20，30pts）：保证图是一棵树，$m=n-1$。（依赖subtask 2,3） subtask5（20-30,9,10，30pts）：无特殊限制。（依赖subtask 1,2,3,4） 题解我的做法（186ms）可以发现，对于一个边双来说，一定存在一种定向方法，使得边数内两两点之间均可到达。 所以一个边双相当于一个点。那么我们缩点，把图变成一颗树。这样，$s$ 到 $t$ 只能走树上简单路径。 我们把 $s\\rightarrow LCA$ 的路径打向上的标记，把 $LCA\\rightarrow t$ 的路径打向下的标记。$LCA$ 可以通过倍增预处理。 只要没有一条边同时有两种标记，就是合法的。打标记使用树上差分实现。 时间复杂度：$ O(n+m+q\\log n)$。 有一些细节： 原图不保证连通，所以在缩点，预处理倍增，判断答案的时候要在每个连通块都做一次。 原图可能有重边，所以 $\\rm tarjan$ 的时候要记上一条边的编号而不是父亲节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/********************************************************************* * Source：互测 * Problem：CF555E * Author：hydd * Date：2020/8/30 - 2020/8/31 * Encoding：Simplified Chinese (GB2312)*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;//#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;const int MAXN=210000;const int MAXM=410000;int n,m,q,u[MAXN],v[MAXN];int top,st[MAXN],fr[MAXN],dep[MAXN];int cnt2,fa[MAXN][19]; bool vis[MAXN];int cnt,num[MAXN],up[MAXN],dw[MAXN];int dtime,dfn[MAXN],low[MAXN];vector&lt;int&gt; vec[MAXN];int edgenum=1,vet[MAXM],Next[MAXM],Head[MAXN];void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;void tarjan(int u,int le)&#123;//2. dfn[u]=low[u]=++dtime; st[++top]=u; int v; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (e==(le^1)) continue; if (!dfn[v])&#123; tarjan(v,e); low[u]=min(low[u],low[v]); &#125; else low[u]=min(low[u],dfn[v]); &#125; if (dfn[u]==low[u])&#123; cnt++; while (st[top]!=u)&#123; num[st[top]]=cnt; top--;&#125; num[st[top]]=cnt; top--; &#125;&#125;void dfs(int u,int f)&#123; fr[u]=cnt2; dep[u]=dep[f]+1; fa[u][0]=f; for (int i=1;(1&lt;&lt;i)&lt;dep[u];i++) fa[u][i]=fa[fa[u][i-1]][i-1]; for (int v:vec[u])&#123; if (v==f) continue; dfs(v,u); &#125;&#125;void dfs2(int u,int f)&#123; vis[u]=true; for (int v:vec[u])&#123; if (v==f) continue; dfs2(v,u); up[u]+=up[v]; dw[u]+=dw[v]; &#125;&#125;int LCA(int x,int y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); int d=dep[x]-dep[y]; for (int i=0;i&lt;=18;i++) if (d&amp;(1&lt;&lt;i)) x=fa[x][i]; if (x==y) return x; for (int i=18;i&gt;=0;i--) if (fa[x][i]!=fa[y][i])&#123; x=fa[x][i]; y=fa[y][i]; &#125; return fa[x][0];&#125;bool check()&#123; int s,t; while (q--)&#123; s=read(); t=read(); s=num[s]; t=num[t]; if (fr[s]!=fr[t]) return false; int w=LCA(s,t); up[s]++; up[w]--; dw[t]++; dw[w]--; &#125; for (int i=1;i&lt;=n;i++) if (!vis[i]) dfs2(i,0);//1. for (int i=1;i&lt;=cnt;i++) if (up[i]&amp;&amp;dw[i]) return false; return true;&#125;int main()&#123; n=read(); m=read(); q=read(); edgenum=1; for (int i=1;i&lt;=m;i++)&#123; u[i]=read(); v[i]=read(); addedge(u[i],v[i]); addedge(v[i],u[i]); &#125; for (int i=1;i&lt;=n;i++) if (!dfn[i]) tarjan(i,0);//1. int x,y; for (int i=1;i&lt;=m;i++)&#123; x=num[u[i]]; y=num[v[i]]; if (x==y) continue; vec[x].push_back(y); vec[y].push_back(x); &#125; for (int i=1;i&lt;=cnt;i++) if (!fr[i])&#123; cnt2++; dfs(i,0);&#125;//1. if (check()) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; CodeForces 最快做法（124ms）思路与前述相同。 使用了 $\\rm tarjan$ 求 $LCA$，时间复杂度 $O(n+m+q)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define N 200002#define E 400003#define Spush(x) (in[sk[++sp]=x]=true)#define Spop() (in[sk[sp--]]=false)#define Stop() (sk[sp])#define Dp (puts(&quot;&quot;))#define Dw printf#define Df(i,s,t) for(int i=s;i&lt;=t;i++)struct Edge&#123;int y,t;&#125;e[E];struct Query&#123;int y,t,ans;&#125;Q[E];bool in[N],used[N],done[N],vis[N],IsPos[N];char ch;int n,m,q,x[N],y[N],qx,qy,h[N],ep=1,sk[N],sp,dfn[N],low[N],tm,color[N],cp,hq[N],qp=1,f[N],djw,djf,djt,dep[N],fa[N],pos[N],neg[N];inline void read(int &amp;x)&#123;x=0;do&#123;ch=getchar();&#125;while(ch&lt;&#x27;0&#x27;||&#x27;9&#x27;&lt;ch);do&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;while(&#x27;0&#x27;&lt;=ch&amp;&amp;ch&lt;=&#x27;9&#x27;);&#125;inline void AddEdge(const int &amp;x,const int &amp;y)&#123;e[++ep].y=y;e[ep].t=h[x];h[x]=ep;&#125;inline void AddQuery(const int &amp;x,const int &amp;y)&#123;Q[++qp].y=y;Q[qp].t=hq[x];hq[x]=qp;&#125;inline int F(const int &amp;x)&#123; djw=x;while(f[djw]!=djw)djw=f[djw];djf=djw; djw=x;while(djw!=djf)&#123;djt=f[djw];f[djw]=djf;djw=djt;&#125; return djf;&#125;void TarjanSCC(const int &amp;x)&#123; dfn[x]=low[x]=++tm; Spush(x); for(int i=h[x];i;i=e[i].t) if(!used[i&gt;&gt;1]) &#123; if(!dfn[e[i].y]) &#123; used[i&gt;&gt;1]=true; TarjanSCC(e[i].y); low[x]=min(low[x],low[e[i].y]); used[i&gt;&gt;1]=false; &#125; else if(in[e[i].y])low[x]=min(low[x],dfn[e[i].y]); &#125; if(dfn[x]==low[x]) &#123; color[x]=++cp; while(Stop()!=x) &#123; color[Stop()]=cp; Spop(); &#125; Spop(); &#125;&#125;void TarjanLCA(const int &amp;x)&#123; done[x]=true; for(int i=h[x];i;i=e[i].t) if(!done[e[i].y])TarjanLCA(e[i].y),f[e[i].y]=x; for(int i=hq[x];i;i=Q[i].t) if(done[Q[i].y])Q[i|1].ans=F(Q[i].y);&#125;void dfs(const int &amp;x)&#123; for(int i=h[x];i;i=e[i].t) if(e[i].y!=fa[x]) &#123; fa[e[i].y]=x; dep[e[i].y]=dep[x]+1; dfs(e[i].y); &#125;&#125;void GetPosUp(const int &amp;x)&#123; vis[x]=true; for(int i=h[x];i;i=e[i].t) if(!vis[e[i].y]) &#123; GetPosUp(e[i].y); pos[x]=max(pos[x],pos[e[i].y]-1); &#125; if(pos[x])IsPos[x]=true;&#125;void GetNegUp(const int &amp;x)&#123; vis[x]=true; for(int i=h[x];i;i=e[i].t) if(!vis[e[i].y]) &#123; GetNegUp(e[i].y); neg[x]=max(neg[x],neg[e[i].y]-1); &#125; if(neg[x])if(IsPos[x])&#123;puts(&quot;No&quot;);exit(0);&#125;&#125;int main(void)&#123; read(n),read(m),read(q); for(int i=1;i&lt;=m;i++)read(x[i]),read(y[i]),AddEdge(x[i],y[i]),AddEdge(y[i],x[i]); for(int i=1;i&lt;=n;i++)if(!dfn[i])TarjanSCC(i); memset(e,0,sizeof(e)); memset(h,0,sizeof(h)); ep=1; for(int i=1;i&lt;=m;i++)if(color[x[i]]!=color[y[i]])AddEdge(color[x[i]],color[y[i]]),AddEdge(color[y[i]],color[x[i]]); for(int i=1;i&lt;=q;i++) &#123; read(qx),read(qy); if(color[qx]!=color[qy])AddQuery(color[qx],color[qy]),AddQuery(color[qy],color[qx]); &#125; for(int i=1;i&lt;=cp;i++)f[i]=i; for(int i=1;i&lt;=cp;i++)if(!done[i])TarjanLCA(i); for(int i=1;i&lt;=cp;i++)if(!dep[i])dep[i]=1,dfs(i); for(int i=2;i&lt;=qp;i+=2) &#123; pos[Q[i|1].y]=dep[Q[i|1].y]-dep[Q[i|1].ans]; neg[Q[i].y]=dep[Q[i].y]-dep[Q[i|1].ans]; &#125; for(int i=1;i&lt;=n;i++)if(!vis[i])GetPosUp(i); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++)if(!vis[i])GetNegUp(i); puts(&quot;Yes&quot;); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/categories/Codeforces/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"http://example.com/tags/Tarjan/"}]},{"title":"僵尸","slug":"sol_1","date":"2020-08-22T16:00:00.000Z","updated":"2020-09-30T12:07:01.973Z","comments":true,"path":"2020/08/23/sol_1/","link":"","permalink":"http://example.com/2020/08/23/sol_1/","excerpt":"","text":"题目大意 给定一棵 $n$ 个点的无根树，每条边有一堵墙，高度在 $[l_i,r_i]$ 等概率出现。 有 $m$ 个僵尸，第 $i$ 只僵尸初始出生在 $x_i$ 点，能力值为 $h_i$，表示可以走过墙的高度 $&lt;h_i$ 的边。 称一个点是安全的，当且仅当它不能被任何一个僵尸走到。 求树上至少有一个点是安全的概率，对 $998244353$ 取模，有 $T$ 组数据。 $T\\leqslant 5,1\\leqslant n,m\\leqslant 2000,1\\leqslant x_i\\leqslant n,1\\leqslant l_i,r_i,h_i\\leqslant 10^9$，保证 $r_i-l_i+1\\neq 998244353$。 $\\texttt{source:[Nowcoder2018 ACM多校第十场 I] Rikka with Zombies}$。 题解先说说考场的思路： 首先，因为所有高度都是等概率的，所以可以用 $p=\\frac{\\texttt{至少有一个点是安全的方案数}}{\\texttt{总方案数}}$ 得到答案，而 $1-p=\\frac{\\texttt{所有点都不安全的方案数}}{\\texttt{总方案数}}$，所以我们可以算所有点都不安全的方案数。 这个东西并不容易直接算，而这种树上计数问题一般考虑树形 $dp$。 所以，我当时设的是 $dp[u][i]$ 表示以 $u$ 为根，$u$ 子树内的所有点都是不安全的，且 $u$ 子树内能走到 $u$ 的能力值最大的僵尸编号。然后我们会发现，$u$ 子树内的一些点可能可以从子树外的僵尸走到，所以就不行了。 正解： 一般的树形 $dp$ 是只考虑子树内的，但是这题是要考虑子树外的。 设的是 $dp[u][i]$ 表示以 $u$ 为根，$u$ 子树内的所有点都是不安全的，子树外皆有可能，且能走到 $u$ 的能力值最大的僵尸编号（可以在子树外）。 考虑 $f[v][b]$ 对 $f[u][a]$ 的贡献， $v$ 是 $u$ 的一个孩子。 若 $a=b$，不论 $a$ 在 $v$ 子树内还是子树外，都必须能跨过 $(u,v)$。那么 $f[u][a]+=f[u][a]\\times f[v][b]\\times(a\\texttt{能跨过}(u,v)\\texttt{的方案数})$。 若 $a\\neq b$，那么 $a,b$ 必定不同时在 $v$ 子树内或 $v$ 子树外，且它们两者能力值较大的必定不能跨过 $(u,v)$。 具体来说，若 $ab$，且 $a$ 在子树 $v$ 外，$b$ 在子树 $v$ 内，那么 $f[u][a]+=f[u][a]\\times f[v][b]\\times(a\\texttt{不能跨过}(u,v)\\texttt{的方案数})$。 初值怎么设呢？设 $u$ 点出生的能力值最大的僵尸为 $k$（没有则为 $1$）， 则对于所有 $i\\geqslant k$，$f[u][i]=1$。 但是，如果 $x[a]..u$ 之间的最小的 $l$ 都 $\\geqslant h_a$ 的话，那贡献应该为 $0$，那它在 $dp$ 中会不会有贡献？ 而在它们两个的 $LCA$ 的时候，贡献必定已经消失了，因为必定有一条边不能跨过，贡献是乘起来的，所以就是 $0$。也就是，它在 $LCA$ 的时候才能保证 $dp$ 值是正确的，在其他位置有可能是错误的，比较奇怪。显然的是， $f[1]$ 的值是对的，答案显然是 $\\sum_i f[1][i]$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/********************************************************************* * Source：CSP-S模拟赛 * Problem：zombie * Author：hydd * Date：2020/8/21 * Encoding：Simplified Chinese (GB2312)*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;bitset&gt;using namespace std;typedef long long ll;const int MAXN=2100;const int MAXE=4100;const int Mod=998244353;int T,n,m,l[MAXN],r[MAXN],f[MAXN][MAXN],tmp[MAXN];int edgenum,vet[MAXE],Next[MAXE],Head[MAXN];bitset&lt;MAXN&gt; vis[MAXN];struct node&#123; int x,v; bool operator&lt;(const node &amp;a) const&#123; return v&lt;a.v;&#125;&#125; a[MAXN];inline int getnum(int t,int v)&#123; return max(0,min(v-1,r[t])-l[t]+1);&#125;char Getchar()&#123; static char now[1&lt;&lt;20],*S,*T; if (T==S)&#123; T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; &#125; return *S++;&#125;int read()&#123; int x=0,f=1; char ch=Getchar(); while (ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if (ch==&#x27;-&#x27;) f=-1; ch=Getchar(); &#125; while (ch&lt;=&#x27;9&#x27;&amp;&amp;ch&gt;=&#x27;0&#x27;) x=x*10+ch-&#x27;0&#x27;,ch=Getchar(); return x*f;&#125;ll qpow(ll x,int a)&#123; ll res=1; while (a)&#123; if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; &#125; return res;&#125;void addedge(int u,int v)&#123; vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum;&#125;void dfs(int u,int fa)&#123; int pos=1,v,sum; for (int i=1;i&lt;=m;i++) if (a[i].x==u) vis[u][i]=1,pos=i; else vis[u][i]=0; for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (v==fa) continue; dfs(v,u); vis[u]|=vis[v]; &#125; for (int i=1;i&lt;=m;i++) f[u][i]=(i&gt;=pos); for (int e=Head[u];e;e=Next[e])&#123; v=vet[e]; if (v==fa) continue; int t=e&gt;&gt;1; for (int i=1;i&lt;=m;i++) tmp[i]=f[u][i],f[u][i]=0; for (int i=1;i&lt;=m;i++)&#123;//i=j int k=getnum(t,a[i].v); f[u][i]=(f[u][i]+1ll*tmp[i]*f[v][i]%Mod*k)%Mod; &#125; sum=0; for (int i=1;i&lt;=m;i++)&#123;//i&gt;j，i在子树外，j在子树内 int k=getnum(t,a[i].v); if (vis[v][i]) sum=(sum+f[v][i])%Mod;//在子树内，记录前缀和 else f[u][i]=(f[u][i]+1ll*tmp[i]*sum%Mod*(r[t]-l[t]+1-k))%Mod; &#125; sum=0; for (int i=m;i&gt;=1;i--)&#123;//i&lt;j，i在子树外，j在子树内 int k=getnum(t,a[i].v); if (vis[v][i]) sum=(sum+1ll*f[v][i]*(r[t]-l[t]+1-k))%Mod;//在子树内，记录前缀和 else f[u][i]=(f[u][i]+1ll*tmp[i]*sum)%Mod; &#125; &#125;&#125;int main()&#123; freopen(&quot;zombie.in&quot;,&quot;r&quot;,stdin); freopen(&quot;zombie.out&quot;,&quot;w&quot;,stdout); T=read(); while (T--)&#123; n=read(); m=read(); int ans=0,ans2=1; edgenum=1; for (int i=1;i&lt;=n;i++) Head[i]=0; int u,v; for (int i=1;i&lt;n;i++)&#123; u=read(); v=read(); l[i]=read(); r[i]=read(); ans2=1ll*ans2*(r[i]-l[i]+1)%Mod; addedge(u,v); addedge(v,u); &#125; for (int i=1;i&lt;=m;i++) a[i].x=read(),a[i].v=read(); sort(a+1,a+m+1); dfs(1,0); for (int i=1;i&lt;=m;i++) ans=(ans+f[1][i])%Mod; ans=1ll*ans*qpow(ans2,Mod-2)%Mod; printf(&quot;%d\\n&quot;,(Mod+1-ans)%Mod); &#125; return 0;&#125;","categories":[{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://example.com/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"树形dp（概率）","slug":"树形dp（概率）","permalink":"http://example.com/tags/%E6%A0%91%E5%BD%A2dp%EF%BC%88%E6%A6%82%E7%8E%87%EF%BC%89/"}]},{"title":"20200812 模拟赛题解","slug":"sol_7","date":"2020-08-11T16:00:00.000Z","updated":"2020-09-30T12:09:35.724Z","comments":true,"path":"2020/08/12/sol_7/","link":"","permalink":"http://example.com/2020/08/12/sol_7/","excerpt":"","text":"Query在一次询问后，“预测答案”，并安排后两次询问。 预测成功，两次询问有效。预测失败，就浪费了两次询问。 我们定义一个数列 $a[x]=a[x-1]+a[x-3]+1$（$+1$是等号的情况），$a[1]=0,a[2]=0,a[3]=1$。表示通过这个方法，用 $x$ 次可以询问出值域在 $[1,a[x]]$ 之间的所有数。显然，$3$ 次可以问出一个数。 在第三步询问时，第一步询问的答案已经出来了。 若答案为 $=$，即为这个数； 若答案为 $&gt;$，则后面两次询问浪费，结构和后面的询问没关系。将 $x-=3$，当做一个子问题递归处理； 若答案为 $&lt;$，用类似的方法，第四步询问 $a[x-2]$ 的左子区间（长度为 $a[x-3]$）的第 $a[x-4]+1$ 个数，此时得出了第二步的答案，类似的处理即可。 不管怎样，三步询问后，下一次询问的区间长度都为 $a[x-3]$。则总共需要的次数是 $O(x)$级别的。 又因为 $a[56]&gt;10^9$，所以次数不超过 $56$ 次。 12345678910111213141516171819202122232425#include &quot;query.hpp&quot;#include&lt;algorithm&gt;using namespace std;int a[510];void guess()&#123; a[3]=1; int x; for (int i=4;i&lt;=500;i++)&#123; a[i]=a[i-1]+a[i-3]+1; if (a[i]&gt;=1000000000)&#123; x=i; break;&#125; &#125; int L=1; while (true)&#123; if (query(L+a[max(x-1,0)])==&#x27;=&#x27;) return; if (query(L+a[max(x-2,0)])==&#x27;=&#x27;) return; while (true)&#123; char ch=query(L+a[max(x-3,0)]); if (ch==&#x27;=&#x27;) return; if (ch==&#x27;&lt;&#x27;)&#123; L+=a[max(x-1,0)]+1; x-=3; break; &#125; x--; &#125; &#125;&#125; Xorsum有一些显然的条件：和不小于异或和（$s\\geq x$），和与异或和奇偶性相同（$2\\mid s-x$）。 最大值最小显然可以二分答案 $mid$，如果我们知道每一位有几个 $1$，就可以贪心地得到答案。每次尽量分给 $&lt;m$ 的数（即没有压上界的），分不下的话剩下的分给前面几位暂时 $=m$ 的数（继续压上界）。 怎么求呢？先令 $b_i$ 的奇偶性和 $x$ 第 $2^i$ 位的奇偶性一样，然后再加上 $(s-x)/2$ 的这一位的两倍（此处十分巧妙，先从 $s$ 中减去 $x$ 来固定奇偶性，然后将剩下的每位都是 $2$ 的倍数的加上）。 我们设第 $i$ 位 $1$ 的个数为 $b_i$，我们先求出一个字典序最大的 $b_i$（即先满足 $b_{60}$ 最大，再满足 $b_{59}$ 最大，…）。那么所有可能的 $\\{b_i\\}$ 即为每次把某个 $u$，$b[u]-=2,b[u-1]+=4$ 就是所有答案（由于奇偶性不能变）。 直接 $dp$ 模拟这个过程。设 $dp[i][j]$ 表示决定好了从高到低的前 $i$ 位，当前有 $j$ 个数已经小于 $m$，这时候 $b[i-1]$ 加多少倍的 $4$ 。 那么当前的 $b[i-1]$ 是 $b_0[i-1]+4\\times dp[i][j]$（$b_0$ 就是初始时的那个字典序最大的 $\\{b_i\\}$），令 $u$ 为当前的 $b[i-1]$。 看 $m$ 的 $2^i$ 位 若为 $0$，就必须把 $u$ 整成不超过 $j$，转移到 $f[i-1][j]$（因为超过 $j$ 的话只能选当前暂时 $=m$，而 $m$ 当前位为 $0$，所以它们当前位不能为 $1$），那么要从当前的 $b$ 减去 $(max(u-j,0)+1)/2\\times 2$（必须减去偶数个，$(x+1)/2\\times 2$ 即为 $\\geq x$ 的最小偶数）。 若为 $1$，如果当前的 $u\\leq n$，那么新的 $j_new=\\max(\\min(n-(u-j),n),j)$ 时（先尽量把 $u$ 放在 $j$ 中，那么剩下的 $u-j$ 个必须为 $1$，它们依旧压上界，其它的可以不压上界）。对于其它的 $j’$，先尽量把 $j’$ 放在 $j$ 中，那么剩下的 $j’-j$ 必须为 $1$，而剩下必须要留下 $u\\bmod 2$ 个。令 $v=n-(j’-j)$，那么当前留下 $\\min(u,(v-u\\bmod 2)/2\\times 2+u\\bmod 2)$。那么当前行都减去 $u-\\min(u,(v-u\\bmod 2)/2\\times 2+u\\bmod 2)$，下一行减去 $2\\min(u,(v-u\\bmod 2)/2\\times 2+u\\bmod 2)$。 注意到：如果有 $f[i][j]=0$ 且 $j\\geq 3$，那么一定有解，因为初始的 $b$ 都不超过 $3$，把这些放到 $j$ 个数中即可；另外一个是我们并不需要用借位一次将 $j$ 增加太多，因为如果借了 $2$，后面就要还 $4$，所以不应该借太多（？）。 因此我们只需要转移到 $j&lt;5$ 或 $j’-j&lt;2$ 的状态，状态数就是 $O(\\log)$ 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/********************************************************************* Problem:Xor Sum Source:Easy Contest #2 - by zzq Author:hydd Date:2020/8/12 Encoding:UTF-8*********************************************************************/#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cassert&gt;#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout)using namespace std;typedef long long ll;const ll INF=2e18;ll n,s,x,t,f[64],g[64];inline void chkmin(ll &amp;x,ll y)&#123; if (x&gt;y) x=y;&#125;bool check(ll mid)&#123; t=s-x; if (t&lt;0||(t&amp;1)) return false; t/=2; f[0]=0; for (ll j=1;j&lt;64;j++) f[j]=INF; ll m=min(3ll,n); for (ll i=59;i&gt;=0;i--)&#123; for (ll j=0;j&lt;64;j++) g[j]=INF; for (ll j=0;j&lt;=m;j++)&#123; ll u=f[j]*4; if (x&amp;1ll&lt;&lt;i) u++;//令b的奇偶性和x那位一样 if (t&amp;1ll&lt;&lt;i) u+=2;//然后再加上(s-x)/2的这一位的两倍 if (mid&amp;(1ll&lt;&lt;i))&#123; if (u&lt;=n)&#123; ll k=max(min(n-(u-j),n),(ll)j);//注意一定要开long long，否则可能越界边负数下面判不掉 if (k&gt;=3) return true; chkmin(g[k],0); &#125; for (int k=j;(k&lt;5||k-j&lt;2)&amp;&amp;k&lt;=n;k++)&#123; ll v=n-(k-j);//先尽量把k放在j中，那么剩下的k-j必须为1 if (v&gt;=u%2)&#123;//至少要留下u%2个数，e必须为偶数，奇偶性不变 ll e=u-min(u,(v-u%2)/2*2+u%2); assert(e%2==0); //当前减去e，下一行减去2e，即4(e/2) chkmin(g[k],e/2); &#125; &#125; &#125; else&#123; ll e=(max(u-j,0ll)+1)/2;//当前有u个数，而剩下不超过j个数，多余的下传 if (e*2&gt;u) continue;//当前减去2e，下一行减去4e，即4(e) chkmin(g[j],e); &#125; &#125; m++; m=min((ll)m,n); swap(f,g); &#125; for (int i=0;i&lt;=m;i++) if (!f[i]) return true; return false;&#125;void solve()&#123; scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;s,&amp;x); ll l=0,r=s+1,mid; while (l&lt;r)&#123; mid=(l+r)&gt;&gt;1; if (check(mid)) r=mid; else l=mid+1; &#125; if (r==s+1) puts(&quot;-1&quot;); else printf(&quot;%lld\\n&quot;,r);&#125;int T;int main()&#123; File(&quot;xs&quot;); scanf(&quot;%d&quot;,&amp;T); while (T--) solve(); return 0;&#125;/*14 8 0*/ Path首先，将它看成在坐标轴上，每次往右上或右下走一格，不能经过 $y=-1$ 和 $y=m-n+1$，问走到 $(n+m,m-n)$ 的方案数。 直接容斥翻折即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#define int long longusing namespace std;typedef long long ll;const int Mod=998244353;int n,m,a,b,tmp1,tmp2,ans;ll inv[20000005];inline int add(int x,int y)&#123; return x+y&gt;=Mod?x+y-Mod:x+y;&#125;inline int dec(int x,int y)&#123; return x-y&lt;0?x-y+Mod:x-y;&#125;inline int C(int x)&#123; if (x&lt;0) return 0; if (x&gt;n+m) return 0; return inv[x]*inv[n+m-x]%Mod;&#125;signed main()&#123; freopen(&quot;path.in&quot;,&quot;r&quot;,stdin); freopen(&quot;path.out&quot;,&quot;w&quot;,stdout); inv[1]=1; for (int i=2;i&lt;=20000000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=20000000;i++) inv[i]=inv[i-1]*inv[i]%Mod; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); n--; m--; ans=C(m); ll mul=1; for (int i=1;i&lt;=n+m;i++) mul=mul*i%Mod; a=m-n; b=m-n; tmp1=2*(-1); tmp2=2*(m-n+1); for (int i=1;i&lt;=20000000;i++)&#123; if (i&amp;1)&#123; a=tmp1-a;//关于y=-1对称 b=tmp2-b;//关于y=m-n+1对称 &#125; else&#123; a=tmp2-a;//关于y=m-n+1对称 b=tmp1-b;//关于y=-1对称 &#125; if (i&amp;1)&#123; ans=dec(ans,C((a+n+m)&gt;&gt;1)); ans=dec(ans,C((b+n+m)&gt;&gt;1)); &#125; else&#123; ans=add(ans,C((a+n+m)&gt;&gt;1)); ans=add(ans,C((b+n+m)&gt;&gt;1)); &#125; &#125; printf(&quot;%lld\\n&quot;,1ll*ans*mul%Mod); return 0;&#125;/*5000000 10000000100000 200000*/","categories":[{"name":"NOI模拟赛","slug":"NOI模拟赛","permalink":"http://example.com/categories/NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"zzq","slug":"zzq","permalink":"http://example.com/tags/zzq/"}]}],"categories":[{"name":"CSP-S模拟赛","slug":"CSP-S模拟赛","permalink":"http://example.com/categories/CSP-S%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/categories/Codeforces/"},{"name":"NOI模拟赛","slug":"NOI模拟赛","permalink":"http://example.com/categories/NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"tags":[{"name":"树形dp（期望）","slug":"树形dp（期望）","permalink":"http://example.com/tags/%E6%A0%91%E5%BD%A2dp%EF%BC%88%E6%9C%9F%E6%9C%9B%EF%BC%89/"},{"name":"zr9月线下","slug":"zr9月线下","permalink":"http://example.com/tags/zr9%E6%9C%88%E7%BA%BF%E4%B8%8B/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://example.com/tags/Tarjan/"},{"name":"树形dp（概率）","slug":"树形dp（概率）","permalink":"http://example.com/tags/%E6%A0%91%E5%BD%A2dp%EF%BC%88%E6%A6%82%E7%8E%87%EF%BC%89/"},{"name":"zzq","slug":"zzq","permalink":"http://example.com/tags/zzq/"}]}